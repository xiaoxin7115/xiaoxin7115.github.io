<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的博客beginning</title>
    <url>/2022/04/02/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2beginning/</url>
    <content><![CDATA[<p>爱猪妮是终身浪漫的开始</p>
<blockquote>
<p>亲爱的，你知道嘛。其实我一直在寻觅有什么方法可以不去喜欢你，现在终于明白…我对你的爱恋早溶入血液，渗到骨髓并且永久的驻留在身体的每个细胞里。我就这样不停的喜欢你喜欢你喜欢你喜欢你……直到停止心跳与呼吸……</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/04/15/MySQL/</url>
    <content><![CDATA[<p>mysql</p>
<span id="more"></span>

<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h2><ul>
<li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li>
<li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li>
<li>DQL: 数据查询语言，用来查询数据库中表的记录</li>
<li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li>
</ul>
<h3 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h3><p>数据定义语言</p>
<h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>查询所有数据库：<br><code>SHOW DATABASES;</code><br>查询当前数据库：<br><code>SELECT DATABASE();</code><br>创建数据库：<br><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code><br>删除数据库：<br><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code><br>使用数据库：<br><code>USE 数据库名;</code></p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li>
</ul>
<h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><p>查询当前数据库所有表：<br><code>SHOW TABLES;</code><br>查询表结构：<br><code>DESC 表名;</code><br>查询指定表的建表语句：<br><code>SHOW CREATE TABLE 表名;</code></p>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段1 字段1类型 [COMMENT 字段1注释],</span><br><span class="line">	字段2 字段2类型 [COMMENT 字段2注释],</span><br><span class="line">	字段3 字段3类型 [COMMENT 字段3注释],</span><br><span class="line">	...</span><br><span class="line">	字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure>
<p><strong>最后一个字段后面没有逗号</strong></p>
<p>添加字段：<br><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></p>
<p>修改数据类型：<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code><br>修改字段名和字段类型：<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：将emp表的nickname字段修改为username，类型为varchar(30)<br><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></p>
<p>删除字段：<br><code>ALTER TABLE 表名 DROP 字段名;</code></p>
<p>修改表名：<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></p>
<p>删除表：<br><code>DROP TABLE [IF EXISTS] 表名;</code><br>删除表，并重新创建该表：<br><code>TRUNCATE TABLE 表名;</code></p>
<h3 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>指定字段：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code><br>全部字段：<br><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></p>
<p>批量添加数据：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p>
<h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>字符串和日期类型数据应该包含在引号中</li>
<li>插入的数据大小应该在字段的规定范围内</li>
</ul>
<h4 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h4><p>修改数据：<br><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code><br>例：<br><code>UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;</code></p>
<p>删除数据：<br><code>DELETE FROM 表名 [ WHERE 条件 ];</code></p>
<h3 id="DQL（数据查询语言）"><a href="#DQL（数据查询语言）" class="headerlink" title="DQL（数据查询语言）"></a>DQL（数据查询语言）</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	字段列表</span><br><span class="line">FROM</span><br><span class="line">	表名字段</span><br><span class="line">WHERE</span><br><span class="line">	条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">	分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">	分组后的条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>

<h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><p>查询多个字段：<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code><br><code>SELECT * FROM 表名;</code></p>
<p>设置别名：<br><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</code><br><code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></p>
<p>去除重复记录：<br><code>SELECT DISTINCT 字段列表 FROM 表名;</code></p>
<p>转义：<br><code>SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;</code><br>/ 之后的_不作为通配符</p>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></p>
<p>条件：</p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt; 或 !=</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN … AND …</td>
<td>在某个范围内（含最小、最大值）</td>
</tr>
<tr>
<td>IN(…)</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>LIKE 占位符</td>
<td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>AND 或 &amp;&amp;</td>
<td>并且（多个条件同时成立）</td>
</tr>
<tr>
<td>OR 或 &#124;&#124;</td>
<td>或者（多个条件任意一个成立）</td>
</tr>
<tr>
<td>NOT 或 !</td>
<td>非，不是</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 年龄等于30</span><br><span class="line">select * from employee where age = 30;</span><br><span class="line">-- 年龄小于30</span><br><span class="line">select * from employee where age &lt; 30;</span><br><span class="line">-- 小于等于</span><br><span class="line">select * from employee where age &lt;= 30;</span><br><span class="line">-- 没有身份证</span><br><span class="line">select * from employee where idcard is null or idcard = &#x27;&#x27;;</span><br><span class="line">-- 有身份证</span><br><span class="line">select * from employee where idcard;</span><br><span class="line">select * from employee where idcard is not null;</span><br><span class="line">-- 不等于</span><br><span class="line">select * from employee where age != 30;</span><br><span class="line">-- 年龄在20到30之间</span><br><span class="line">select * from employee where age between 20 and 30;</span><br><span class="line">select * from employee where age &gt;= 20 and age &lt;= 30;</span><br><span class="line">-- 下面语句不报错，但查不到任何信息</span><br><span class="line">select * from employee where age between 30 and 20;</span><br><span class="line">-- 性别为女且年龄小于30</span><br><span class="line">select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;</span><br><span class="line">-- 年龄等于25或30或35</span><br><span class="line">select * from employee where age = 25 or age = 30 or age = 35;</span><br><span class="line">select * from employee where age in (25, 30, 35);</span><br><span class="line">-- 姓名为两个字</span><br><span class="line">select * from employee where name like &#x27;__&#x27;;</span><br><span class="line">-- 身份证最后为X</span><br><span class="line">select * from employee where idcard like &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="聚合查询（聚合函数）"><a href="#聚合查询（聚合函数）" class="headerlink" title="聚合查询（聚合函数）"></a>聚合查询（聚合函数）</h4><p>常见聚合函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody></table>
<p>语法：<br><code>SELECT 聚合函数(字段列表) FROM 表名;</code><br>例：<br><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></p>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></p>
<p>where 和 having 的区别：</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span><br><span class="line">select count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性数量</span><br><span class="line">select gender, count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性的平均年龄</span><br><span class="line">select gender, avg(age) from employee group by gender;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组</span><br><span class="line">select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>执行顺序：where &gt; 聚合函数 &gt; having</li>
<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li>
</ul>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></p>
<p>排序方式：</p>
<ul>
<li>ASC: 升序（默认）</li>
<li>DESC: 降序</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据年龄升序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC;</span><br><span class="line">SELECT * FROM employee ORDER BY age;</span><br><span class="line">-- 两字段排序，根据年龄升序排序，入职时间降序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询第一页数据，展示10条</span><br><span class="line">SELECT * FROM employee LIMIT 0, 10;</span><br><span class="line">-- 查询第二页</span><br><span class="line">SELECT * FROM employee LIMIT 10, 10;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数</li>
<li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li>
</ul>
<h4 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h4><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><p>查询用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER mysql;</span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure>

<p>创建用户:<br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></p>
<p>修改用户密码：<br><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></p>
<p>删除用户：<br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建用户test，只能在当前主机localhost访问</span><br><span class="line">create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 创建用户test，能在任意主机访问</span><br><span class="line">create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">create user &#x27;test&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 修改密码</span><br><span class="line">alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;</span><br><span class="line">-- 删除用户</span><br><span class="line">drop user &#x27;test&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>主机名可以使用 % 通配</li>
</ul>
<h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>常用权限：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL, ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库/表/视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库/表</td>
</tr>
</tbody></table>
<p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p>
<p>查询权限：<br><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
<p>授予权限：<br><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
<p>撤销权限：<br><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
<h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>多个权限用逗号分隔</li>
<li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>字符串函数</li>
<li>数值函数</li>
<li>日期函数</li>
<li>流程函数</li>
</ul>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>常用函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(s1, s2, …, sn)</td>
<td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串全部转为小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串全部转为大写</td>
</tr>
<tr>
<td>LPAD(str, n, pad)</td>
<td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>RPAD(str, n, pad)</td>
<td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str, start, len)</td>
<td>返回从字符串str从start位置起的len个长度的字符串</td>
</tr>
</tbody></table>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 拼接</span><br><span class="line">SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);</span><br><span class="line">-- 小写</span><br><span class="line">SELECT LOWER(&#x27;Hello&#x27;);</span><br><span class="line">-- 大写</span><br><span class="line">SELECT UPPER(&#x27;Hello&#x27;);</span><br><span class="line">-- 左填充</span><br><span class="line">SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 右填充</span><br><span class="line">SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 去除空格</span><br><span class="line">SELECT TRIM(&#x27; Hello World &#x27;);</span><br><span class="line">-- 切片（起始索引为1）</span><br><span class="line">SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);</span><br></pre></td></tr></table></figure>

<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>常见函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x, y)</td>
<td>返回x/y的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>ROUND(x, y)</td>
<td>求参数x的四舍五入值，保留y位小数</td>
</tr>
</tbody></table>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>常用函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1, date2)</td>
<td>返回起始时间date1和结束时间date2之间的天数</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- DATE_ADD</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</span><br></pre></td></tr></table></figure>

<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>常用函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value, t, f)</td>
<td>如果value为true，则返回t，否则返回f</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td>如果val1为true，返回res1，… 否则返回default默认值</td>
</tr>
<tr>
<td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">	name,</span><br><span class="line">	(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)</span><br><span class="line">from employee;</span><br><span class="line">select</span><br><span class="line">	name,</span><br><span class="line">	(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>分类：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制该字段的数据不能为null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束（8.0.1版本后）</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody></table>
<p>约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。</p>
<h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><table>
<thead>
<tr>
<th>约束条件</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>自动增长</td>
<td>AUTO_INCREMENT</td>
</tr>
<tr>
<td>不为空</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>逻辑条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>默认值</td>
<td>DEFAULT</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(10) not null unique,</span><br><span class="line">	age int check(age &gt; 0 and age &lt; 120),</span><br><span class="line">	status char(1) default &#x27;1&#x27;,</span><br><span class="line">	gender char(1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>添加外键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	...</span><br><span class="line">	[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);</span><br><span class="line"></span><br><span class="line">-- 例子</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);</span><br></pre></td></tr></table></figure>

<p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p>
<h4 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h4><table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NO ACTION</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td>
</tr>
<tr>
<td>CASCADE</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td>
</tr>
<tr>
<td>SET NULL</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td>
</tr>
</tbody></table>
<p>更改删除/更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul>
<li>一对多（多对一）</li>
<li>多对多</li>
<li>一对一</li>
</ul>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p>
<blockquote>
<p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p>
</blockquote>
<p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p>
<h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><p>内连接查询的是两张表交集的部分</p>
<p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p>
<p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p>
<p>显式性能比隐式高</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询员工姓名，及关联的部门的名称</span><br><span class="line">-- 隐式</span><br><span class="line">select e.name, d.name from employee as e, dept as d where e.dept = d.id;</span><br><span class="line">-- 显式</span><br><span class="line">select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>

<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>左外连接：<br>查询左表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>相当于查询表1的所有数据，包含表1和表2交集部分数据</p>
<p>右外连接：<br>查询右表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 左</span><br><span class="line">select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;</span><br><span class="line">select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样</span><br><span class="line">-- 右</span><br><span class="line">select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>

<p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p>
<h3 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p>
<p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p>
<p>自连接查询，可以是内连接查询，也可以是外连接查询</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询员工及其所属领导的名字</span><br><span class="line">select a.name, b.name from employee a, employee b where a.manager = b.id;</span><br><span class="line">-- 没有领导的也查询出来</span><br><span class="line">select a.name, b.name from employee a left join employee b on a.manager = b.id;</span><br></pre></td></tr></table></figure>

<h3 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 union, union all"></a>联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B ...</span><br></pre></td></tr></table></figure>

<h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>UNION ALL 会有重复结果，UNION 不会</li>
<li>联合查询比使用or效率高，不会使索引失效</li>
</ul>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p>
<p>根据子查询结果可以分为：</p>
<ul>
<li>标量子查询（子查询结果为单个值）</li>
<li>列子查询（子查询结果为一列）</li>
<li>行子查询（子查询结果为一行）</li>
<li>表子查询（子查询结果为多行多列）</li>
</ul>
<p>根据子查询位置可分为：</p>
<ul>
<li>WHERE 之后</li>
<li>FROM 之后</li>
<li>SELECT 之后</li>
</ul>
<h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询销售部所有员工</span><br><span class="line">select id from dept where name = &#x27;销售部&#x27;;</span><br><span class="line">-- 根据销售部部门ID，查询员工信息</span><br><span class="line">select * from employee where dept = 4;</span><br><span class="line">-- 合并（子查询）</span><br><span class="line">select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询xxx入职之后的员工信息</span><br><span class="line">select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure>

<h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。</p>
<p>常用操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>在指定的集合范围内，多选一</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在指定的集合范围内</td>
</tr>
<tr>
<td>ANY</td>
<td>子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td>SOME</td>
<td>与ANY等同，使用SOME的地方都可以使用ANY</td>
</tr>
<tr>
<td>ALL</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询销售部和市场部的所有员工信息</span><br><span class="line">select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="line">select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));</span><br><span class="line">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="line">select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：=, &lt;, &gt;, IN, NOT IN</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询与xxx的薪资及直属领导相同的员工信息</span><br><span class="line">select * from employee where (salary, manager) = (12500, 1);</span><br><span class="line">select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure>

<h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="line">select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);</span><br><span class="line">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="line">select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>基本操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 查询张三账户余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">-- 2. 将张三账户余额-1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">-- 此语句出错后张三钱减少但是李四钱没有增加</span><br><span class="line">模拟sql语句错误</span><br><span class="line">-- 3. 将李四账户余额+1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查看事务提交方式</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="line">SET @@AUTOCOMMIT = 0;</span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 设置手动提交后上面代码改为：</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>操作方式二：</p>
<p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p>
<p>操作实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<h3 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h3><ul>
<li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li>
<li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
<li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li>
</ul>
<h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td>
</tr>
</tbody></table>
<blockquote>
<p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a> </p>
</blockquote>
<p>并发事务隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ul>
<li>√表示在当前隔离级别下该问题会出现</li>
<li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li>
</ul>
<p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p>
<h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL体系结构：</p>
<p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p>
<p>相关操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询建表语句</span><br><span class="line">show create table account;</span><br><span class="line">-- 建表时指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">	...</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line">-- 查看当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure>

<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p>
<p>特点：</p>
<ul>
<li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li>
<li><strong>行级锁</strong>，提高并发访问性能</li>
<li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li>
</ul>
<p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p>
<p>知识点：</p>
<p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p>
<p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p>
<p>InnoDB 逻辑存储结构：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p>
<p>特点：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
<li>xxx.MYD: 存储数据</li>
<li>xxx.MYI: 存储索引</li>
</ul>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>特点：</p>
<ul>
<li>存放在内存中，速度快</li>
<li>hash索引（默认）</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
</ul>
<h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（5.6版本之后）</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li>
<li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li>
<li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ul>
<p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> 或者 <code>SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code><br>例：<code>show global status like &#39;Com_______&#39;</code></p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：<br>    # 开启慢查询日志开关<br>    slow_query_log=1<br>    # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>    long_query_time=2<br>更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</p>
<p>查看慢查询日志开关状态：<br><code>show variables like &#39;slow_query_log&#39;;</code></p>
<h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p>
<h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br>    # 直接在select语句之前加上关键字 explain / desc<br>    EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p>
<p>EXPLAIN 各字段含义：</p>
<ul>
<li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li>
<li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</li>
<li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li>
<li>possible_key：可能应用在这张表上的索引，一个或多个</li>
<li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li>
<li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li>
<li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li>
<li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p>
<p>优缺点：</p>
<p>优点：</p>
<ul>
<li>提高数据检索效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引列也是要占用空间的</li>
<li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li>
</ul>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree</td>
<td>最常见的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td>Hash</td>
<td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-Tree(空间索引)</td>
<td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-Text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-Tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p>
<p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p>
<p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p>
<p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p>
<blockquote>
<p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p>
</blockquote>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>结构图：</p>
<p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p>
<blockquote>
<p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p>
</blockquote>
<p>与 B-Tree 的区别：</p>
<ul>
<li>所有的数据都会出现在叶子节点</li>
<li>叶子节点形成一个单向链表</li>
</ul>
<p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p>
<p><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>
<p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p>
<p>特点：</p>
<ul>
<li>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li>
<li>无法利用索引完成排序操作</li>
<li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li>
</ul>
<p>存储引擎支持：</p>
<ul>
<li>Memory</li>
<li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol>
<li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li>
</ol>
<ul>
<li>相对于二叉树，层级更少，搜索效率高</li>
<li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li>
<li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>演示图：</p>
<p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li>
<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li>
</ul>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure>

<p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p>
<p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p>
<p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p>
<p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p>
<p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p>
<p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p>
<p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="line">create index idx_user_name on tb_user(name);</span><br><span class="line">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user (phone);</span><br><span class="line">-- 为profession, age, status创建联合索引</span><br><span class="line">create index idx_user_pro_age_stat on tb_user(profession, age, status);</span><br><span class="line">-- 为email建立合适的索引来提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">drop index idx_user_email on tb_user;</span><br></pre></td></tr></table></figure>

<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>
<p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</p>
<h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol>
<li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></li>
<li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li>
<li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效。</li>
<li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li>
<li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li>
</ol>
<h4 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p>
<p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p>
<h4 id="覆盖索引-amp-回表查询"><a href="#覆盖索引-amp-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p>
<p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p>
<p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p>
<p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p>
<p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p>
<p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</span><br></pre></td></tr></table></figure>

<p>show index 里面的sub_part可以看到接取的长度</p>
<h4 id="单列索引-amp-联合索引"><a href="#单列索引-amp-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>这句只会用到phone索引字段</p>
<h5 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li>
</ul>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li>
<li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li>
</ol>
<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>普通插入：</p>
<ol>
<li>采用批量插入（一次插入的数据不建议超过1000条）</li>
<li>手动提交事务</li>
<li>主键顺序插入</li>
</ol>
<p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">select @@local_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p>
<p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p>
<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p>
<blockquote>
<p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p>
</blockquote>
<p>主键设计原则：</p>
<ul>
<li>满足业务需求的情况下，尽量降低主键的长度</li>
<li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li>
<li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li>
<li>业务操作时，避免对主键的修改</li>
</ul>
<h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li>
</ol>
<p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p>
<p>总结：</p>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li>
<li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li>
</ul>
<h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul>
<li>在分组操作时，可以通过索引来提高效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p>
<h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 此语句耗时很长</span><br><span class="line">select * from tb_sku limit 9000000, 10;</span><br><span class="line">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="line">select id from tb_sku order by id limit 9000000, 10;</span><br><span class="line">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="line">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="line">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="line">select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</span><br></pre></td></tr></table></figure>

<h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p>
<p>count的几种用法：</p>
<ul>
<li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li>
<li>用法：count(*)、count(主键)、count(字段)、count(1)</li>
<li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li>
</ul>
<p>各种用法的性能：</p>
<ul>
<li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li>
<li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li>
<li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li>
<li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li>
</ul>
<p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p>
<h3 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>
<p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>取值范围</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>-128〜127</td>
<td>1个字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>-32768〜32767</td>
<td>2个宇节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>-8388608〜8388607</td>
<td>3个字节</td>
</tr>
<tr>
<td>INT (INTEGHR)</td>
<td>-2147483648〜2147483647</td>
<td>4个字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>-9223372036854775808〜9223372036854775807</td>
<td>8个字节</td>
</tr>
</tbody></table>
<p>无符号在数据类型后加 unsigned 关键字。</p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4 个字节</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8 个字节</td>
</tr>
<tr>
<td>DECIMAL (M, D)，DEC</td>
<td>压缩的“严格”定点数</td>
<td>M+2 个字节</td>
</tr>
</tbody></table>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>日期格式</th>
<th>日期范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>YYYY</td>
<td>1901 ~ 2155</td>
<td>1 个字节</td>
</tr>
<tr>
<td>TIME</td>
<td>HH:MM:SS</td>
<td>-838:59:59 ~ 838:59:59</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATE</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01 ~ 9999-12-3</td>
<td>3 个字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td>8 个字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td>
<td>4 个字节</td>
</tr>
</tbody></table>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度非二进制字符串</td>
<td>M 字节，1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>变长非二进制字符串</td>
<td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>非常小的非二进制字符串</td>
<td>L+1字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>小的非二进制字符串</td>
<td>L+2字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小的非二进制字符串</td>
<td>L+3字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大的非二进制字符串</td>
<td>L+4字节，在此，L&lt;2^32</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型，只能有一个枚举字符串值</td>
<td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td>
</tr>
<tr>
<td>SET</td>
<td>一个设置，字符串对象可以有零个或 多个SET成员</td>
<td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td>
</tr>
</tbody></table>
<h2 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h2><table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>BIT(M)</td>
<td>位字段类型</td>
<td>大约 (M+7)/8 字节</td>
</tr>
<tr>
<td>BINARY(M)</td>
<td>固定长度二进制字符串</td>
<td>M 字节</td>
</tr>
<tr>
<td>VARBINARY (M)</td>
<td>可变长度二进制字符串</td>
<td>M+1 字节</td>
</tr>
<tr>
<td>TINYBLOB (M)</td>
<td>非常小的BLOB</td>
<td>L+1 字节，在此，L&lt;2^8</td>
</tr>
<tr>
<td>BLOB (M)</td>
<td>小 BLOB</td>
<td>L+2 字节，在此，L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMBLOB (M)</td>
<td>中等大小的BLOB</td>
<td>L+3 字节，在此，L&lt;2^24</td>
</tr>
<tr>
<td>LONGBLOB (M)</td>
<td>非常大的BLOB</td>
<td>L+4 字节，在此，L&lt;2^32</td>
</tr>
</tbody></table>
<h1 id="权限一览表"><a href="#权限一览表" class="headerlink" title="权限一览表"></a>权限一览表</h1><blockquote>
<p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p>
</blockquote>
<p>GRANT 和 REVOKE 允许的静态权限</p>
<table>
<thead>
<tr>
<th align="left">Privilege</th>
<th align="left">Grant Table Column</th>
<th align="left">Context</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td>
<td align="left">Synonym for “all privileges”</td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td>
<td align="left"><code>Alter_priv</code></td>
<td align="left">Tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td>
<td align="left"><code>Alter_routine_priv</code></td>
<td align="left">Stored routines</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td>
<td align="left"><code>Create_priv</code></td>
<td align="left">Databases, tables, or indexes</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td>
<td align="left"><code>Create_role_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td>
<td align="left"><code>Create_routine_priv</code></td>
<td align="left">Stored routines</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td>
<td align="left"><code>Create_tablespace_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td>
<td align="left"><code>Create_tmp_table_priv</code></td>
<td align="left">Tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td>
<td align="left"><code>Create_user_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td>
<td align="left"><code>Create_view_priv</code></td>
<td align="left">Views</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td>
<td align="left"><code>Delete_priv</code></td>
<td align="left">Tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td>
<td align="left"><code>Drop_priv</code></td>
<td align="left">Databases, tables, or views</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td>
<td align="left"><code>Drop_role_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td>
<td align="left"><code>Event_priv</code></td>
<td align="left">Databases</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td>
<td align="left"><code>Execute_priv</code></td>
<td align="left">Stored routines</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td>
<td align="left"><code>File_priv</code></td>
<td align="left">File access on server host</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td>
<td align="left"><code>Grant_priv</code></td>
<td align="left">Databases, tables, or stored routines</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td>
<td align="left"><code>Index_priv</code></td>
<td align="left">Tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td>
<td align="left"><code>Insert_priv</code></td>
<td align="left">Tables or columns</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td>
<td align="left"><code>Lock_tables_priv</code></td>
<td align="left">Databases</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td>
<td align="left"><code>Process_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td>
<td align="left">See <code>proxies_priv</code> table</td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td>
<td align="left"><code>References_priv</code></td>
<td align="left">Databases or tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td>
<td align="left"><code>Reload_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td>
<td align="left"><code>Repl_client_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td>
<td align="left"><code>Repl_slave_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td>
<td align="left"><code>Select_priv</code></td>
<td align="left">Tables or columns</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td>
<td align="left"><code>Show_db_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td>
<td align="left"><code>Show_view_priv</code></td>
<td align="left">Views</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td>
<td align="left"><code>Shutdown_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td>
<td align="left"><code>Super_priv</code></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td>
<td align="left"><code>Trigger_priv</code></td>
<td align="left">Tables</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td>
<td align="left"><code>Update_priv</code></td>
<td align="left">Tables or columns</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td>
<td align="left">Synonym for “no privileges”</td>
<td align="left">Server administration</td>
</tr>
</tbody></table>
<p>GRANT 和 REVOKE 允许的动态权限</p>
<table>
<thead>
<tr>
<th align="left">Privilege</th>
<th align="left">Context</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td>
<td align="left">Dual password administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td>
<td align="left">Allow queries blocked by audit log filter</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td>
<td align="left">Audit log administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td>
<td align="left">Authentication administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td>
<td align="left">Backup administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td>
<td align="left">Backup and Replication administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td>
<td align="left">Backup and Replication administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td>
<td align="left">Clone administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td>
<td align="left">Firewall administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td>
<td align="left">Firewall administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td>
<td align="left">Firewall administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td>
<td align="left">Replication administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td>
<td align="left">Replication administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td>
<td align="left">Redo log archiving administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td>
<td align="left">NDB Cluster</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td>
<td align="left">Authentication administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td>
<td align="left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td>
<td align="left">Replication administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td>
<td align="left">Resource group administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td>
<td align="left">Resource group administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
<tr>
<td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td>
<td align="left">Server administration</td>
</tr>
</tbody></table>
<h1 id="图形化界面工具"><a href="#图形化界面工具" class="headerlink" title="图形化界面工具"></a>图形化界面工具</h1><ul>
<li>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li>
<li>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li>
<li>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li>
<li>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li>
<li>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li>
<li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol>
<li>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</li>
<li>查看Mysql数据库占用空间：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT table_schema &quot;Database Name&quot;</span><br><span class="line">     , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;</span><br><span class="line">FROM information_schema.TABLES</span><br><span class="line">GROUP BY table_schema;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>ssm</title>
    <url>/2022/04/09/ssm%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>SSM</p>
<span id="more"></span>

<hr>
<hr>
<h1 id="第一章-Spring-的-IoC-和-DI"><a href="#第一章-Spring-的-IoC-和-DI" class="headerlink" title="第一章 Spring 的 IoC 和 DI"></a>第一章 Spring 的 IoC 和 DI</h1><h2 id="1-Spring-快速入门"><a href="#1-Spring-快速入门" class="headerlink" title="1.Spring 快速入门"></a>1.Spring 快速入门</h2><h3 id="1-1-Spring-程序开发步骤"><a href="#1-1-Spring-程序开发步骤" class="headerlink" title="1.1 Spring 程序开发步骤"></a>1.1 Spring 程序开发步骤</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212123861.png" alt="image-20220221212347738"></p>
</blockquote>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212124142.png" alt="img"></p>
</blockquote>
<h3 id="1-2-导入-Spring-开发的基本包坐标"><a href="#1-2-导入-Spring-开发的基本包坐标" class="headerlink" title="1.2 导入 Spring 开发的基本包坐标"></a>1.2 导入 Spring 开发的基本包坐标</h3><blockquote>
<properties>
    <spring.version>5.0.5.RELEASE</spring.version>
</properties>
<dependencies>
    <!--导入spring的context坐标，context依赖core、beans、expression-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>${spring.version}</version>
    </dependency>
</dependencies>
</blockquote>
<h3 id="1-3-编写-Dao-接口和实现类"><a href="#1-3-编写-Dao-接口和实现类" class="headerlink" title="1.3 编写 Dao 接口和实现类"></a>1.3 编写 Dao 接口和实现类</h3><blockquote>
<p>public interface UserDao {<br>    public void save();<br>}</p>
<p>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao save method running….”);<br>    }<br>}</p>
</blockquote>
<h3 id="1-4-创建-Spring-核心配置文件"><a href="#1-4-创建-Spring-核心配置文件" class="headerlink" title="1.4 创建 Spring 核心配置文件"></a>1.4 创建 Spring 核心配置文件</h3><p>在类路径下（resources）创建 applicationContext.xml 配置文件</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"></p>
</beans>

<h3 id="1-5-在-Spring-配置文件中配置-UserDaoImpl"><a href="#1-5-在-Spring-配置文件中配置-UserDaoImpl" class="headerlink" title="1.5 在 Spring 配置文件中配置 UserDaoImpl"></a>1.5 在 Spring 配置文件中配置 UserDaoImpl</h3><?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean></p>
</beans>

<h3 id="1-6-使用-Spring-的-API-获得-Bean-实例"><a href="#1-6-使用-Spring-的-API-获得-Bean-实例" class="headerlink" title="1.6 使用 Spring 的 API 获得 Bean 实例"></a>1.6 使用 Spring 的 API 获得 Bean 实例</h3><p>public class UseDaoDemo {<br>    public static void main(String[] args) {<br>        ApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        UserDao userDao = (UserDao) app.getBean(“userDao”);<br>        userDao.save();<br>    }<br>}</p>
<h3 id="1-7-知识要点"><a href="#1-7-知识要点" class="headerlink" title="1.7 知识要点"></a>1.7 知识要点</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212130136.png" alt="img"></p>
</blockquote>
<h2 id="2-Spring-配置文件"><a href="#2-Spring-配置文件" class="headerlink" title="2.Spring 配置文件"></a>2.Spring 配置文件</h2><h3 id="2-1-Bean-标签基本配置"><a href="#2-1-Bean-标签基本配置" class="headerlink" title="2.1 Bean 标签基本配置"></a>2.1 Bean 标签基本配置</h3><p>用于配置对象交由 Spring 来创建。<br>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。<br>基本属性：<br>● id：Bean 实例在 Spring 容器中的唯一标识<br>● class：Bean 的全限定名称</p>
<h3 id="2-2-Bean-标签范围配置"><a href="#2-2-Bean-标签范围配置" class="headerlink" title="2.2 Bean 标签范围配置"></a>2.2 Bean 标签范围配置</h3><p>scope：指对象的作用范围，取值如下：</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212133968.png" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212133230.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-3-Bean-生命周期配置"><a href="#2-3-Bean-生命周期配置" class="headerlink" title="2.3 Bean 生命周期配置"></a>2.3 Bean 生命周期配置</h3><p>● init-method：指定类中的初始化方法名称<br>● destroy-method：指定类中销毁方法名称</p>
<h3 id="2-4-Bean-实例化三种方式"><a href="#2-4-Bean-实例化三种方式" class="headerlink" title="2.4 Bean 实例化三种方式"></a>2.4 Bean 实例化三种方式</h3><p>1） 使用无参构造方法实例化<br>它会根据默认无参构造方法来创建类对象，如果 bean 中没有默认无参构造函数，将会创建失败</p>
<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>
2） 工厂静态方法实例化
工厂的静态方法返回 Bean 实例

<p>public class StaticFactoryBean {<br>    public static UserDao createUserDao(){<br>        return new UserDaoImpl();<br>    }<br>}<br><bean id="userDao" class="com.itheima.factory.StaticFactoryBean" factory-method="createUserDao" /><br>3） 工厂实例方法实例化<br>工厂的非静态方法返回 Bean 实例</p>
<p>public class DynamicFactoryBean {<br>    public UserDao createUserDao(){<br>        return new UserDaoImpl();<br>    }<br>}<br><bean id="factoryBean" class="com.itheima.factory.DynamicFactoryBean"/><br><bean id="userDao" factory-bean="factoryBean" factory-method="createUserDao"/></p>
<p><strong>对象已在spring容器中，需要自己去取</strong></p>
<h3 id="2-5-Bean-的依赖注入入门"><a href="#2-5-Bean-的依赖注入入门" class="headerlink" title="2.5 Bean 的依赖注入入门"></a>2.5 Bean 的依赖注入入门</h3><p>① 创建 UserService，UserService 内部在调用 UserDao 的 save () 方法</p>
<p>public class UserServiceImpl implements UserService {<br>    @Override<br>    public void save() {<br>        ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        UserDao userDao = (UserDao) app.getBean(“userDao”);<br>        userDao.save();<br>    }<br>}<br>② 将 UserServiceImpl 的创建权交给 Spring</p>
<bean id="userService" class="com.itheima.service.impl.UserServiceImpl"/>
③ 从 Spring 容器中获得 UserService 进行操作

<p>ApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>UserService userService = (UserService) app.getBean(“userService”);<br>userService.save();</p>
<h3 id="2-6-Bean-的依赖注入分析"><a href="#2-6-Bean-的依赖注入分析" class="headerlink" title="2.6 Bean 的依赖注入分析"></a>2.6 Bean 的依赖注入分析</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212140993.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212140861.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-7-Bean-的依赖注入概念"><a href="#2-7-Bean-的依赖注入概念" class="headerlink" title="2.7 Bean 的依赖注入概念"></a>2.7 Bean 的依赖注入概念</h3><p>依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。</p>
<p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。<br>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p>
<p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。<br>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p>
<p>怎么将 UserDao 怎样注入到 UserService 内部呢？<br>● 构造方法<br>● set 方法</p>
<p>1）set 方法注入<br>在 UserServiceImpl 中添加 setUserDao 方法</p>
<p>public class UserServiceImpl implements UserService {<br>    private UserDao userDao;<br>    public void setUserDao(UserDao userDao) {<br>        this.userDao = userDao;<br>    }<br>    @Override<br>    public void save() {<br>        userDao.save();<br>    }<br>}<br>配置 Spring 容器调用 set 方法进行注入</p>
<p><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean><br><bean id="userService" class="com.itheima.service.impl.UserServiceImpl"><br>    <property name="userDao" ref="userDao"></property><br></bean><br>P 命名空间注入本质也是 set 方法注入，但比起上述的 set 方法注入更加方便，主要体现在配置文件中，如下：<br>首先，需要引入 P 命名空间：</p>
<p>xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;">http://www.springframework.org/schema/p&quot;</a><br>其次，需要修改注入方式</p>
<p><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean><br><bean id="userService" class="com.itheima.service.impl.UserServiceImpl" p:userDao-ref="userDao"></bean><br>2）构造方法注入<br>创建有参构造</p>
<p>public UserServiceImpl() {</p>
<p>}</p>
<p>public UserServiceImpl(UserDao userDao) {<br>        this.userDao = userDao;<br>}<br>配置 Spring 容器调用有参构造时进行注入</p>
<p><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean><br><bean id="userService" class="com.itheima.service.impl.UserServiceImpl"><br>    <constructor-arg name="userDao" ref="userDao"></constructor-arg><br></bean></p>
<h3 id="2-8-Bean-的依赖注入的数据类型"><a href="#2-8-Bean-的依赖注入的数据类型" class="headerlink" title="2.8 Bean 的依赖注入的数据类型"></a>2.8 Bean 的依赖注入的数据类型</h3><p>上面的操作，都是注入的引用 Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p>
<p>注入数据的三种数据类型<br>● 普通数据类型<br>● 引用数据类型<br>● 集合数据类型</p>
<p>其中引用数据类型，此处就不再赘述了，之前的操作都是对 UserDao 对象的引用进行注入的，下面将以 set 方法注入为例，演示普通数据类型和集合数据类型的注入。</p>
<p>1） 普通数据类型的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private int age;<br>    private String name;<br>    public void setAge(int age) {<br>        this.age = age;<br>    }<br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>     public void save() {<br>        System.out.println(name + “============” + age);<br>    }<br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>        <property name="name" value="zhangsan"></property><br>        <property name="age" value="18"></property><br></bean><br>2）集合数据类型（List）的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private List<String> strList;<br>    public void setStrList(List<String> strList) {<br>        this.strList = strList;<br>    }<br>    public void save() {<br>        System.out.println(strList);<br>    }<br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>        <property name="strList"><br>            <list><br>                <value>aaa</value><br>                <value>bbb</value><br>                <value>ccc</value><br>            </list><br>        </property><br></bean><br>3）集合数据类型（List）的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private List<User> userList;<br>    public void setUserList(List<User> userList) {<br>        this.userList = userList;<br>    }<br>    public void save() {<br>        System.out.println(userList);<br>        System.out.println(“UserDao save method running….”);<br>    }<br>}<br><bean id="user1" class="com.itheima.domain.User"><br>    <property name="name" value="tom"></property><br>    <property name="addr" value="beijing"></property><br></bean><br><bean id="user2" class="com.itheima.domain.User"><br>    <property name="name" value="lucy"></property><br>    <property name="addr" value="tianjing"></property><br></bean><br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>    <property name="userList"><br>        <list><br>            <ref bean="user1"></ref><br>            <ref bean="user2"></ref><br>        </list><br>    </property><br></bean><br>4）集合数据类型（ Map&lt;String,User&gt; ）的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private Map&lt;String,User&gt; userMap;<br>    public void setUserMap(Map&lt;String, User&gt; userMap) {<br>        this.userMap = userMap;<br>    }<br>    public void save() {<br>        System.out.println(userMap);<br>    }<br>}<br><bean id="user1" class="com.itheima.domain.User"><br>    <property name="name" value="tom"></property><br>    <property name="addr" value="beijing"></property><br></bean><br><bean id="user2" class="com.itheima.domain.User"><br>    <property name="name" value="lucy"></property><br>    <property name="addr" value="tianjing"></property><br></bean><br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>    <property name="userMap"><br>        <map><br>            <entry key="u1" value-ref="user1"></entry><br>            <entry key="u2" value-ref="user2"></entry><br>        </map><br>    </property><br></bean><br>5）集合数据类型（Properties）的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private Properties properties;<br>    public void setProperties(Properties properties) {<br>        this.properties = properties;<br>    }<br>    public void save() {<br>        System.out.println(properties);<br>        System.out.println(“UserDao save method running….”);<br>    }<br>}<br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>    <property name="properties"><br>        <props><br>            <prop key="p1">ppp1</prop><br>            <prop key="p2">ppp2</prop><br>            <prop key="p3">ppp3</prop><br>        </props><br>    </property><br></bean></p>
<h3 id="2-9-引入其他配置文件（分模块开发）"><a href="#2-9-引入其他配置文件（分模块开发）" class="headerlink" title="2.9 引入其他配置文件（分模块开发）"></a>2.9 引入其他配置文件（分模块开发）</h3><p>实际开发中，Spring 的配置内容非常多，这就导致 Spring 配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在 Spring 主配置文件通过 import 标签进行加载</p>
<import resource="applicationContext-xxx.xml"/>

<h3 id="2-10-知识要点"><a href="#2-10-知识要点" class="headerlink" title="2.10 知识要点"></a>2.10 知识要点</h3><p>Spring 的重点配置</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212158848.png" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="3-Spring-相关-API"><a href="#3-Spring-相关-API" class="headerlink" title="3.Spring 相关 API"></a>3.Spring 相关 API</h2><h3 id="3-1-ApplicationContext-的继承体系"><a href="#3-1-ApplicationContext-的继承体系" class="headerlink" title="3.1 ApplicationContext 的继承体系"></a>3.1 ApplicationContext 的继承体系</h3><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212200328.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-2-ApplicationContext-的实现类"><a href="#3-2-ApplicationContext-的实现类" class="headerlink" title="3.2 ApplicationContext 的实现类"></a>3.2 ApplicationContext 的实现类</h3><p>1）ClassPathXmlApplicationContext</p>
<p>它是从类的根路径下加载配置文件 推荐使用这种<br>例如：</p>
<p>ApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>2）FileSystemXmlApplicationContext</p>
<p>它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。<br>例如：</p>
<p>ApplicationContext app1 = new FileSystemXmlApplicationContext(“D:\IDEA\IdeaProjects\Spring\itheima_spring_ioc\src\main\resources\applicationContext.xml”)<br>3）AnnotationConfigApplicationContext</p>
<p>当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p>
<h3 id="3-3-getBean-方法使用"><a href="#3-3-getBean-方法使用" class="headerlink" title="3.3 getBean () 方法使用"></a>3.3 getBean () 方法使用</h3><p>public Object getBean(String name) throws BeansException {<br>    assertBeanFactoryActive();<br>    return getBeanFactory().getBean(name);<br>}<br>public <T> T getBean(Class<T> requiredType) throws BeansException {<br>    assertBeanFactoryActive();<br>    return getBeanFactory().getBean(requiredType);<br>}<br>其中，当参数的数据类型是字符串时，表示根据 Bean 的 id 从容器中获得 Bean 实例，返回是 Object，需要强转。<br>当参数的数据类型是 Class 类型时，表示根据类型从容器中匹配 Bean 实例，当容器中相同类型的 Bean 有多个时，则此方法会报错。</p>
<p>ApplicationContext applicationContext = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>UserService userService1 = (UserService)applicationContext.getBean(“userService”);<br>UserService userService2 = applicationContext.getBean(UserService.class);</p>
<h3 id="3-4-知识要点"><a href="#3-4-知识要点" class="headerlink" title="3.4 知识要点"></a>3.4 知识要点</h3><p>Spring 的重点 API</p>
<p>ApplicationContext app = new ClasspathXmlApplicationContext(“xml文件”)<br>app.getBean(“id”)<br>app.getBean(Class)</p>
<h1 id="第二章-IoC-和-DI-注解开发"><a href="#第二章-IoC-和-DI-注解开发" class="headerlink" title="第二章 IoC 和 DI 注解开发"></a>第二章 IoC 和 DI 注解开发</h1><h2 id="1-Spring-配置数据源"><a href="#1-Spring-配置数据源" class="headerlink" title="1.Spring 配置数据源"></a>1.Spring 配置数据源</h2><h3 id="1-1-数据源（连接池）的作用"><a href="#1-1-数据源（连接池）的作用" class="headerlink" title="1.1 数据源（连接池）的作用"></a>1.1 数据源（连接池）的作用</h3><p>● 数据源 (连接池) 是提高程序性能如出现的<br>● 事先实例化数据源，初始化部分连接资源<br>● 使用连接资源时从数据源中获取<br>● 使用完毕后将连接资源归还给数据源</p>
<p>常见的数据源 (连接池)：DBCP、C3P0、BoneCP、Druid 等</p>
<p>数据源的开发步骤：<br>① 导入数据源的坐标和数据库驱动坐标<br>② 创建数据源对象<br>③ 设置数据源的基本连接数据<br>④ 使用数据源获取连接资源和归还连接资源</p>
<h3 id="1-2-数据源的手动创建"><a href="#1-2-数据源的手动创建" class="headerlink" title="1.2 数据源的手动创建"></a>1.2 数据源的手动创建</h3><p>① 导入 c3p0 和 druid 的坐标</p>
<!-- C3P0连接池 -->
<dependency>
    <groupId>c3p0</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.1.2</version>
</dependency>
<!-- Druid连接池 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.10</version>
</dependency>
导入 mysql 数据库驱动坐标

<!-- mysql驱动 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.39</version>
</dependency>
② 创建 C3P0 连接池

<p>@Test<br>public void testC3P0() throws Exception {<br>    //创建数据源<br>    ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>    //设置数据库连接参数<br>    dataSource.setDriverClass(“com.mysql.jdbc.Driver”);<br>    dataSource.setJdbcUrl(“jdbc:mysql://localhost:3306/test”);<br>    dataSource.setUser(“root”);<br>    dataSource.setPassword(“root”);<br>    //获得连接对象<br>    Connection connection = dataSource.getConnection();<br>    System.out.println(connection);<br>}<br>② 创建 Druid 连接池</p>
<p>@Test<br>public void testDruid() throws Exception {<br>    //创建数据源<br>    DruidDataSource dataSource = new DruidDataSource();<br>    //设置数据库连接参数<br>    dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);<br>    dataSource.setUrl(“jdbc:mysql://localhost:3306/test”);<br>    dataSource.setUsername(“root”);<br>    dataSource.setPassword(“root”);<br>    //获得连接对象<br>    Connection connection = dataSource.getConnection();<br>    System.out.println(connection);<br>}<br>③ 提取 jdbc.properties 配置文件</p>
<p>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/test<br>jdbc.username=root<br>jdbc.password=root<br>④ 读取 jdbc.properties 配置文件创建连接池</p>
<p>@Test<br>public void testC3P0ByProperties() throws Exception {<br>    //加载类路径下的jdbc.properties<br>    ResourceBundle rb = ResourceBundle.getBundle(“jdbc”);<br>    ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>    dataSource.setDriverClass(rb.getString(“jdbc.driver”));<br>    dataSource.setJdbcUrl(rb.getString(“jdbc.url”));<br>    dataSource.setUser(rb.getString(“jdbc.username”));<br>    dataSource.setPassword(rb.getString(“jdbc.password”));<br>    Connection connection = dataSource.getConnection();<br>    System.out.println(connection);<br>}</p>
<h3 id="1-3-Spring-配置数据源"><a href="#1-3-Spring-配置数据源" class="headerlink" title="1.3 Spring 配置数据源"></a>1.3 Spring 配置数据源</h3><p>可以将 DataSource 的创建权交由 Spring 容器去完成<br>● DataSource 有无参构造方法，而 Spring 默认就是通过无参构造方法实例化对象的<br>● DataSource 要想使用需要通过 set 方法设置数据库连接信息，而 Spring 可以通过 set 方法进行字符串注入</p>
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
</bean>
测试从容器当中获取数据源

<p>ApplicationContext applicationContext = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>DataSource dataSource = (DataSource)<br>applicationContext.getBean(“dataSource”);<br>Connection connection = dataSource.getConnection();<br>System.out.println(connection);</p>
<h4 id="1-4-抽取-jdbc-配置文件"><a href="#1-4-抽取-jdbc-配置文件" class="headerlink" title="1.4 抽取 jdbc 配置文件"></a>1.4 抽取 jdbc 配置文件</h4><p>applicationContext.xml 加载 jdbc.properties 配置文件获得连接信息。<br>首先，需要引入 context 命名空间和约束路径：<br>● 命名空间：xmlns:context=“<a href="http://www.springframework.org/schema/context%E2%80%9D">http://www.springframework.org/schema/context”</a><br>● 约束路径：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></p>
<p>&lt;context:property-placeholder location=”classpath:jdbc.properties”/&gt;<br><bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>    <property name="driverClass" value="${jdbc.driver}"/><br>    <property name="jdbcUrl" value="${jdbc.url}"/><br>    <property name="user" value="${jdbc.username}"/><br>    <property name="password" value="${jdbc.password}"/><br></bean></p>
<h3 id="1-5-知识要点"><a href="#1-5-知识要点" class="headerlink" title="1.5 知识要点"></a>1.5 知识要点</h3><p>Spring 容器加载 properties 文件</p>
<p>&lt;context:property-placeholder location=”xx.properties”/&gt;<br><property name="" value="${key}"/></p>
<h2 id="2-Spring-注解开发"><a href="#2-Spring-注解开发" class="headerlink" title="2.Spring 注解开发"></a>2.Spring 注解开发</h2><h3 id="2-1-Spring-原始注解"><a href="#2-1-Spring-原始注解" class="headerlink" title="2.1 Spring 原始注解"></a>2.1 Spring 原始注解</h3><p>Spring 是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替 xml 配置文件可以简化配置，提高开发效率。</p>
<p>Spring 原始注解主要是替代的配置</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212216426.png" alt="在这里插入图片描述"></p>
<p>注意：<br>使用注解进行开发时，需要在 applicationContext.xml 中配置组件扫描，作用是指定哪个包及其子包下的 Bean 需要进行扫描以便识别使用注解配置的类、字段和方法。</p>
<!--注解的组件扫描-->
<p>&lt;context:component-scan base-package=”com.itheima”&gt;</context:componentscan><br>● 使用 @Compont 或 @Repository 标识 UserDaoImpl 需要 Spring 进行实例化。</p>
<p>//@Component(“userDao”)<br>@Repository(“userDao”)<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“save running… …”);<br>    }<br>}<br>● 使用 @Compont 或 @Service 标识 UserServiceImpl 需要 Spring 进行实例化<br>● 使用 @Autowired 或者 @Autowired+@Qulifier 或者 @Resource 进行 userDao 的注入</p>
<p>//@Component(“userService”)<br>@Service(“userService”)<br>public class UserServiceImpl implements UserService {<br>    /*<br>    @Autowired //按照数据类型从Spring容器中进行匹配的<br>    @Qualifier(“userDao”)  //是按照id值从容器中进行匹配的 但是注意@Qualifier要结合@Autowired一起使用<br>    */<br>    @Resource(name=”userDao”)<br>    private UserDao userDao;<br>    @Override<br>    public void save() {<br>        userDao.save();<br>    }<br>}<br>● 使用 @Value 进行字符串的注入</p>
<p>@Repository(“userDao”)<br>public class UserDaoImpl implements UserDao {<br>    @Value(“注入普通数据”)<br>    private String str;<br>    @Value(“${jdbc.driver}”)<br>    private String driver;<br>    @Override<br>    public void save() {<br>        System.out.println(str);<br>        System.out.println(driver);<br>        System.out.println(“save running… …”);<br>    }<br>}<br>● 使用 @Scope 标注 Bean 的范围</p>
<p>//@Scope(“prototype”)<br>@Scope(“singleton”)<br>public class UserDaoImpl implements UserDao {<br>    //此处省略代码<br>}<br>● 使用 @PostConstruct 标注初始化方法，使用 @PreDestroy 标注销毁方法</p>
<p>@PostConstruct<br>public void init(){<br>    System.out.println(“初始化方法….”);<br>}<br>@PreDestroy<br>public void destroy(){<br>    System.out.println(“销毁方法…..”);<br>}</p>
<h3 id="2-2-Spring-新注解"><a href="#2-2-Spring-新注解" class="headerlink" title="2.2 Spring 新注解"></a>2.2 Spring 新注解</h3><p>使用上面的注解还不能全部替代 xml 配置文件，还需要使用注解替代的配置如下：<br>● 非自定义的 Bean 的配置：<bean><br>● 加载 properties 文件的配置：<a href="context:property-placeholder">context:property-placeholder</a><br>● 组件扫描的配置：<a href="context:component-scan">context:component-scan</a><br>● 引入其他文件：<import></p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212226869.png" alt="在这里插入图片描述"></p>
<p>● @Configuration<br>● @ComponentScan<br>● @Import</p>
<p>@Configuration  //标志该类是Spring的核心配置类<br>@ComponentScan(“com.itheima”)<br>@Import({DataSourceConfiguration.class})<br>public class SpringConfiguration {<br>}<br>● @PropertySource<br>● @value</p>
<p>@PropertySource(“classpath:jdbc.properties”)<br>public class DataSourceConfiguration {<br>    @Value(“${jdbc.driver}”)<br>    private String driver;<br>    @Value(“${jdbc.url}”)<br>    private String url;<br>    @Value(“${jdbc.username}”)<br>    private String username;<br>    @Value(“${jdbc.password}”)<br>    private String password;<br>}<br>● @Bean</p>
<p>@Bean(name=”dataSource”)  //Spring会将当前方法的返回值以指定名称存储到Spring容器中<br>public DataSource getDataSource() throws PropertyVetoException {<br>    ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>    dataSource.setDriverClass(driver);<br>    dataSource.setJdbcUrl(url);<br>    dataSource.setUser(username);<br>    dataSource.setPassword(password);<br>    return dataSource;<br>}<br>测试加载核心配置类创建 Spring 容器</p>
<p>@Test<br>public void testAnnoConfiguration() throws Exception {<br>  ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class);<br>    UserService userService = (UserService) applicationContext.getBean(“userService”);<br>    userService.save();<br>    DataSource dataSource = (DataSource) applicationContext.getBean(“dataSource”);<br>    Connection connection = dataSource.getConnection();<br>    System.out.println(connection);<br>}</p>
<h2 id="3-Spring-集成-Junit"><a href="#3-Spring-集成-Junit" class="headerlink" title="3.Spring 集成 Junit"></a>3.Spring 集成 Junit</h2><h3 id="3-1-原始-Junit-测试-Spring-的问题"><a href="#3-1-原始-Junit-测试-Spring-的问题" class="headerlink" title="3.1 原始 Junit 测试 Spring 的问题"></a>3.1 原始 Junit 测试 Spring 的问题</h3><p>在测试类中，每个测试方法都有以下两行代码：</p>
<p>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>IAccountService as = ac.getBean(“accountService”,IAccountService.class);<br>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p>
<h3 id="3-2-上述问题解决思路"><a href="#3-2-上述问题解决思路" class="headerlink" title="3.2 上述问题解决思路"></a>3.2 上述问题解决思路</h3><p>● 让 SpringJunit 负责创建 Spring 容器，但是需要将配置文件的名称告诉它<br>● 将需要进行测试 Bean 直接在测试类中进行注入</p>
<h3 id="3-3-Spring-集成-Junit-步骤"><a href="#3-3-Spring-集成-Junit-步骤" class="headerlink" title="3.3 Spring 集成 Junit 步骤"></a>3.3 Spring 集成 Junit 步骤</h3><p>① 导入 spring 集成 Junit 的坐标<br>② 使用 @Runwith 注解替换原来的运行期<br>③ 使用 @ContextConfiguration 指定配置文件或配置类<br>④ 使用 @Autowired 注入需要测试的对象<br>⑤ 创建测试方法进行测试</p>
<h3 id="3-4-Spring-集成-Junit-代码实现"><a href="#3-4-Spring-集成-Junit-代码实现" class="headerlink" title="3.4 Spring 集成 Junit 代码实现"></a>3.4 Spring 集成 Junit 代码实现</h3><p>① 导入 spring 集成 Junit 的坐标</p>
<!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>

<p>② 使用 @Runwith 注解替换原来的运行期</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>public class SpringJunitTest {<br>}<br>③ 使用 @ContextConfiguration 指定配置文件或配置类</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>//加载spring核心配置文件<br>//@ContextConfiguration(value = {“classpath:applicationContext.xml”})<br>//加载spring核心配置类<br>@ContextConfiguration(classes = {SpringConfiguration.class})<br>public class SpringJunitTest {<br>}<br>④ 使用 @Autowired 注入需要测试的对象</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = {SpringConfiguration.class})<br>public class SpringJunitTest {<br>    @Autowired<br>    private UserService userService;<br>}<br>⑤ 创建测试方法进行测试</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = {SpringConfiguration.class})<br>public class SpringJunitTest {<br>    @Autowired<br>    private UserService userService;<br>    @Test<br>    public void testUserService(){<br>        userService.save();<br>    }<br>}</p>
<h3 id="3-5-知识要点"><a href="#3-5-知识要点" class="headerlink" title="3.5 知识要点"></a>3.5 知识要点</h3><p>Spring 集成 Junit 步骤<br>① 导入 spring 集成 Junit 的坐标<br>② 使用 @Runwith 注解替换原来的运行期<br>③ 使用 @ContextConfiguration 指定配置文件或配置类<br>④ 使用 @Autowired 注入需要测试的对象<br>⑤ 创建测试方法进行测试</p>
<h1 id="第三章-SpringMVC-入门"><a href="#第三章-SpringMVC-入门" class="headerlink" title="第三章 SpringMVC 入门"></a>第三章 SpringMVC 入门</h1><h2 id="1-Spring-集成-web-环境"><a href="#1-Spring-集成-web-环境" class="headerlink" title="1.Spring 集成 web 环境"></a>1.Spring 集成 web 环境</h2><h3 id="1-1-ApplicationContext-应用上下文获取方式"><a href="#1-1-ApplicationContext-应用上下文获取方式" class="headerlink" title="1.1 ApplicationContext 应用上下文获取方式"></a>1.1 ApplicationContext 应用上下文获取方式</h3><p>应用上下文对象是通过 new ClasspathXmlApplicationContext (spring 配置文件) 方式获取的，但是每次从容器中获得 Bean 时都要编写 new ClasspathXmlApplicationContext (spring 配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p>
<p>在 Web 项目中，可以使用 ServletContextListener 监听 Web 应用的启动，我们可以在 Web 应用启动时，就加载 Spring 的配置文件，创建应用上下文对象 ApplicationContext，在将其存储到最大的域 servletContext 域中，这样就可以在任意位置从域中获得应用上下文 ApplicationContext 对象了。</p>
<h3 id="1-2-Spring-提供获取应用上下文的工具"><a href="#1-2-Spring-提供获取应用上下文的工具" class="headerlink" title="1.2 Spring 提供获取应用上下文的工具"></a>1.2 Spring 提供获取应用上下文的工具</h3><p>上面的分析不用手动实现，Spring 提供了一个监听器 ContextLoaderListener 就是对上述功能的封装，该监听器内部加载 Spring 配置文件，创建应用上下文对象，并存储到 ServletContext 域中，提供了一个客户端工具 WebApplicationContextUtils 供使用者获得应用上下文对象。</p>
<p>所以我们需要做的只有两件事：<br>① 在 web.xml 中配置 ContextLoaderListener 监听器（导入 spring-web 坐标）<br>② 使用 WebApplicationContextUtils 获得应用上下文对象 ApplicationContext</p>
<h3 id="1-3-导入-Spring-集成-web-的坐标"><a href="#1-3-导入-Spring-集成-web-的坐标" class="headerlink" title="1.3 导入 Spring 集成 web 的坐标"></a>1.3 导入 Spring 集成 web 的坐标</h3><dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>

<h3 id="1-4-配置-ContextLoaderListener-监听器"><a href="#1-4-配置-ContextLoaderListener-监听器" class="headerlink" title="1.4 配置 ContextLoaderListener 监听器"></a>1.4 配置 ContextLoaderListener 监听器</h3><!--全局初始化参数-->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <!--Spring的总配置文件-->
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>

<!--配置监听器-->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<h3 id="1-5-通过工具获得应用上下文对象"><a href="#1-5-通过工具获得应用上下文对象" class="headerlink" title="1.5 通过工具获得应用上下文对象"></a>1.5 通过工具获得应用上下文对象</h3><p>//先获取上下文对象getServletContext(),将参数放入<br>ApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(servletContext);<br>UserService userService = app.getBean(UserService.class);</p>
<h3 id="1-6-知识要点"><a href="#1-6-知识要点" class="headerlink" title="1.6 知识要点"></a>1.6 知识要点</h3><p>Spring 集成 web 环境步骤<br>① 配置 ContextLoaderListener 监听器<br>② 使用 WebApplicationContextUtils 获得应用上下文</p>
<h2 id="2-SpringMVC-简介"><a href="#2-SpringMVC-简介" class="headerlink" title="2.SpringMVC 简介"></a>2.SpringMVC 简介</h2><h3 id="2-1-SpringMVC-概述"><a href="#2-1-SpringMVC-概述" class="headerlink" title="2.1 SpringMVC 概述"></a>2.1 SpringMVC 概述</h3><p>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。</p>
<p>SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。</p>
<p>SpringMVC 雏形</p>
<h3 id="2-2-SpringMVC-快速入门"><a href="#2-2-SpringMVC-快速入门" class="headerlink" title="2.2 SpringMVC 快速入门"></a>2.2 SpringMVC 快速入门</h3><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。<br>开发步骤：<br>① 导入 SpringMVC 相关坐标<br>② 配置 SpringMVC 核心控制器 DispathcerServlet<br>③ 创建 Controller 类和视图页面<br>④ 使用注解配置 Controller 类中业务方法的映射地址<br>⑤ 配置 SpringMVC 核心文件 spring-mvc.xml<br>⑥ 客户端发起请求测试</p>
<p>① 导入 Spring 和 SpringMVC 的坐标</p>
<!--Spring坐标-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>
<!--SpringMVC坐标-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>
① 导入 Servlet 和 Jsp 的坐标

<!--Servlet坐标-->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>servlet-api</artifactId>
    <version>2.5</version>
     <!-- 因为Tomcat有这个包，所有在打包的时候，不扫描这个包-->
    <scope>provided</scope>
</dependency>
<!--Jsp坐标-->
<dependency>
    <groupId>javax.servlet.jsp</groupId>
    <artifactId>jsp-api</artifactId>
    <version>2.0</version>
     <!-- 因为Tomcat有这个包，所有在打包的时候，不扫描这个包-->
    <scope>provided</scope>
</dependency>
② 在 web.xml 配置 SpringMVC 的核心控制器

<!--配置SpringMVC的前端控制器-->
<servlet>
    <servlet-name>DispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>DispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
③ 创建 Controller 和业务方法

<p>public class UserController {<br>    public String save(){<br>        System.out.println(“Controller save running…”);<br>        return “success.jsp”;<br>    }<br>}<br>③ 创建视图页面 success.jsp</p>
<html>
<body>
    <h1>Success!</h1>
</body>
</html>
④ 配置注解

<p>@Controller<br>public class UserController {<br>    //请求地址：<a href="http://localhost:8080/quick">http://localhost:8080/quick</a><br>    @RequestMapping(“/quick”)<br>    public String save(){<br>        System.out.println(“Controller save running…”);<br>        //  <strong>加/代表从web路径下加载资源，如果不加/代表从/user目录下加载资源，会报错</strong><br>        return “/success.jsp”;<br>    }<br>}<br>⑤ 创建 spring-mvc.xml</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"></p>
<pre><code>&lt;!--Controller的组件扫描--&gt;
&lt;context:component-scan base-package=&quot;com.itheima.controller&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<p>​<br></beans><br>⑥ 访问测试地址</p>
<p><a href="http://localhost:8080/quick">http://localhost:8080/quick</a></p>
<p>Spring 访问流程（代码角度）</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212254106.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-3-SpringMVC-流程图示"><a href="#2-3-SpringMVC-流程图示" class="headerlink" title="2.3 SpringMVC 流程图示"></a>2.3 SpringMVC 流程图示</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212255814.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-4-知识要点"><a href="#2-4-知识要点" class="headerlink" title="2.4 知识要点"></a>2.4 知识要点</h3><p>SpringMVC 的开发步骤<br>① 导入 SpringMVC 相关坐标<br>② 配置 SpringMVC 核心控制器 DispathcerServlet<br>③ 创建 Controller 类和视图页面<br>④ 使用注解配置 Controller 类中业务方法的映射地址<br>⑤ 配置 SpringMVC 核心文件 spring-mvc.xml<br>⑥ 客户端发起请求测试</p>
<h2 id="3-SpringMVC-组件解析"><a href="#3-SpringMVC-组件解析" class="headerlink" title="3.SpringMVC 组件解析"></a>3.SpringMVC 组件解析</h2><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212256494.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-1-SpringMVC-的执行流程"><a href="#3-1-SpringMVC-的执行流程" class="headerlink" title="3.1 SpringMVC 的执行流程"></a>3.1 SpringMVC 的执行流程</h3><p>① 用户发送请求至前端控制器 DispatcherServlet。<br>② DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。<br>③ 处理器映射器找到具体的处理器 (可以根据 xml 配置、注解进行查找)，生成处理器对象及处理器拦截器 (如果有则生成) 一并返回给 DispatcherServlet。<br>④ DispatcherServlet 调用 HandlerAdapter 处理器适配器。<br>⑤ HandlerAdapter 经过适配调用具体的处理器 (Controller，也叫后端控制器)。<br>⑥ Controller 执行完成返回 ModelAndView。<br>⑦ HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。<br>⑧ DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。<br>⑨ ViewReslover 解析后返回具体 View。<br>⑩ DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet 响应用户。</p>
<h3 id="3-2-SpringMVC-组件解析"><a href="#3-2-SpringMVC-组件解析" class="headerlink" title="3.2 SpringMVC 组件解析"></a>3.2 SpringMVC 组件解析</h3><p>前端控制器：DispatcherServlet</p>
<p>用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p>处理器映射器：HandlerMapping</p>
<p>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p>处理器适配器：HandlerAdapter</p>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<p>处理器：Handler</p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。</p>
<p>视图解析器：View Resolver</p>
<p>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
<p>视图：View</p>
<p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p>
<h3 id="3-3-SpringMVC-注解解析"><a href="#3-3-SpringMVC-注解解析" class="headerlink" title="3.3 SpringMVC 注解解析"></a>3.3 SpringMVC 注解解析</h3><p>@RequestMapping<br>作用：用于建立请求 URL 和处理请求方法之间的对应关系</p>
<p>位置：<br>● 类上，请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录<br>● 方法上，请求 URL 的第二级访问目录，与类上的使用 @ReqquestMapping 标注的一级目录一起组成访问虚拟路径</p>
<p>属性：<br>● value：用于指定请求的 URL。它和 path 属性的作用是一样的<br>● method：用于指定请求的方式<br>● params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样</p>
<p>例如：<br>● params = {“accountName”}，表示请求参数必须有 accountName<br>● params = {“moeny!100”}，表示请求参数中 money 不能是 100</p>
<p>1.mvc 命名空间引入</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212259070.png" alt="在这里插入图片描述"></p>
</blockquote>
<ol start="2">
<li>组件扫描<br>SpringMVC 基于 Spring 容器，所以在进行 SpringMVC 操作时，需要将 Controller 存储到 Spring 容器中，如果使用 @Controller 注解标注的话，就需要使用 &lt;context:component-scan base-package=“com.itheima.controller”/&gt; 进行组件扫描。</li>
</ol>
<h3 id="3-4-SpringMVC-的-XML-配置解析"><a href="#3-4-SpringMVC-的-XML-配置解析" class="headerlink" title="3.4 SpringMVC 的 XML 配置解析"></a>3.4 SpringMVC 的 XML 配置解析</h3><p>视图解析器</p>
<p>SpringMVC 有默认组件配置，默认组件都是 DispatcherServlet.properties 配置文件中配置的，该配置文件地址 org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：<br>org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</p>
<p>翻看该解析器源码，可以看到该解析器的默认设置，如下：</p>
<p>REDIRECT_URL_PREFIX = “redirect:” –重定向前缀<br>FORWARD_URL_PREFIX = “forward:” –转发前缀（默认值）<br>prefix = “”; –视图名称前缀<br>suffix = “”; –视图名称后缀<br>我们可以通过属性注入的方式修改视图的的前后缀</p>
<!--配置内部资源视图解析器-->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <!-- /jsp/success.jsp -->
    <property name="prefix" value="/jsp/"></property>
    <property name="suffix" value=".jsp"></property>
</bean>

<h3 id="3-5-知识要点-1"><a href="#3-5-知识要点-1" class="headerlink" title="3.5 知识要点"></a>3.5 知识要点</h3><p>SpringMVC 的相关组件<br>・前端控制器：DispatcherServlet<br>・处理器映射器：HandlerMapping<br>・处理器适配器：HandlerAdapter<br>・处理器：Handler<br>・视图解析器：View Resolver<br>・视图：View</p>
<p>SpringMVC 的注解和配置<br>・请求映射注解：@RequestMapping<br>・视图解析器配置：</p>
<p>REDIRECT_URL_PREFIX = “redirect:” –重定向前缀<br>FORWARD_URL_PREFIX = “forward:” –转发前缀（默认值）<br>prefix = “”; –视图名称前缀<br>suffix = “”; –视图名称后缀</p>
<h1 id="第四章-SpringMVC-的请求和响应"><a href="#第四章-SpringMVC-的请求和响应" class="headerlink" title="第四章 SpringMVC 的请求和响应"></a>第四章 SpringMVC 的请求和响应</h1><h2 id="1-SpringMVC-的数据响应"><a href="#1-SpringMVC-的数据响应" class="headerlink" title="1.SpringMVC 的数据响应"></a>1.SpringMVC 的数据响应</h2><h3 id="1-1-SpringMVC-的数据响应方式"><a href="#1-1-SpringMVC-的数据响应方式" class="headerlink" title="1.1 SpringMVC 的数据响应方式"></a>1.1 SpringMVC 的数据响应方式</h3><p>1） 页面跳转</p>
<p>● 直接返回字符串<br>● 通过 ModelAndView 对象返回</p>
<p>2） 回写数据</p>
<p>● 直接返回字符串<br>● 返回对象或集合</p>
<h3 id="1-2-页面跳转"><a href="#1-2-页面跳转" class="headerlink" title="1.2 页面跳转"></a>1.2 页面跳转</h3><p>（1）返回字符串形式</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212303404.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。</p>
<p>返回带有前缀的字符串：<br>转发：forward:/WEB-INF/views/index.jsp<br>重定向：redirect:/index.jsp(因为 webinfo 文件夹 [即 WEB-INF] 是受保护的，所以要把重定向的 jsp 放到可以直接访问的地方)</p>
<p>（2）返回 ModelAndView 对象</p>
<p>@RequestMapping(value = “/quick2”)<br>public ModelAndView save2() {<br>    /*<br>        Model:模型 作用封装数据<br>        View：视图 作用展示数据<br>     */<br>    ModelAndView modelAndView = new ModelAndView();<br>    //设置模型数据<br>    modelAndView.addObject(“username”, “itcast”);<br>    //设置视图名称<br>    modelAndView.setViewName(“success”);<br>    return modelAndView;<br>}<br>@RequestMapping(value = “/quick4”)<br>public String save4(Model model) {<br>    model.addAttribute(“username”, “博学谷”);<br>    return “success”;<br>}<br>（3）向 request 域存储数据</p>
<p>在进行转发时，往往要向 request 域中存储数据，在 jsp 页面中显示，那么 Controller 中怎样向 request 域中存储数据呢？</p>
<p>① 通过 SpringMVC 框架注入的 request 对象 setAttribute () 方法设置</p>
<p>@RequestMapping(value = “/quick5”)<br>public String save5(HttpServletRequest request) {<br>    request.setAttribute(“username”,”酷丁鱼”);<br>    return “success”;<br>}</p>
<p>② 通过 ModelAndView 的 addObject () 方法设置</p>
<p>@RequestMapping(value = “/quick3”)<br>public ModelAndView save3(ModelAndView modelAndView) {<br>    modelAndView.addObject(“username”, “itheima”);<br>    modelAndView.setViewName(“success”);<br>    return modelAndView;<br>}</p>
<h3 id="1-3-回写数据"><a href="#1-3-回写数据" class="headerlink" title="1.3 回写数据"></a>1.3 回写数据</h3><p>（1）直接返回字符串</p>
<p>Web 基础阶段，客户端访问服务器端，如果想直接回写字符串作为响应体返回的话，只需要使用 response.getWriter ().print (“hello world”) 即可，那么在 Controller 中想直接回写字符串该怎样呢？</p>
<p>① 通过 SpringMVC 框架注入的 response 对象，使用 response.getWriter ().print (“hello world”) 回写数<br>据，此时不需要视图跳转，业务方法返回值为 void。</p>
<p>@RequestMapping(value = “/quick6”)<br>public void save6(HttpServletResponse response) throws IOException {<br>    response.getWriter().println(“hello itcast”);<br>}<br>② 将需要回写的字符串直接返回，但此时需要通过 @ResponseBody 注解告知 SpringMVC 框架，方法<br>返回的字符串不是跳转是直接在 http 响应体中返回。</p>
<p>@RequestMapping(value = “/quick7”)<br>@ResponseBody   //告诉SpringMVC框架 不进行页面跳转 直接进行数据响应<br>public String save7() {<br>    return “hello itheima”;<br>}<br>在异步项目中，客户端与服务器端往往要进行 json 格式字符串交互，此时我们可以手动拼接 json 字符串返回。</p>
<p>@RequestMapping(value = “/quick8”)<br>@ResponseBody   //告诉SpringMVC框架 不进行页面跳转 直接进行数据响应<br>public String save8() {<br>    return “{&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18)}”;<br>}<br>上述方式手动拼接 json 格式字符串的方式很麻烦，开发中往往要将复杂的 java 对象转换成 json 格式的字符串，我们可以使用 web 阶段学习过的 json 转换工具 jackson 进行转换，导入 jackson 坐标。</p>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.9.0</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.0</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.9.0</version>
</dependency>
通过 jackson 转换 json 格式字符串，回写字符串。

<p>@RequestMapping(value = “/quick9”)<br>@ResponseBody   //告诉SpringMVC框架 不进行页面跳转 直接进行数据响应<br>public String save9() throws JsonProcessingException {<br>    User user = new User();<br>    user.setAge(30);<br>    user.setUsername(“lisi”);<br>    //使用json的转换工具将对象转换成json格式字符串再返回<br>    ObjectMapper objectMapper = new ObjectMapper();<br>    String json = objectMapper.writeValueAsString(user);<br>    return json;<br>}</p>
<p>（2）返回对象或集合</p>
<p>通过 SpringMVC 帮助我们对对象或集合进行 json 字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用 jackson 进行对象或集合的转换，因此需要在 spring-mvc.xml 中进行如下配置：</p>
<!--配置处理映射器-->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
    <property name="messageConverters">
       <list>
           <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"></bean>
       </list>
    </property>
</bean>
@RequestMapping(value = "/quick10")
@ResponseBody   //告诉SpringMVC框架 不进行页面跳转 直接进行数据响应
public User save10() {
    User user = new User();
    user.setAge(32);
    user.setUsername("lisi2");
    return user;
}
在方法上添加 @ResponseBody 就可以返回 json 格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用 mvc 的注解驱动代替上述配置。

<!--mvc的注解驱动-->
<p><a href="mvc:annotation-driven">mvc:annotation-driven</a></mvc:annotation-driven><br>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。<br>使用 mvc:annotation-driven 自动加载 RequestMappingHandlerMapping（处理映射器）和<br>RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在 Spring-xml.xml 配置文件中使用 mvc:annotation-driven 替代注解处理器和适配器的配置。<br>同时使用 mvc:annotation-driven 默认底层就会集成 jackson 进行对象或集合的 json 格式字符串的转换。</p>
<h3 id="1-4-知识要点"><a href="#1-4-知识要点" class="headerlink" title="1.4 知识要点"></a>1.4 知识要点</h3><p>SpringMVC 的数据响应方式<br>1） 页面跳转<br>● 直接返回字符串<br>● 通过 ModelAndView 对象返回</p>
<p>2） 回写数据<br>● 直接返回字符串<br>● 返回对象或集合</p>
<h2 id="2-SpringMVC-获得请求数据"><a href="#2-SpringMVC-获得请求数据" class="headerlink" title="2.SpringMVC 获得请求数据"></a>2.SpringMVC 获得请求数据</h2><h3 id="2-1-获得请求参数"><a href="#2-1-获得请求参数" class="headerlink" title="2.1 获得请求参数"></a>2.1 获得请求参数</h3><p>客户端请求参数的格式是：name=value&amp;name=value… …<br>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC 可以接收如下类型的参数：<br>● 基本类型参数<br>● POJO 类型参数<br>● 数组类型参数<br>● 集合类型参数</p>
<h3 id="2-2-获得基本类型参数"><a href="#2-2-获得基本类型参数" class="headerlink" title="2.2 获得基本类型参数"></a>2.2 获得基本类型参数</h3><p>Controller 中的业务方法的参数名称要与请求参数的 name 一致，参数值会自动映射匹配。</p>
<p><a href="http://localhost:8080/user/quick11?username=zhangsan&amp;age=12">http://localhost:8080/user/quick11?username=zhangsan&amp;age=12</a></p>
<p>@RequestMapping(value = “/quick11”)<br>@ResponseBody<br>public void save11(String username, int age) {<br>    System.out.println(username);<br>    System.out.println(age);<br>}</p>
<h3 id="2-3-获得-POJO-类型参数"><a href="#2-3-获得-POJO-类型参数" class="headerlink" title="2.3 获得 POJO 类型参数"></a>2.3 获得 POJO 类型参数</h3><p>Controller 中的业务方法的 POJO 参数的属性名与请求参数的 name 一致，参数值会自动映射匹配。</p>
<p><a href="http://localhost:8080/user/quick12?username=zhangsan&amp;age=12">http://localhost:8080/user/quick12?username=zhangsan&amp;age=12</a></p>
<p>public class User {<br>    private String username;<br>    private int age;<br>    getter/setter…<br>}<br>@RequestMapping(value = “/quick12”)<br>@ResponseBody<br>public void save12(User user) {<br>    System.out.println(user);<br>}</p>
<h3 id="2-4-获得数组类型参数"><a href="#2-4-获得数组类型参数" class="headerlink" title="2.4 获得数组类型参数"></a>2.4 获得数组类型参数</h3><p>Controller 中的业务方法数组名称与请求参数的 name 一致，参数值会自动映射匹配。</p>
<p><a href="http://localhost:8080/user/quick11?strs=111&amp;strs=222&amp;strs=333">http://localhost:8080/user/quick11?strs=111&amp;strs=222&amp;strs=333</a></p>
<p>@RequestMapping(value = “/quick13”)<br>@ResponseBody<br>public void save13(String[] strs) {<br>    System.out.println(Arrays.asList(strs));<br>}</p>
<h3 id="2-5-获得集合类型参数"><a href="#2-5-获得集合类型参数" class="headerlink" title="2.5 获得集合类型参数"></a>2.5 获得集合类型参数</h3><p>获得集合参数时，要将集合参数包装到一个 POJO 中才可以。</p>
<p>public class Vo(){<br>    private List<User> userList;<br>    //get和set方法，重写toString</p>
<p>}</p>
<form action="${pageContext.request.contextPath}/user/quick14" method="post">
    <%--表明是第几个User对象的username age--%>
    <input type="text" name =  "userList[0].username"><br/>
    <input type="text" name =  "userList[0].age"><br/>
    <input type="text" name =  "userList[1].username"><br/>
    <input type="text" name =  "userList[1].age"><br/>
    <input type="submit" value="提交">
</form>

<p>@RequestMapping(value = “/quick14”)<br>@ResponseBody<br>public void save14(VO vo) {<br>    System.out.println(vo);<br>}<br>当使用 ajax 提交时，可以指定 contentType 为 json 形式，那么在方法参数位置使用 @RequestBody 可以<br>直接接收集合数据而无需使用 POJO 进行包装。</p>
<script src="${pageContext.request.contextPath}/js/jquery-3.3.1.js"></script>
<script>
    var userList = new Array();
    userList.push({username: "zhangsan", age: 18});
    userList.push({username: "lisi", age: 28});
$.ajax({
    type: "POST",
    url: "${pageContext.request.contextPath}/user/quick15",
    data: JSON.stringify(userList),
    contextType: "application/json;charset=utf-8"
});
</script>
<p>当使用 ajax 提交时，可以指定 contentType 为 json 形式，那么在方法参数位置使用 @RequestBody 可以<br>直接接收集合数据而无需使用 POJO 进行包装。]</p>
<p>@RequestMapping(value = “/quick15”)<br>@ResponseBody<br>public void save15(@RequestBody List<User> userList) {<br>    System.out.println(userList);<br>}<br>注意：通过谷歌开发者工具抓包发现，没有加载到 jquery 文件，原因是 SpringMVC 的前端控制器 DispatcherServlet 的 url-pattern 配置的是 /, 代表对所有的资源都进行过滤操作，我们可以通过以下两种<br>方式指定放行静态资源：<br>● 在 spring-mvc.xml 配置文件中指定放行的资源</p>
<p>&lt;mvc:resources mapping=”/js/**” location=”/js/“/&gt;<br>● 使用 <a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a> 标签</p>
<h3 id="2-6-请求数据乱码问题"><a href="#2-6-请求数据乱码问题" class="headerlink" title="2.6 请求数据乱码问题"></a>2.6 请求数据乱码问题</h3><p>当 post 请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p>
<!--配置全局过滤的filter-->
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

<h3 id="2-7-参数绑定注解-requestParam"><a href="#2-7-参数绑定注解-requestParam" class="headerlink" title="2.7 参数绑定注解 @requestParam"></a>2.7 参数绑定注解 @requestParam</h3><p>当请求的参数名称与 Controller 的业务方法参数名称不一致时，就需要通过 @RequestParam 注解显示的绑定。</p>
<p>@RequestMapping(value = “/quick16”)<br>@ResponseBody<br>public void save16(@RequestParam(“name”) String username) {<br>    System.out.println(username);<br>}<br>注解 @RequestParam 还有如下参数可以使用：<br>● value：与请求参数名称<br>● required：此在指定的请求参数是否必须包括，默认是 true，提交时如果没有此参数则报错<br>● defaultValue：当没有指定请求参数时，则使用指定的默认值赋值</p>
<p>@RequestMapping(value = “/quick16”)<br>@ResponseBody<br>public void save16(@RequestParam(value = “name”, required = false, defaultValue = “itcast”) String username) {<br>    System.out.println(username);<br>}</p>
<h3 id="2-8-获得-Restful-风格的参数"><a href="#2-8-获得-Restful-风格的参数" class="headerlink" title="2.8 获得 Restful 风格的参数"></a>2.8 获得 Restful 风格的参数</h3><p>Restful 是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p>
<p>Restful 风格的请求是使用 “url + 请求方式” 表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：<br>● GET：用于获取资源<br>● POST：用于新建资源<br>● PUT：用于更新资源<br>● DELETE：用于删除资源</p>
<p>例如：<br>● /user/1 GET ： 得到 id = 1 的 user<br>● /user/1 DELETE： 删除 id = 1 的 user<br>● /user/1 PUT： 更新 id = 1 的 user<br>● /user POST： 新增 user</p>
<p>上述 url 地址 /user/1 中的 1 就是要获得的请求参数，在 SpringMVC 中可以使用占位符进行参数绑定。地址 /user/1 可以写成 /user/{id}，占位符 {id} 对应的就是 1 的值。在业务方法中我们可以使用 @PathVariable 注解进行占位符的匹配获取工作。</p>
<p><a href="http://localhost:8080/user/quick17/zhangsan">http://localhost:8080/user/quick17/zhangsan</a></p>
<p>@RequestMapping(value = “/quick17/{name}”)<br>@ResponseBody<br>public void save17(@PathVariable (value = “name”) String username) {<br>    System.out.println(username);<br>}</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212340500.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-9-自定义类型转换器"><a href="#2-9-自定义类型转换器" class="headerlink" title="2.9 自定义类型转换器"></a>2.9 自定义类型转换器</h3><p>● SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成 int 型进行参数设置。<br>● 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</p>
<p>自定义类型转换器的开发步骤：<br>① 定义转换器类实现 Converter 接口<br>② 在配置文件中声明转换器<br>③ 在中引用转换器</p>
<p>① 定义转换器类实现 Converter 接口</p>
<p>public class DataConverter implements Converter&lt;String, Date&gt; {<br>    @Override<br>    public Date convert(String dateStr) {<br>        //将日期字符串转换成日期对象返回<br>        SimpleDateFormat format = new SimpleDateFormat(“yyyy-MM-dd”);<br>        Date date = null;<br>        try {<br>            date = format.parse(dateStr);<br>        } catch (ParseException e) {<br>            e.printStackTrace();<br>        }<br>        return date;<br>    }<br>}<br>② 在配置文件中声明转换器</p>
<!--声明转换器-->
<bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <list>
            <bean class="com.itheima.converter.DataConverter"></bean>
        </list>
    </property>
</bean>
③ 在 <annotation-driven> 中引用转换器

<!--mvc的注解驱动-->
<p>&lt;mvc:annotation-driven conversion-service=”conversionService”&gt;</mvc:annotation-driven></p>
<h3 id="2-10-获得-Servlet-相关-API"><a href="#2-10-获得-Servlet-相关-API" class="headerlink" title="2.10 获得 Servlet 相关 API"></a>2.10 获得 Servlet 相关 API</h3><p>SpringMVC 支持使用原始 ServletAPI 对象作为控制器方法的参数进行注入，常用的对象如下：<br>● HttpServletRequest<br>● HttpServletResponse<br>● HttpSession</p>
<p>@RequestMapping(value = “/quick19”)<br>@ResponseBody<br>public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) {<br>    System.out.println(request);<br>    System.out.println(response);<br>    System.out.println(session);<br>}<br>输出：</p>
<p>org.apache.catalina.connector.RequestFacade@143935e<br>org.apache.catalina.connector.ResponseFacade@14ac0c3<br>org.apache.catalina.session.StandardSessionFacade@1daa35e<br>这里输出的是 catalina，等价于这里生成的三个对象是 tomcat 原生产生的，然后传给 springmvc 框架，调用方法时引用传递给参数。</p>
<h3 id="2-11-获得请求头"><a href="#2-11-获得请求头" class="headerlink" title="2.11 获得请求头"></a>2.11 获得请求头</h3><p>（1）@RequestHeader</p>
<p>使用 @RequestHeader 可以获得请求头信息，相当于 web 阶段学习的 request.getHeader (name)<br>@RequestHeader 注解的属性如下：<br>● value：请求头的名称<br>● required：是否必须携带此请求头</p>
<p>@RequestMapping(value = “/quick20”)<br>@ResponseBody<br>public void save20(@RequestHeader(value = “User-Agent”,required = false) String user_agent) {<br>    System.out.println(user_agent);<br>}<br>（2）@CookieValue</p>
<p>使用 @CookieValue 可以获得指定 Cookie 的值<br>@CookieValue 注解的属性如下：<br>● value：指定 cookie 的名称<br>● required：是否必须携带此 cookie</p>
<p>@RequestMapping(value = “/quick21”)<br>@ResponseBody<br>public void save21(@CookieValue(value = “JSESSIONID”,required = false) String jsessionId) {<br>    System.out.println(jsessionId);<br>}</p>
<h3 id="2-12-文件上传"><a href="#2-12-文件上传" class="headerlink" title="2.12 文件上传"></a>2.12 文件上传</h3><p>（1）文件上传客户端三要素<br>● 表单项 type=“file”<br>● 表单的提交方式是 post<br>● 表单的 enctype 属性是多部分表单形式，及 enctype=“multipart/form-data”</p>
<form action="${pageContext.request.contextPath}/user/quick22" method="post" enctype="multipart/form-data">
    名称：<input type="text" name="username"><br/>
    文件：<input type="file" name="uploadFile"><br/>
    <input type="submit" value="提交">
</form>
![在这里插入图片描述](https://gitee.com/an-menghe/img/raw/master/test/202202212349096.png)

<p>（2）文件上传原理<br>● 当 form 表单修改为多部分表单时，request.getParameter () 将失效。<br>● enctype=“application/x-www-form-urlencoded” 时，form 表单的正文内容格式是：<br>key=value&amp;key=value&amp;key=value<br>● 当 form 表单的 enctype 取值为 Mutilpart/form-data 时，请求正文内容就变成多部分形式：</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212349938.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-13-单文件上传步骤"><a href="#2-13-单文件上传步骤" class="headerlink" title="2.13 单文件上传步骤"></a>2.13 单文件上传步骤</h3><p>① 导入 fileupload 和 io 坐标<br>② 配置文件上传解析器<br>③ 编写文件上传代码</p>
<h3 id="2-14-单文件上传实现"><a href="#2-14-单文件上传实现" class="headerlink" title="2.14 单文件上传实现"></a>2.14 单文件上传实现</h3><p>① 导入 fileupload 和 io 坐标</p>
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.1</version>
</dependency>
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.3</version>
</dependency>
② 配置文件上传解析器

<!--配置文件上传解析器-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <!--上传文件的编码类型-->
    <property name="defaultEncoding" value="UTF-8"></property>
    <!--上传文件的总大小-->
    <property name="maxUploadSize" value="5242800"></property>
    <!--上传单个文件的大小-->
    <property name="maxUploadSizePerFile" value="5242800"></property>
</bean>
③ 编写文件上传代码

<p>@RequestMapping(value = “/quick22”)<br>@ResponseBody<br>public void save22(String username, MultipartFile uploadFile) throws IOException {<br>    System.out.println(username);<br>    //获得上传文件的名称<br>    String originalFilename = uploadFile.getOriginalFilename();<br>    uploadFile.transferTo(new File(“E:\图片\“ + originalFilename));<br>}</p>
<h3 id="2-15-多文件上传实现"><a href="#2-15-多文件上传实现" class="headerlink" title="2.15 多文件上传实现"></a>2.15 多文件上传实现</h3><p>多文件上传，只需要将页面修改为多个文件上传项，将方法参数 MultipartFile 类型修改为 MultipartFile [] 即可</p>
<form action="${pageContext.request.contextPath}/user/quick23" method="post" enctype="multipart/form-data">
    名称：<input type="text" name="username"><br/>
    文件1：<input type="file" name="uploadFile"><br/>
    文件2：<input type="file" name="uploadFile"><br/>
    文件3：<input type="file" name="uploadFile"><br/>
    <input type="submit" value="提交">
</form>
@RequestMapping(value = "/quick23")
@ResponseBody
public void save23(String username, MultipartFile[] uploadFile) throws IOException {
    System.out.println(username);
    for (MultipartFile multipartFile : uploadFile) {
        String originalFilename = multipartFile.getOriginalFilename();
        multipartFile.transferTo(new File("E:\\图片\\" + originalFilename));
    }
}

<h3 id="2-16-知识要点"><a href="#2-16-知识要点" class="headerlink" title="2.16 知识要点"></a>2.16 知识要点</h3><p>MVC 实现数据请求方式<br>● 基本类型参数<br>● POJO 类型参数<br>● 数组类型参数<br>● 集合类型参数</p>
<p>MVC 获取数据细节<br>● 中文乱码问题<br>● @RequestParam 和 @PathVariable<br>● 自定义类型转换器<br>● 获得 Servlet 相关 API<br>● @RequestHeader 和 @CookieValue<br>● 文件上传</p>
<h1 id="第五章-JdbcTemplate"><a href="#第五章-JdbcTemplate" class="headerlink" title="第五章 JdbcTemplate"></a>第五章 JdbcTemplate</h1><h2 id="1-Spring-JdbcTemplate-基本使用"><a href="#1-Spring-JdbcTemplate-基本使用" class="headerlink" title="1.Spring JdbcTemplate 基本使用"></a>1.Spring JdbcTemplate 基本使用</h2><h3 id="1-1-JdbcTemplate-概述"><a href="#1-1-JdbcTemplate-概述" class="headerlink" title="1.1 JdbcTemplate 概述"></a>1.1 JdbcTemplate 概述</h3><p>它是 spring 框架中提供的一个对象，是对原始繁琐的 Jdbc API 对象的简单封装。spring 框架为我们提供了很多的操作模板类。例如：操作关系型数据的 JdbcTemplate 和 HibernateTemplate，操作 nosql 数据库的 RedisTemplate，操作消息队列的 JmsTemplate 等等。</p>
<h3 id="1-2-JdbcTemplate-开发步骤"><a href="#1-2-JdbcTemplate-开发步骤" class="headerlink" title="1.2 JdbcTemplate 开发步骤"></a>1.2 JdbcTemplate 开发步骤</h3><p>① 导入 spring-jdbc 和 spring-tx 坐标<br>② 创建数据库表和实体<br>③ 创建 JdbcTemplate 对象<br>④ 执行数据库操作</p>
<h3 id="1-3-JdbcTemplate-快速入门"><a href="#1-3-JdbcTemplate-快速入门" class="headerlink" title="1.3 JdbcTemplate 快速入门"></a>1.3 JdbcTemplate 快速入门</h3><p>① 导入坐标</p>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>
② 创建 accout 表和 Accout 实体

<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212354675.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>③ 创建 JdbcTemplate 对象<br>④ 执行数据库操作</p>
<p>//创建数据源对象<br>ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>dataSource.setDriverClass(“com.mysql.jdbc.Driver”);<br>dataSource.setJdbcUrl(“jdbc:mysql://localhost:3306/test”);<br>dataSource.setUser(“root”);<br>dataSource.setPassword(“”);</p>
<p>JdbcTemplate jdbcTemplate = new JdbcTemplate();<br>//设置数据源对象 知道数据库在哪<br>jdbcTemplate.setDataSource(dataSource);<br>//执行操作<br>int row = jdbcTemplate.update(“insert into account values(?,?)”, “tom”, 5000);<br>System.out.println(row);</p>
<h3 id="1-4-Spring-产生-JdbcTemplate-对象"><a href="#1-4-Spring-产生-JdbcTemplate-对象" class="headerlink" title="1.4 Spring 产生 JdbcTemplate 对象"></a>1.4 Spring 产生 JdbcTemplate 对象</h3><p>我们可以将 JdbcTemplate 的创建权交给 Spring，将数据源 DataSource 的创建权也交给 Spring，在 Spring 容器内部将数据源 DataSource 注入到 JdbcTemplate 模版对象中，配置如下：</p>
<p>jdbc.properties：</p>
<p>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/test<br>jdbc.username=root<br>jdbc.password=root</p>
<!--加载jdbc.properties-->
<p>&lt;context:property-placeholder location=”jdbc.properties”&gt;</context:property-placeholder></p>
<!--数据源对象-->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}"></property>
    <property name="jdbcUrl" value="${jdbc.url}"></property>
    <property name="user" value="${jdbc.username}"></property>
    <property name="password" value="${jdbc.password}"></property>
</bean>

<!--jdbc模板对象-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="dataSource"></property>
</bean>

<p>从容器中获得 JdbcTemplate 进行添加操作</p>
<p>@Test<br>//测试Spring产生JdbcTemplate对象<br>public void test2() {<br>    ApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>    JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class);<br>    int row = jdbcTemplate.update(“insert into account values(?,?)”, “zhangsan”, 5000);<br>    System.out.println(row);<br>}</p>
<h3 id="1-5-JdbcTemplate-的常用操作"><a href="#1-5-JdbcTemplate-的常用操作" class="headerlink" title="1.5 JdbcTemplate 的常用操作"></a>1.5 JdbcTemplate 的常用操作</h3><p>修改操作</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class JdbcTemplateCRUDTest {<br>     @Autowired<br>     JdbcTemplate jdbcTemplate;</p>
<pre><code> @Test
 public void testUpdate() &#123;
      jdbcTemplate.update(&quot;update account set money=? where name=?&quot;, 10000, &quot;tom&quot;);
 &#125;
</code></pre>
<p>}<br>删除和查询全部操作</p>
<p>@Test<br>public void testDelete() {<br>    jdbcTemplate.update(“delete from account where name=?”, “tom”);<br>}</p>
<p>@Test<br>public void testQueryAll(){</p>
<pre><code>//new BeanPropertyRowMapper&lt;封装的实体类&gt;

List&lt;Account&gt; accountList = jdbcTemplate.query(&quot;select* from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class));
System.out.println(accountList);
</code></pre>
<p>}<br>查询单个数据操作操作</p>
<p>@Test<br>//测试查询单个对象操作<br>public void testQueryOne(){<br>    Account account = jdbcTemplate.queryForObject(“select * from account where name=?”, new BeanPropertyRowMapper<Account>(Account.class), “tom”);<br>    System.out.println(account);<br>}</p>
<p>@Test<br>//测试查询单个简单数据操作(聚合查询)<br>public void testQueryCount(){<br>    Long count = jdbcTemplate.queryForObject(“select count(*) from account”, Long.class);<br>    System.out.println(count);<br>}</p>
<h3 id="1-6-知识要点-1"><a href="#1-6-知识要点-1" class="headerlink" title="1.6 知识要点"></a>1.6 知识要点</h3><p>① 导入 spring-jdbc 和 spring-tx 坐标<br>② 创建数据库表和实体<br>③ 创建 JdbcTemplate 对象</p>
<p>JdbcTemplate jdbcTemplate = new JdbcTemplate();<br>jdbcTemplate.setDataSource(dataSource);</p>
<p>④ 执行数据库操作</p>
<p>更新操作：<br>jdbcTemplate.update (sql,params)<br>查询操作：<br>jdbcTemplate.query (sql,Mapper,params)<br>jdbcTemplate.queryForObject(sql,Mapper,params)</p>
<h1 id="第六章-Spring-练习"><a href="#第六章-Spring-练习" class="headerlink" title="第六章 Spring 练习"></a>第六章 Spring 练习</h1><h2 id="1-Spring-练习环境搭建"><a href="#1-Spring-练习环境搭建" class="headerlink" title="1.Spring 练习环境搭建"></a>1.Spring 练习环境搭建</h2><h3 id="1-1-Spring-环境搭建步骤"><a href="#1-1-Spring-环境搭建步骤" class="headerlink" title="1.1 Spring 环境搭建步骤"></a>1.1 Spring 环境搭建步骤</h3><p>① 创建工程（Project&amp;Module）<br>② 导入静态页面（见资料 jsp 页面）<br>③ 导入需要坐标（见资料中的 pom.xml）<br>④ 创建包结构（controller、service、dao、domain、utils）<br>⑤ 导入数据库脚本（见资料 test.sql）<br>⑥ 创建 POJO 类（见资料 User.java 和 Role.java）<br>⑦ 创建配置文件（applicationContext.xml、spring-mvc.xml、jdbc.properties、log4j.properties）</p>
<p>web.xml</p>
<!--全局的初始化参数-->
<!--Spring集成Web环境的配置-->
<context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>classpath:applicationContext.xml</param-value>
</context-param>

<!--Spring的监听器-->
<!--Spring集成Web环境的配置-->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>



<!--SpringMVC的前端控制器-->
<servlet>
  <servlet-name>DispatcherServlet</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  <init-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring-mvc.xml</param-value>
  </init-param>
  <load-on-startup>2</load-on-startup>
</servlet>

<servlet-mapping>
  <servlet-name>DispatcherServlet</servlet-name>
  <url-pattern>/</url-pattern>
</servlet-mapping>
spring-mvc.xml

<!--1、mvc注解驱动-->
<p><a href="mvc:annotation-driven/">mvc:annotation-driven/</a></p>
<!--2、配置视图解析器-->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/pages/"></property>
    <property name="suffix" value=".jsp"></property>
</bean>

<!--3、静态资源权限开放-->
<p><a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a><br>applicationContext.xml</p>
<!--1、加载jdbc.properties-->
<p>&lt;context:property-placeholder location=”jdbc.properties”&gt;</context:property-placeholder></p>
<!--2、配置数据源对象-->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}"></property>
    <property name="jdbcUrl" value="${jdbc.url}"></property>
    <property name="user" value="${jdbc.username}"></property>
    <property name="password" value="${jdbc.password}"></property>
</bean>

<!--3、配置JdbcTemplate对象-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="dataSource"></property>
</bean>

<h3 id="1-2-用户和角色的关系"><a href="#1-2-用户和角色的关系" class="headerlink" title="1.2 用户和角色的关系"></a>1.2 用户和角色的关系</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220004746.png" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220004414.png" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="2-角色列表的展示和添加操作"><a href="#2-角色列表的展示和添加操作" class="headerlink" title="2.角色列表的展示和添加操作"></a>2.角色列表的展示和添加操作</h2><h3 id="2-1-角色列表的展示效果"><a href="#2-1-角色列表的展示效果" class="headerlink" title="2.1 角色列表的展示效果"></a>2.1 角色列表的展示效果</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220006201.png" alt="img"></p>
</blockquote>
<p>2.2 角色列表的展示步骤分析<br>① 点击角色管理菜单发送请求到服务器端（修改角色管理菜单的 url 地址）<br>② 创建 RoleController 和 showList () 方法<br>③ 创建 RoleService 和 showList () 方法<br>④ 创建 RoleDao 和 findAll () 方法<br>⑤ 使用 JdbcTemplate 完成查询操作<br>⑥ 将查询数据存储到 Model 中</p>
<p>导入 c 命名 &lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</p>
<p>使用</p>
<blockquote>
<p>&lt;c:forEach items=”” var=””&gt;</p>
<tr>
<td>${}</td>
<td>${}</td>
<td>${}</td>
<td>${}</td>
<td>${}</td>
<td>${}</td>
</tr>
</c:forEach>
⑦ 转发到 role-list.jsp 页面进行展示
</blockquote>
<h2 id="2-3-角色添加的效果"><a href="#2-3-角色添加的效果" class="headerlink" title="2.3 角色添加的效果"></a>2.3 角色添加的效果</h2><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220014241.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-4-角色添加的步骤分析"><a href="#2-4-角色添加的步骤分析" class="headerlink" title="2.4 角色添加的步骤分析"></a>2.4 角色添加的步骤分析</h3><p>① 点击列表页面新建按钮跳转到角色添加页面<br>② 输入角色信息，点击保存按钮，表单数据提交服务器<br>③ 编写 RoleController 的 save () 方法<br>④ 编写 RoleService 的 save () 方法<br>⑤ 编写 RoleDao 的 save () 方法<br>⑥ 使用 JdbcTemplate 保存 Role 数据到 sys_role<br>⑦ 跳转回角色列表页面</p>
<h2 id="3-用户列表的展示和添加操作"><a href="#3-用户列表的展示和添加操作" class="headerlink" title="3.用户列表的展示和添加操作"></a>3.用户列表的展示和添加操作</h2><h3 id="3-1-用户列表的展示效果"><a href="#3-1-用户列表的展示效果" class="headerlink" title="3.1 用户列表的展示效果"></a>3.1 用户列表的展示效果</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220016093.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-2-用户列表的展示步骤分析"><a href="#3-2-用户列表的展示步骤分析" class="headerlink" title="3.2 用户列表的展示步骤分析"></a>3.2 用户列表的展示步骤分析</h3><p>① 点击用户管理菜单发送请求到服务器端（修改用户管理菜单的 url 地址）<br>② 创建 RoleController 和 showList () 方法<br>③ 创建 RoleService 和 showList () 方法<br>④ 创建 RoleDao 和 findAll () 方法<br>⑤ 使用 JdbcTemplate 完成查询操作<br>⑥ 将查询数据存储到 Model 中<br>⑦ 转发到 user-list.jsp 页面进行展示</p>
<h3 id="3-3-用户添加的效果"><a href="#3-3-用户添加的效果" class="headerlink" title="3.3 用户添加的效果"></a>3.3 用户添加的效果</h3><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220017546.png" alt="在这里插入图片描述"></p>
<h3 id="3-4-用户添加的步骤分析"><a href="#3-4-用户添加的步骤分析" class="headerlink" title="3.4 用户添加的步骤分析"></a>3.4 用户添加的步骤分析</h3><p>① 点击列表页面新建按钮（访问 /saveUI）跳转到角色添加页面</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220024232.png" alt="image-20220222002415111"></p>
</blockquote>
<p>方法查询了角色表，并返回视图和数据</p>
<p>导入 c 命名 &lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</p>
<p>使用</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220025167.png" alt="image-20220222002551029"></p>
<p>② 输入角色信息，点击保存按钮，表单数据提交服务器<br>③ 编写 RoleController 的 save () 方法</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220027507.png" alt="image-20220222002758440"></p>
<p>④ 编写 RoleService 的 save () 方法</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220027806.png" alt="image-20220222002718739"></p>
<p>⑤ 编写 RoleDao 的 save () 方法</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220028389.png" alt="image-20220222002855258"></p>
<p>因为数据库的主键是递增的无法第一时间获取 userId，运行会报错，所以这里的解决办法是（学习 Mybatishou, 就特别好解决 ，这里的解决方法只做了解）</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220032096.png" alt="image-20220222003212971"></p>
<p>⑥ 使用 JdbcTemplate 保存 Role 数据到 sys_role<br>⑦ 跳转回角色列表页面</p>
<h2 id="4-删除用户操作"><a href="#4-删除用户操作" class="headerlink" title="4.删除用户操作"></a>4.删除用户操作</h2><h3 id="4-1-删除用户的效果"><a href="#4-1-删除用户的效果" class="headerlink" title="4.1 删除用户的效果"></a>4.1 删除用户的效果</h3><h3 id="4-2-删除用户的步骤分析"><a href="#4-2-删除用户的步骤分析" class="headerlink" title="4.2 删除用户的步骤分析"></a>4.2 删除用户的步骤分析</h3><p>① 点击用户列表的删除按钮，发送请求到服务器端<br>② 编写 UserController 的 deleteById () 方法<br>③ 编写 UserService 的 deleteById () 方法<br>④ 编写 UserDao 的 deleteById () 方法<br>⑤ 编写 UserDao 的 deleteRelByUid () 方法<br>⑥ 跳回当前用户列表页面</p>
<h1 id="第七章-SpringMVC-拦截器"><a href="#第七章-SpringMVC-拦截器" class="headerlink" title="第七章 SpringMVC 拦截器"></a>第七章 SpringMVC 拦截器</h1><h2 id="1-SpringMVC-拦截器"><a href="#1-SpringMVC-拦截器" class="headerlink" title="1.SpringMVC 拦截器"></a>1.SpringMVC 拦截器</h2><h3 id="1-1-拦截器（interceptor）的作用"><a href="#1-1-拦截器（interceptor）的作用" class="headerlink" title="1.1 拦截器（interceptor）的作用"></a>1.1 拦截器（interceptor）的作用</h3><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p>
<p>将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是 AOP 思想的具体实现。</p>
<h3 id="1-2-拦截器和过滤器区别"><a href="#1-2-拦截器和过滤器区别" class="headerlink" title="1.2 拦截器和过滤器区别"></a>1.2 拦截器和过滤器区别</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220035906.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-3-拦截器的快速入门"><a href="#1-3-拦截器的快速入门" class="headerlink" title="1.3 拦截器的快速入门"></a>1.3 拦截器的快速入门</h3><p>自定义拦截器很简单，只有如下三步：<br>① 创建拦截器类实现 HandlerInterceptor 接口<br>② 配置拦截器<br>③ 测试拦截器的拦截效果</p>
<p>① 创建拦截器类实现 HandlerInterceptor 接口</p>
<p>public class MyInterceptor1 implements HandlerInterceptor {<br>    //在目标方法执行之前 执行<br>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {<br>        System.out.println(“preHandle…..”);<br>        //设置true 表示放行<br>        return true;<br>    }<br>    //在目标方法执行之后 视图对象返回之前执行<br>    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {<br>        System.out.println(“postHandle…”);<br>    }<br>    //在流程都执行完毕后 执行<br>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {<br>        System.out.println(“afterCompletion….”);<br>    }<br>}<br>② 配置拦截器</p>
<!--配置拦截器-->
<p><a href="mvc:interceptors">mvc:interceptors</a><br>    <a href="mvc:interceptor">mvc:interceptor</a><br>        <!--对哪些资源进行拦截操作  (这里是所有)--><br>        &lt;mvc:mapping path=”/**”/&gt;<br>        <bean class="com.itheima.interceptor.MyInterceptor1"></bean><br>    </mvc:interceptor><br></mvc:interceptors></p>
<p>③ 测试拦截器的拦截效果（编写目标方法）</p>
<p>@Controller<br>public class TargetController {<br>    @RequestMapping(“/target”)<br>    public ModelAndView show(){<br>        System.out.println(“目标资源执行……”);<br>        ModelAndView modelAndView = new ModelAndView();<br>        modelAndView.addObject(“name”,”itcast”);<br>        modelAndView.setViewName(“index”);<br>        return modelAndView;<br>    }<br>}<br>访问网址：<a href="http://localhost:8080/target">http://localhost:8080/target</a><br>控制台打印结果</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220037230.png" alt="img"></p>
<h3 id="1-4-多拦截器操作"><a href="#1-4-多拦截器操作" class="headerlink" title="1.4 多拦截器操作"></a>1.4 多拦截器操作</h3><p>同上，再编写一个 MyHandlerInterceptor2 操作，测试执行顺序</p>
<p>public class MyInterceptor2 implements HandlerInterceptor {<br>    //在目标方法执行之前 执行<br>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {<br>        System.out.println(“preHandle2222…..”);<br>        return true;<br>    }<br>    //在目标方法执行之后 视图对象返回之前执行<br>    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {<br>        modelAndView.addObject(“name”,”itheima”);<br>        System.out.println(“postHandle2222…”);<br>    }<br>    //在流程都执行完毕后 执行<br>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {<br>        System.out.println(“afterCompletion2222….”);<br>    }<br>}</p>
<!--配置拦截器-->
<p><a href="mvc:interceptors">mvc:interceptors</a><br>    <a href="mvc:interceptor">mvc:interceptor</a><br>        <!--对哪些资源进行拦截操作--><br>        &lt;mvc:mapping path=”/**”/&gt;<br>        <bean class="com.itheima.interceptor.MyInterceptor1"></bean><br>    </mvc:interceptor><br>    <a href="mvc:interceptor">mvc:interceptor</a><br>        <!--对哪些资源进行拦截操作--><br>        &lt;mvc:mapping path=”/**”/&gt;<br>        <bean class="com.itheima.interceptor.MyInterceptor2"></bean><br>    </mvc:interceptor><br></mvc:interceptors><br>输出结果：(拦截顺序 与 配置拦截器的前后位置有关，，，遵循前进后出原则)</p>
<p>preHandle…..<br>preHandle2222…..<br>目标资源执行……<br>postHandle2222…<br>postHandle…<br>afterCompletion2222….<br>afterCompletion….</p>
<h3 id="1-5-拦截器方法说明"><a href="#1-5-拦截器方法说明" class="headerlink" title="1.5 拦截器方法说明"></a>1.5 拦截器方法说明</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220041752.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-6-知识要点-2"><a href="#1-6-知识要点-2" class="headerlink" title="1.6 知识要点"></a>1.6 知识要点</h3><p>自定义拦截器步骤<br>① 创建拦截器类实现 HandlerInterceptor 接口<br>② 配置拦截器<br>③ 测试拦截器的拦截效果</p>
<h3 id="1-7-案例-用户登录权限控制"><a href="#1-7-案例-用户登录权限控制" class="headerlink" title="1.7 案例 - 用户登录权限控制"></a>1.7 案例 - 用户登录权限控制</h3><p>需求：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作</p>
<p>1—- 需要放行登录请求路径</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220045115.png" alt="image-20220222004554024"></p>
<p>2—- 登录的用户，会在 HttpSession session 中放一个 key 值为 user</p>
<p>3—- 根据 HttpSession session 的 session.getAttribute (“user”) 是否为空值 ，来进行放行</p>
<p> 为 null ,return false 拦截，并重定向到登录页面</p>
<p> 不为空，,return true 放行 正常跳转</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220055379.png" alt="在这里插入图片描述"></p>
<h1 id="第八章-SpringMVC-异常处理机制"><a href="#第八章-SpringMVC-异常处理机制" class="headerlink" title="第八章 SpringMVC 异常处理机制"></a>第八章 SpringMVC 异常处理机制</h1><h2 id="1-SpringMVC-异常处理"><a href="#1-SpringMVC-异常处理" class="headerlink" title="1.SpringMVC 异常处理"></a>1.SpringMVC 异常处理</h2><h3 id="1-1-异常处理的思路"><a href="#1-1-异常处理的思路" class="headerlink" title="1.1 异常处理的思路"></a>1.1 异常处理的思路</h3><p>系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p>
<p>系统的 Dao、Service、Controller 出现都通过 throws Exception 向上抛出，最后由 SpringMVC 前端控制器交由异常处理器进行异常处理，如下图：</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221121080.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-2-异常处理两种方式"><a href="#1-2-异常处理两种方式" class="headerlink" title="1.2 异常处理两种方式"></a>1.2 异常处理两种方式</h3><p>● 使用 Spring MVC 提供的简单异常处理器 SimpleMappingExceptionResolver<br>● 实现 Spring 的异常处理接口 HandlerExceptionResolver 自定义自己的异常处理器</p>
<h3 id="1-3-简单异常处理器-SimpleMappingExceptionResolver"><a href="#1-3-简单异常处理器-SimpleMappingExceptionResolver" class="headerlink" title="1.3 简单异常处理器 SimpleMappingExceptionResolver"></a>1.3 简单异常处理器 SimpleMappingExceptionResolver</h3><p>SpringMVC 已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置</p>
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <!--没有其他要求，配这一个就可以-->
    <property name="defaultErrorView" value="error"/>
    <property name="exceptionMappings">

<pre><code>    &lt;map&gt;
        &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error1&quot;/&gt;
        &lt;entry key=&quot;com.itheima.exception.MyException&quot; value=&quot;error2&quot;/&gt;
    &lt;/map&gt;
</code></pre>
<p>​    </property><br></bean></p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221122088.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-4-自定义异常处理步骤"><a href="#1-4-自定义异常处理步骤" class="headerlink" title="1.4 自定义异常处理步骤"></a>1.4 自定义异常处理步骤</h3><p>① 创建异常处理器类实现 HandlerExceptionResolver<br>② 配置异常处理器<br>③ 编写异常页面<br>④ 测试异常跳转</p>
<p>① 创建异常处理器类实现 HandlerExceptionResolver</p>
<p>public class MyExceptionResolver implements HandlerExceptionResolver {<br>    /*<br>       参数Exception：异常对象<br>       返回值ModelAndView：跳转到错误视图信息<br>    */<br>    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {<br>        ModelAndView modelAndView = new ModelAndView();<br>        if (e instanceof MyException) {<br>            modelAndView.addObject(“info”, “自定义异常”);<br>        } else if (e instanceof ClassCastException) {<br>            modelAndView.addObject(“info”, “类转换异常”);<br>        }<br>        modelAndView.setViewName(“error”);<br>        return modelAndView;<br>    }<br>}<br>② 配置异常处理器</p>
<!--自定义异常处理器-->
<p><bean class="com.itheima.resolver.MyExceptionResolver"></bean>③ 编写异常页面<br>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p>
<html>

<head>
    <title>Title</title>
</head>

<body>
    
<pre><code>&lt;h1&gt;通用的错误提示页面&lt;/h1&gt;
&lt;h1&gt;$&#123;info&#125;&lt;/h1&gt;
</code></pre>
</body>
</html>
④ 测试异常跳转

<h3 id="1-5-知识要点-1"><a href="#1-5-知识要点-1" class="headerlink" title="1.5 知识要点"></a>1.5 知识要点</h3><p>异常处理方式<br>● 配置简单异常处理器 SimpleMappingExceptionResolver<br>● 自定义异常处理器</p>
<p>自定义异常处理步骤<br>① 创建异常处理器类实现 HandlerExceptionResolver<br>② 配置异常处理器<br>③ 编写异常页面<br>④ 测试异常跳转</p>
<h1 id="第九章-面向切面编程-AOP"><a href="#第九章-面向切面编程-AOP" class="headerlink" title="第九章 面向切面编程 AOP"></a>第九章 面向切面编程 AOP</h1><h2 id="1-Spring-的-AOP-简介"><a href="#1-Spring-的-AOP-简介" class="headerlink" title="1.Spring 的 AOP 简介"></a>1.Spring 的 AOP 简介</h2><h3 id="1-1-什么是-AOP"><a href="#1-1-什么是-AOP" class="headerlink" title="1.1 什么是 AOP"></a>1.1 什么是 AOP</h3><p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>AOP 是 OOP 的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h3 id="1-2-AOP-的作用及其优势"><a href="#1-2-AOP-的作用及其优势" class="headerlink" title="1.2 AOP 的作用及其优势"></a>1.2 AOP 的作用及其优势</h3><p>● 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强<br>● 优势：减少重复代码，提高开发效率，并且便于维护</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221253383.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-AOP-的底层实现"><a href="#1-3-AOP-的底层实现" class="headerlink" title="1.3 AOP 的底层实现"></a>1.3 AOP 的底层实现</h3><p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring 通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p>
<h3 id="1-4-AOP-的动态代理技术"><a href="#1-4-AOP-的动态代理技术" class="headerlink" title="1.4 AOP 的动态代理技术"></a>1.4 AOP 的动态代理技术</h3><p>常用的动态代理技术<br>● JDK 代理：基于接口的动态代理技术<br>● cglib 代理：基于父类的动态代理技术</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221254107.png" alt="在这里插入图片描述"></p>
<h3 id="1-5-JDK-的动态代理"><a href="#1-5-JDK-的动态代理" class="headerlink" title="1.5 JDK 的动态代理"></a>1.5 JDK 的动态代理</h3><p>① 目标类接口</p>
<p>public interface TargetInterface {<br>    public void save();<br>}<br>② 目标类</p>
<p>public class Target implements TargetInterface {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>    }<br>}<br>③ 增强代码</p>
<p>public class Advice {<br>    public void before() {<br>        System.out.println(“前置增强….”);<br>    }<br>    public void afterReturning() {<br>        System.out.println(“后置增强….”);<br>    }<br>}<br>④ 动态代理代码</p>
<p>//目标对象<br>final Target target = new Target();</p>
<p>//增强对象<br>final Advice advice = new Advice();</p>
<p>//返回值 就是动态生成的代理对象<br>TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(<br>        target.getClass().getClassLoader(), //目标对象类加载器<br>        target.getClass().getInterfaces(), //目标对象相同的接口字节码对象数组<br>        new InvocationHandler() {<br>            //调用代理对象的任何方法  实质执行的都是invoke方法<br>            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>                advice.before(); //前置增强<br>                Object invoke = method.invoke(target, args);//执行目标方法<br>                advice.afterReturning(); //后置增强<br>                return invoke;<br>            }<br>        }<br>);<br>⑤ 调用代理对象的方法测试</p>
<p>//调用代理对象的方法<br>proxy.save();<br>输出结果：</p>
<p>前置增强….<br>save running…..</p>
<p>后置增强….</p>
<h3 id="1-6-cglib-的动态代理"><a href="#1-6-cglib-的动态代理" class="headerlink" title="1.6 cglib 的动态代理"></a>1.6 cglib 的动态代理</h3><p>① 目标类</p>
<p>public class Target {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>    }<br>}<br>② 动态代理代码</p>
<p>//目标对象<br>final Target target = new Target();<br>//增强对象<br>final Advice advice = new Advice();<br>//返回值 就是动态生成的代理对象  基于cglib<br>//1、创建增强器<br>Enhancer enhancer = new Enhancer();<br>//2、设置父类（目标）<br>enhancer.setSuperclass(Target.class);<br>//3、设置回调<br>enhancer.setCallback(new MethodInterceptor() {<br>    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {<br>        advice.before(); //执行前置<br>        Object invoke = method.invoke(target, args);//执行目标<br>        advice.afterReturning(); //执行后置<br>        return invoke;<br>    }<br>});<br>//4、创建代理对象<br>Target proxy = (Target) enhancer.create();<br>③ 调用代理对象的方法测试</p>
<p>proxy.save();<br>前置增强….<br>save running…..<br>后置增强….</p>
<h3 id="1-7-AOP-相关概念"><a href="#1-7-AOP-相关概念" class="headerlink" title="1.7 AOP 相关概念"></a>1.7 AOP 相关概念</h3><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p>
<p>在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：<br>● Target（目标对象）：代理的目标对象<br>● Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类<br>● Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在 spring 中，这些点指的是方法，因为 spring 只支持方法类型的连接点。通俗的说，可以被增强的方法叫连接点<br>● Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义<br>● Advice（通知 / 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知<br>● Aspect（切面）：是切入点和通知（引介）的结合<br>● Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入</p>
<h3 id="1-8-AOP-开发明确的事项"><a href="#1-8-AOP-开发明确的事项" class="headerlink" title="1.8 AOP 开发明确的事项"></a>1.8 AOP 开发明确的事项</h3><p>（1）需要编写的内容<br>● 编写核心业务代码（目标类的目标方法）<br>● 编写切面类，切面类中有通知 (增强功能方法)<br>● 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</p>
<p>（2）AOP 技术实现的内容<br>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>
<p>（3）AOP 底层使用哪种代理方式<br>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p>
<h3 id="1-9-知识要点"><a href="#1-9-知识要点" class="headerlink" title="1.9 知识要点"></a>1.9 知识要点</h3><p>● aop：面向切面编程<br>● aop 底层实现：基于 JDK 的动态代理 和 基于 Cglib 的动态代理<br>● aop 的重点概念：<br>Pointcut（切入点）：被增强的方法<br>Advice（通知 / 增强）：封装增强业务逻辑的方法<br>Aspect（切面）：切点 + 通知<br>Weaving（织入）：将切点与通知结合的过程</p>
<p>● 开发明确事项：<br>谁是切点（切点表达式配置）<br>谁是通知（切面类中的增强方法）<br>将切点和通知进行织入配置</p>
<h2 id="2-基于-XML-的-AOP-开发"><a href="#2-基于-XML-的-AOP-开发" class="headerlink" title="2.基于 XML 的 AOP 开发"></a>2.基于 XML 的 AOP 开发</h2><h3 id="2-1-快速入门"><a href="#2-1-快速入门" class="headerlink" title="2.1 快速入门"></a>2.1 快速入门</h3><p>① 导入 AOP 相关坐标<br>② 创建目标接口和目标类（内部有切点）<br>③ 创建切面类（内部有增强方法）<br>④ 将目标类和切面类的对象创建权交给 spring<br>⑤ 在 applicationContext.xml 中配置织入关系<br>⑥ 测试代码</p>
<p>① 导入 AOP 相关坐标</p>
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-context</artifactId>
  <version>5.0.5.RELEASE</version>
</dependency>
<!--AOP织-->
<dependency>
  <groupId>org.aspectj</groupId>
  <artifactId>aspectjweaver</artifactId>
  <version>1.8.4</version>
</dependency>
② 创建目标接口和目标类（内部有切点）

<p>public interface TargetInterface {<br>    public void save();<br>}</p>
<p>public class Target implements TargetInterface {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>    }<br>}<br>③ 创建切面类（内部有增强方法）</p>
<p>public class MyAspect {<br>    public void before(){<br>        System.out.println(“前置增强……….”);<br>    }<br>}<br>④ 将目标类和切面类的对象创建权交给 spring</p>
<!--目标对象-->
<p><bean id="target" class="com.itheima.aop.Target"></bean></p>
<!--切面对象-->
<p><bean id="myAspect" class="com.itheima.aop.MyAspect"></bean><br>⑤ 在 applicationContext.xml 中配置织入关系<br>导入 aop 命名空间</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
"></p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221302641.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>配置切点表达式和前置增强的织入关系</p>
<!--配置织入：告诉spring框架 哪些方法(切点)需要进行哪些增强(前置、后置...)-->
<p><a href="aop:config">aop:config</a><br>    <!--声明切面--><br>    &lt;aop:aspect ref=”myAspect”&gt;<br>        <!--切面：切点+通知--><br>        &lt;aop:before method=”before” pointcut=”execution(public void com.itheima.aop.Target.save())”&gt;                 </aop:before><br>    </aop:aspect><br></aop:config><br>⑥ 测试代码</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class AopTest {<br>    @Autowired<br>    private TargetInterface target;<br>    @Test<br>    public void test1(){<br>        target.save();<br>    }<br>}<br>⑦ 测试结果</p>
<p>前置增强……….<br>save running…..</p>
<h3 id="2-2-XML-配置-AOP-详解"><a href="#2-2-XML-配置-AOP-详解" class="headerlink" title="2.2 XML 配置 AOP 详解"></a>2.2 XML 配置 AOP 详解</h3><p>（1）切点表达式的写法<br>表达式语法：</p>
<p>execution ([修饰符] 返回值类型 包名。类名。方法名 (参数))</p>
<p>● 访问修饰符可以省略<br>● 返回值类型、包名、类名、方法名可以使用星号 * 代表任意<br>● 包名与类名之间一个点。代表当前包下的类，两个点 .. 表示当前包及其子包下的类<br>● 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p>
<p>例如：</p>
<p>execution(public void com.itheima.aop.Target.method())<br>execution(void com.itheima.aop.Target.<em>(..))<br>execution(</em> com.itheima.aop.<em>.</em>(..))<br>execution(* com.itheima.aop..<em>.</em>(..))<br>execution(* <em>..</em>.*(..))<br>（2）通知的类型<br>通知的配置语法：</p>
<p>&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式”&gt;&lt;/aop:通知类型&gt;</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221306661.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>（3）切点表达式的抽取<br>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p>
<p><a href="aop:config">aop:config</a><br>    <!--引用myAspect的Bean为切面对象--><br>    &lt;aop:aspect ref=”myAspect”&gt;<br>        &lt;aop:pointcut id=”myPointcut” expression=”execution(* com.itheima.aop.*.*(..))”/&gt;<br>        &lt;aop:before method=”before” pointcut-ref=”myPointcut”&gt;</aop:before><br>    </aop:aspect></p>
<p></aop:config></p>
<h3 id="2-3-知识要点"><a href="#2-3-知识要点" class="headerlink" title="2.3 知识要点"></a>2.3 知识要点</h3><p>● aop 织入的配置</p>
<p><a href="aop:config">aop:config</a><br>    &lt;aop:aspect ref=“切面类”&gt;<br>        &lt;aop:before method=“通知方法名称” pointcut=“切点表达式”&gt;</aop:before><br>    </aop:aspect><br></aop:config><br>● 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知<br>● 切点表达式的写法：</p>
<p>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</p>
<h2 id="3-基于注解的-AOP-开发"><a href="#3-基于注解的-AOP-开发" class="headerlink" title="3.基于注解的 AOP 开发"></a>3.基于注解的 AOP 开发</h2><h3 id="3-1-快速入门"><a href="#3-1-快速入门" class="headerlink" title="3.1 快速入门"></a>3.1 快速入门</h3><p>基于注解的 aop 开发步骤：<br>① 创建目标接口和目标类（内部有切点）<br>② 创建切面类（内部有增强方法）<br>③ 将目标类和切面类的对象创建权交给 spring<br>④ 在切面类中使用注解配置织入关系<br>⑤ 在配置文件中开启组件扫描和 AOP 的自动代理<br>⑥ 测试</p>
<p>① 创建目标接口和目标类（内部有切点）</p>
<p>public interface TargetInterface {<br>    public void save();<br>}</p>
<p>public class Target implements TargetInterface {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>    }<br>}<br>② 创建切面类（内部有增强方法）</p>
<p>public class MyAspect {<br>    //前置增强方法<br>    public void before(){<br>        System.out.println(“前置增强……….”);<br>    }<br>}<br>③ 将目标类和切面类的对象创建权交给 spring</p>
<p>@Component(“target”)<br>public class Target implements TargetInterface {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>        //int i = 1/0;<br>    }<br>}</p>
<p>@Component(“myAspect”)<br>public class MyAspect {<br>    public void before(){<br>        System.out.println(“前置增强……….”);<br>    }<br>}</p>
<p>④ 在切面类中使用注解配置织入关系</p>
<p>@Component(“myAspect”)<br>@Aspect //标注当前MyAspect是一个切面类<br>public class MyAspect {<br>    //配置前置通知<br>    @Before(“execution(* com.itheima.anno.<em>.</em>(..))”)<br>    public void before(){<br>        System.out.println(“前置增强……….”);<br>    }<br>}</p>
<p>⑤ 在配置文件中开启组件扫描和 AOP 的自动代理</p>
<!--组件扫描-->
<p>&lt;context:component-scan base-package=”com.itheima.anno”&gt;</context:component-scan></p>
<!--aop自动代理-->
<p><a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a></aop:aspectj-autoproxy><br>⑥ 测试代码</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(“classpath:applicationContext-anno.xml”)<br>public class AnnoTest {<br>    @Autowired<br>    private TargetInterface target;</p>
<pre><code>@Test
public void test1()&#123;
     target.save();
&#125;
</code></pre>
<p>}<br>⑦ 测试结果</p>
<p>前置增强……….<br>save running…..</p>
<h3 id="3-2-注解配置-AOP-详解"><a href="#3-2-注解配置-AOP-详解" class="headerlink" title="3.2 注解配置 AOP 详解"></a>3.2 注解配置 AOP 详解</h3><p>（1）注解通知的类型<br>通知的配置语法：@通知注解 (“切点表达式”)</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221318308.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>（2） 切点表达式的抽取<br>同 xml 配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用 @Pointcut 注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p>
<p>@Component(“myAspect”)<br>@Aspect //标注当前MyAspect是一个切面类<br>public class MyAspect {<br>    //Proceeding JoinPoint:  正在执行的连接点===切点<br>    //@Around(“execution(* com.itheima.anno.<em>.</em>(..))”)<br>    @Around(“pointcut()”)<br>    public Object around(ProceedingJoinPoint pjp) throws Throwable {<br>        System.out.println(“环绕前增强….”);<br>        Object proceed = pjp.proceed();//切点方法<br>        System.out.println(“环绕后增强….”);<br>        return proceed;<br>    }<br>    //@After(“execution(* com.itheima.anno.<em>.</em>(..))”)<br>    @After(“MyAspect.pointcut()”)<br>    public void after(){<br>        System.out.println(“最终增强……….”);<br>    }</p>
<pre><code>//定义切点表达式
@Pointcut(&quot;execution(* com.itheima.anno.*.*(..))&quot;)
public void pointcut()&#123;&#125;
</code></pre>
<p>}</p>
<h3 id="3-3-知识要点"><a href="#3-3-知识要点" class="headerlink" title="3.3 知识要点"></a>3.3 知识要点</h3><p>● 注解 aop 开发步骤<br>① 使用 @Aspect 标注切面类<br>② 使用 @通知注解标注通知方法<br>③ 在配置文件中配置 aop 自动代理 <a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a></p>
<p>● 通知注解类型</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221320563.png" alt="在这里插入图片描述"></p>
<h1 id="第十章-声明式事务控制"><a href="#第十章-声明式事务控制" class="headerlink" title="第十章 声明式事务控制"></a>第十章 声明式事务控制</h1><h2 id="1-编程式事务控制相关对象"><a href="#1-编程式事务控制相关对象" class="headerlink" title="1.编程式事务控制相关对象"></a>1.编程式事务控制相关对象</h2><h3 id="1-1-PlatformTransactionManager"><a href="#1-1-PlatformTransactionManager" class="headerlink" title="1.1 PlatformTransactionManager"></a>1.1 PlatformTransactionManager</h3><p>PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221333535.png" alt="img"></p>
</blockquote>
<p>注意：<br>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是 jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager<br>Dao 层技术是 hibernate 时：org.springframework.orm.hibernate5.HibernateTransactionManager</p>
<h3 id="1-2-TransactionDefinition"><a href="#1-2-TransactionDefinition" class="headerlink" title="1.2 TransactionDefinition"></a>1.2 TransactionDefinition</h3><p>TransactionDefinition 是事务的定义信息对象，里面有如下方法：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221334387.png" alt="在这里插入图片描述"></p>
<p>（1）事务隔离级别</p>
<p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。<br>● ISOLATION_DEFAULT<br>● ISOLATION_READ_UNCOMMITTED<br>● ISOLATION_READ_COMMITTED<br>● ISOLATION_REPEATABLE_READ<br>● ISOLATION_SERIALIZABLE</p>
<p>（2）事务传播行为</p>
<p>● REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）<br>● SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）<br>● MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常<br>● REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。<br>● NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起<br>● NEVER：以非事务方式运行，如果当前存在事务，抛出异常<br>● NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作<br>● 超时时间：默认值是 - 1，没有超时限制。如果有，以秒为单位进行设置<br>● 是否只读：建议查询时设置为只读</p>
<h3 id="1-3-TransactionStatus"><a href="#1-3-TransactionStatus" class="headerlink" title="1.3 TransactionStatus"></a>1.3 TransactionStatus</h3><p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221335866.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-4-知识要点-1"><a href="#1-4-知识要点-1" class="headerlink" title="1.4 知识要点"></a>1.4 知识要点</h3><p>编程式事务控制三大对象<br>● PlatformTransactionManager<br>● TransactionDefinition<br>● TransactionStatus</p>
<p>平台对象操作事务行为，定义对象设置事务属性，状态对象反馈事务运行过程中的信息。换句话说，状态对象由管理器和事务信息共同决定的。</p>
<h2 id="2-基于-XML-的声明式事务控制"><a href="#2-基于-XML-的声明式事务控制" class="headerlink" title="2.基于 XML 的声明式事务控制"></a>2.基于 XML 的声明式事务控制</h2><h3 id="2-1-什么是声明式事务控制"><a href="#2-1-什么是声明式事务控制" class="headerlink" title="2.1 什么是声明式事务控制"></a>2.1 什么是声明式事务控制</h3><p>Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p>
<p>声明式事务处理的作用<br>● 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可<br>● 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p>
<p>注意：Spring 声明式事务控制底层就是 AOP。业务对象是切点，事务管理是增强 (切面)。</p>
<h3 id="2-2-声明式事务控制的实现"><a href="#2-2-声明式事务控制的实现" class="headerlink" title="2.2 声明式事务控制的实现"></a>2.2 声明式事务控制的实现</h3><p>声明式事务控制明确事项：<br>● 谁是切点？<br>● 谁是通知？<br>● 配置切面？</p>
<p>① 引入 tx 命名空间</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
"><br>② 配置事务增强</p>
<!--配置平台事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <!--配置数据源-->
    <property name="dataSource" ref="dataSource"></property>
</bean>

<!--通知  事务的增强-->
<p>&lt;tx:advice id=”txAdvice” transaction-manager=”transactionManager”&gt;<br>    <!--设置事务的属性信息--><br>    <a href="tx:attributes">tx:attributes</a><br>        &lt;tx:method name=”transfer” isolation=”REPEATABLE_READ” propagation=”REQUIRED” read-only=”false”/&gt;<br>        &lt;tx:method name=”save” isolation=”REPEATABLE_READ” propagation=”REQUIRED” read-only=”false”/&gt;<br>        &lt;tx:method name=”findAll” isolation=”REPEATABLE_READ” propagation=”REQUIRED” read-only=”true”/&gt;<br>        <!--代表update开头的所有方法--><br>        &lt;tx:method name=”update*” isolation=”REPEATABLE_READ” propagation=”REQUIRED” read-only=”true”/&gt;<br>        &lt;tx:method name=”*”/&gt;<br>    </tx:attributes><br></tx:advice><br>③ 配置事务 AOP 织入</p>
<!--配置事务的aop织入-->
<p><a href="aop:config">aop:config</a><br>    &lt;aop:advisor advice-ref=”txAdvice” pointcut=”execution(* com.itheima.service.impl.*.*(..))”&gt;                 </aop:advisor><br></aop:config><br>④ 测试事务控制转账业务代码</p>
<p>@Override<br>public void transfer(String outMan, String inMan, double money) {<br>    accountDao.out(outMan,money);<br>    int i = 1/0;<br>    accountDao.in(inMan,money);<br>}</p>
<h3 id="2-3-切点方法的事务参数的配置"><a href="#2-3-切点方法的事务参数的配置" class="headerlink" title="2.3 切点方法的事务参数的配置"></a>2.3 切点方法的事务参数的配置</h3><!--事务增强配置-->
<p>&lt;tx:advice id=”txAdvice” transaction-manager=”transactionManager”&gt;<br>    <a href="tx:attributes">tx:attributes</a><br>        &lt;tx:method name=”*”/&gt;<br>    </tx:attributes><br></tx:advice><br>其中，<a href="tx:method">tx:method</a> 代表切点方法的事务参数的配置，例如：</p>
<p>&lt;tx:method name=”transfer” isolation=”REPEATABLE_READ” propagation=”REQUIRED” timeout=”-1” read-only=”false”/&gt;<br>● name：切点方法名称<br>● isolation: 事务的隔离级别<br>● propogation：事务的传播行为<br>● timeout：超时时间<br>● read-only：是否只读</p>
<h3 id="2-4-知识要点-1"><a href="#2-4-知识要点-1" class="headerlink" title="2.4 知识要点"></a>2.4 知识要点</h3><p>声明式事务控制的配置要点<br>● 平台事务管理器配置<br>● 事务通知的配置<br>● 事务 aop 织入的配置</p>
<h2 id="3-基于注解的声明式事务控制"><a href="#3-基于注解的声明式事务控制" class="headerlink" title="3.基于注解的声明式事务控制"></a>3.基于注解的声明式事务控制</h2><h3 id="3-1-使用注解配置声明式事务控制"><a href="#3-1-使用注解配置声明式事务控制" class="headerlink" title="3.1 使用注解配置声明式事务控制"></a>3.1 使用注解配置声明式事务控制</h3><p>（1）编写 AccoutDao</p>
<p>@Repository(“accountDao”)<br>public class AccountDaoImpl implements AccountDao {<br>    @Autowired<br>    private JdbcTemplate jdbcTemplate;<br>    public void out(String outMan, double money) {<br>        jdbcTemplate.update(“update account set money=money-? where name=?”,money,outMan);<br>    }<br>    public void in(String inMan, double money) {<br>        jdbcTemplate.update(“update account set money=money+? where name=?”,money,inMan);<br>    }<br>}<br>（2） 编写 AccoutService</p>
<p>@Repository<br>@Transactional//这里没有写参数，代表采用默认配置；这里声明事务，代表这个类的所有方法都会开启事务<br>public class AccountServiceImpl implements AccountService {<br>    @Autowired<br>    private AccountDao accountDao;<br>    @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)//这里又定义了事务，则此方法以这个事务定义为准<br>    public void transfer(String outMan, String inMan, double money) {<br>        accountDao.out(outMan, money);<br>        //int i = 1 / 0;<br>        accountDao.in(inMan, money);<br>    }<br>}<br>（3）编写 applicationContext.xml 配置文件</p>
<!--之前省略datsSource、jdbcTemplate、平台事务管理器的配置-->
<!--组件扫描-->
<p>&lt;context:component-scan base-package=”com.itheima”&gt;</context:component-scan></p>
<!--事务的注解驱动-->
<p>&lt;tx:annotation-driven transaction-manager=”transactionManager”&gt;</tx:annotation-driven></p>
<h3 id="3-2-注解配置声明式事务控制解析"><a href="#3-2-注解配置声明式事务控制解析" class="headerlink" title="3.2 注解配置声明式事务控制解析"></a>3.2 注解配置声明式事务控制解析</h3><p>① 使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。<br>② 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。<br>③ 使用在方法上，不同的方法可以采用不同的事务参数配置。<br>④ Xml 配置文件中要开启事务的注解驱动 &lt;tx:annotation-driven /&gt;</p>
<h3 id="3-3-知识要点-1"><a href="#3-3-知识要点-1" class="headerlink" title="3.3 知识要点"></a>3.3 知识要点</h3><p>注解声明式事务控制的配置要点<br>● 平台事务管理器配置（xml 方式）<br>● 事务通知的配置（@Transactional 注解配置）<br>● 事务注解驱动的配置 <a href="tx:annotation-driven/">tx:annotation-driven/</a></p>
<h1 id="第十一章-MyBatis-入门操作"><a href="#第十一章-MyBatis-入门操作" class="headerlink" title="第十一章 MyBatis 入门操作"></a>第十一章 MyBatis 入门操作</h1><h2 id="1-Mybatis-简介"><a href="#1-Mybatis-简介" class="headerlink" title="1.Mybatis 简介"></a>1.Mybatis 简介</h2><h3 id="1-1-原始-jdbc-操作（查询数据）"><a href="#1-1-原始-jdbc-操作（查询数据）" class="headerlink" title="1.1 原始 jdbc 操作（查询数据）"></a>1.1 原始 jdbc 操作（查询数据）</h3><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221344619.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-原始-jdbc-操作（插入数据）"><a href="#1-1-原始-jdbc-操作（插入数据）" class="headerlink" title="1.1 原始 jdbc 操作（插入数据）"></a>1.1 原始 jdbc 操作（插入数据）</h3><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221345438.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-原始-jdbc-操作的分析"><a href="#1-2-原始-jdbc-操作的分析" class="headerlink" title="1.2 原始 jdbc 操作的分析"></a>1.2 原始 jdbc 操作的分析</h3><p>原始 jdbc 开发存在的问题如下：<br>① 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能<br>② sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。<br>③ 查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到 sql 语句的占位符位置</p>
<p>应对上述问题给出的解决方案：<br>① 使用数据库连接池初始化连接资源<br>② 将 sql 语句抽取到 xml 配置文件中<br>③ 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p>
<h3 id="1-3-什么是-Mybatis"><a href="#1-3-什么是-Mybatis" class="headerlink" title="1.3 什么是 Mybatis"></a>1.3 什么是 Mybatis</h3><p>● mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。<br>● mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句。<br>● 最后 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</p>
<h2 id="2-Mybatis-的快速入门"><a href="#2-Mybatis-的快速入门" class="headerlink" title="2.Mybatis 的快速入门"></a>2.Mybatis 的快速入门</h2><h3 id="2-1-MyBatis-开发步骤"><a href="#2-1-MyBatis-开发步骤" class="headerlink" title="2.1 MyBatis 开发步骤"></a>2.1 MyBatis 开发步骤</h3><p>① 添加 MyBatis 的坐标<br>② 创建 user 数据表<br>③ 编写 User 实体类<br>④ 编写映射文件 UserMapper.xml<br>⑤ 编写核心文件 SqlMapConfig.xml<br>⑥ 编写测试类</p>
<h3 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h3><p>（1）导入 MyBatis 的坐标和其他相关坐标</p>
<!--mybatis坐标-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.32</version>
</dependency>
<!--mysql驱动坐标-->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.4.6</version>
</dependency>
<!--单元测试坐标-->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
</dependency>
<!--日志坐标-->
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
（2）创建 user 数据表

<p>（3）编写 User 实体</p>
<p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;<br>    //省略get和set方法<br>}<br>（4）编写 UserMapper 映射文件</p>
<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="userMapper">
    <select id="findAll" resultType="com.itheima.domain.User">
        select * from user
    </select>
</mapper>
（5）编写 MyBatis 核心文件

<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>


<pre><code>&lt;!--数据源环境--&gt;
&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;


&lt;!--加载映射文件--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt;
&lt;/mappers&gt;
</code></pre>
</configuration>

<h3 id="2-3-编写测试代码"><a href="#2-3-编写测试代码" class="headerlink" title="2.3 编写测试代码"></a>2.3 编写测试代码</h3><p>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>//获得session回话对象<br>SqlSession sqlSession = sqlSessionFactory.openSession();<br>//执行操作  参数：namespace+id<br>List<User> userList = sqlSession.selectList(“userMapper.findAll”);<br>//打印数据<br>System.out.println(userList);<br>//释放资源<br>sqlSession.close();</p>
<h3 id="2-4-知识小结"><a href="#2-4-知识小结" class="headerlink" title="2.4 知识小结"></a>2.4 知识小结</h3><p>MyBatis 开发步骤：<br>① 添加 MyBatis 的坐标<br>② 创建 user 数据表<br>③ 编写 User 实体类<br>④ 编写映射文件 UserMapper.xml<br>⑤ 编写核心文件 SqlMapConfig.xml<br>⑥ 编写测试类</p>
<h2 id="3-MyBatis-的映射文件概述"><a href="#3-MyBatis-的映射文件概述" class="headerlink" title="3.MyBatis 的映射文件概述"></a>3.MyBatis 的映射文件概述</h2><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221401630.png" alt="在这里插入图片描述"></p>
<h2 id="4-MyBatis-的增删改查操作"><a href="#4-MyBatis-的增删改查操作" class="headerlink" title="4.MyBatis 的增删改查操作"></a>4.MyBatis 的增删改查操作</h2><h3 id="4-1-MyBatis-的插入数据操作"><a href="#4-1-MyBatis-的插入数据操作" class="headerlink" title="4.1 MyBatis 的插入数据操作"></a>4.1 MyBatis 的插入数据操作</h3><p>（1）编写 UserMapper 映射文件</p>
<!--插入操作-->
<insert id="save" parameterType="com.itheima.domain.User">
    insert into user values(#{id},#{username},#{password})
</insert>
（2）编写插入实体 User 的代码

<p>//模拟user对象<br>User user = new User();<br>user.setUsername(“xxx”);<br>user.setPassword(“abc”);<br>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>//获得session回话对象<br>SqlSession sqlSession = sqlSessionFactory.openSession();<br>//执行操作  参数：namespace+id<br>sqlSession.insert(“userMapper.save”,user);<br>//mybatis执行更新操作  提交事务<br>sqlSession.commit();<br>//释放资源<br>sqlSession.close();<br>（3）插入操作注意问题<br>● 插入语句使用 insert 标签<br>● 在映射文件中使用 parameterType 属性指定要插入的数据类型<br>● Sql 语句中使用 #{实体属性名} 方式引用实体中的属性值<br>● 插入操作使用的 API 是 sqlSession.insert (“命名空间.id”, 实体对象);<br>● 插入操作涉及数据库数据变化，所以要使用 sqlSession 对象显示的提交事务，即 sqlSession.commit ()</p>
<h3 id="4-2-MyBatis-的修改数据操作"><a href="#4-2-MyBatis-的修改数据操作" class="headerlink" title="4.2 MyBatis 的修改数据操作"></a>4.2 MyBatis 的修改数据操作</h3><p>（1）编写 UserMapper 映射文件</p>
<!--修改操作-->
<update id="update" parameterType="com.itheima.domain.User">
    update user set username=#{username},password=#{password} where id=#{id}
</update>
（2）编写修改实体 User 的代码

<p>//模拟user对象<br>User user = new User();<br>user.setId(0);<br>user.setUsername(“lucy”);<br>user.setPassword(“123”);<br>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>//获得session回话对象<br>SqlSession sqlSession = sqlSessionFactory.openSession();<br>//执行操作  参数：namespace+id<br>sqlSession.update(“userMapper.update”, user);<br>//mybatis执行更新操作  提交事务<br>sqlSession.commit();<br>//释放资源<br>sqlSession.close();<br>（3）修改操作注意问题<br>● 修改语句使用 update 标签<br>● 修改操作使用的 API 是 sqlSession.update (“命名空间.id”, 实体对象);</p>
<h3 id="4-3-MyBatis-的删除数据操作"><a href="#4-3-MyBatis-的删除数据操作" class="headerlink" title="4.3 MyBatis 的删除数据操作"></a>4.3 MyBatis 的删除数据操作</h3><p>（1）编写 UserMapper 映射文件</p>
<!--删除操作-->
<delete id="delete" parameterType="java.lang.Integer">
    delete  from user where id=#{id}
</delete>
（2）编写删除数据的代码

<p>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>//获得session回话对象<br>SqlSession sqlSession = sqlSessionFactory.openSession();<br>//执行操作  参数：namespace+id<br>sqlSession.delete(“userMapper.delete”, 0);<br>//mybatis执行更新操作  提交事务<br>sqlSession.commit();<br>//释放资源<br>sqlSession.close();<br>（3）删除操作注意问题<br>● 删除语句使用 delete 标签<br>● Sql 语句中使用 #{任意字符串} 方式引用传递的单个参数<br>● 删除操作使用的 API 是 sqlSession.delete (“命名空间.id”,Object);</p>
<h3 id="4-4-知识小结"><a href="#4-4-知识小结" class="headerlink" title="4.4 知识小结"></a>4.4 知识小结</h3><p>增删改查映射配置与 API：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221401412.png" alt="在这里插入图片描述"></p>
<h2 id="5-MyBatis-核心配置文件概述"><a href="#5-MyBatis-核心配置文件概述" class="headerlink" title="5.MyBatis 核心配置文件概述"></a>5.MyBatis 核心配置文件概述</h2><h3 id="5-1-MyBatis-核心配置文件层级关系"><a href="#5-1-MyBatis-核心配置文件层级关系" class="headerlink" title="5.1 MyBatis 核心配置文件层级关系"></a>5.1 MyBatis 核心配置文件层级关系</h3><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221406205.png" alt="在这里插入图片描述"></p>
<h3 id="5-2-MyBatis-常用配置解析"><a href="#5-2-MyBatis-常用配置解析" class="headerlink" title="5.2 MyBatis 常用配置解析"></a>5.2 MyBatis 常用配置解析</h3><p>（1）environments 标签<br>数据库环境的配置，支持多环境配置</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221406943.png" alt="在这里插入图片描述"></p>
<p>其中，事务管理器（transactionManager）类型有两种：</p>
<p>● JDBC：这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。<br>● MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p>
<p>其中，数据源（dataSource）类型有三种：</p>
<p>● UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。<br>● POOLED：这种数据源的实现利用 “池” 的概念将 JDBC 连接对象组织起来。<br>● JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
<p>（2）mapper 标签<br>该标签的作用是加载映射的，加载方式有如下几种：<br>● 使用相对于类路径的资源引用，例如：<br>● 使用完全限定资源定位符（URL），例如：<br>● 使用映射器接口实现类的完全限定类名，例如：<br>● 将包内的映射器接口实现全部注册为映射器，例如：</p>
<p>（3）Properties 标签<br>实际开发中，习惯将数据源的配置信息单独抽取成一个 properties 文件，该标签可以加载额外配置的 properties 文件</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221407868.png" alt="在这里插入图片描述"></p>
<p>（4） typeAliases 标签<br>类型别名是为 Java 类型设置一个短的名字。原来的类型名称配置如下</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221408809.png" alt="在这里插入图片描述"></p>
<p>上面我们是自定义的别名，mybatis 框架已经为我们设置好的一些常用的类型的别名：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221408900.png" alt="在这里插入图片描述"></p>
<h3 id="5-3-知识小结"><a href="#5-3-知识小结" class="headerlink" title="5.3 知识小结"></a>5.3 知识小结</h3><p>核心配置文件常用配置：<br>（1）properties 标签：该标签可以加载外部的 properties 文件</p>
<p><properties resource="jdbc.properties"></properties><br>（2）typeAliases 标签：设置类型别名</p>
<typeAliases>
    <typeAlias type="com.itheima.domain.User" alias="user"></typeAlias>
</typeAliases>
（3）mappers 标签：加载映射配置

<mappers>
    <mapper resource="com/itheima/mapper/UserMapper.xml"></mapper>
</mappers>
（4）environments 标签：数据源环境配置标签

<environments default="development">
    <environment id="development">
        <transactionManager type="JDBC"></transactionManager>
        <dataSource type="POOLED">
            <property name="driver" value="${jdbc.driver}"/>
            <property name="url" value="${jdbc. url}"/>
            <property name="username" value="${jdbc.username}"/>
            <property name="password" value="${jdbc.password}"/>
        </dataSource>
    </environment>
</environments>

<h2 id="6-MyBatis-相应-API"><a href="#6-MyBatis-相应-API" class="headerlink" title="6.MyBatis 相应 API"></a>6.MyBatis 相应 API</h2><h3 id="6-1-SqlSession-工厂构建器-SqlSessionFactoryBuilder"><a href="#6-1-SqlSession-工厂构建器-SqlSessionFactoryBuilder" class="headerlink" title="6.1 SqlSession 工厂构建器 SqlSessionFactoryBuilder"></a>6.1 SqlSession 工厂构建器 SqlSessionFactoryBuilder</h3><p>常用 API：SqlSessionFactory build (InputStream inputStream)<br>通过加载 mybatis 的核心文件的输入流的形式构建一个 SqlSessionFactory 对象</p>
<p>String resource = “org/mybatis/builder/mybatis-config.xml”;<br>InputStream inputStream = Resources.getResourceAsStream(resource);<br>SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();<br>SqlSessionFactory factory = builder.build(inputStream);<br>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p>
<h3 id="6-2-SqlSession-工厂对象-SqlSessionFactory"><a href="#6-2-SqlSession-工厂对象-SqlSessionFactory" class="headerlink" title="6.2 SqlSession 工厂对象 SqlSessionFactory"></a>6.2 SqlSession 工厂对象 SqlSessionFactory</h3><blockquote>
<p>SqlSessionFactory 有多个个方法创建 SqlSession 实例。常用的有如下两个：<img src="https://gitee.com/an-menghe/img/raw/master/test/202202221413472.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="6-3-SqlSession-会话对象"><a href="#6-3-SqlSession-会话对象" class="headerlink" title="6.3 SqlSession 会话对象"></a>6.3 SqlSession 会话对象</h3><p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。执行语句的方法主要有：</p>
<p><T> T selectOne(String statement, Object parameter)<br><E> List<E> selectList(String statement, Object parameter)<br>int insert(String statement, Object parameter)<br>int update(String statement, Object parameter)<br>int delete(String statement, Object parameter)<br>操作事务的方法主要有：</p>
<p>void commit()<br>void rollback()</p>
<h1 id="第十二章-MyBatis-的-Dao-层实现方式"><a href="#第十二章-MyBatis-的-Dao-层实现方式" class="headerlink" title="第十二章 MyBatis 的 Dao 层实现方式"></a>第十二章 MyBatis 的 Dao 层实现方式</h1><h2 id="1-Mybatis-的-Dao-层实现"><a href="#1-Mybatis-的-Dao-层实现" class="headerlink" title="1.Mybatis 的 Dao 层实现"></a>1.Mybatis 的 Dao 层实现</h2><h3 id="1-1-传统开发方式"><a href="#1-1-传统开发方式" class="headerlink" title="1.1 传统开发方式"></a>1.1 传统开发方式</h3><p>（1）编写 UserDao 接口</p>
<p>public interface UserMapper {<br>    public List<User> findAll() throws IOException;<br>}<br>（2）编写 UserDaoImpl 实现</p>
<p>public class UserMapperImpl implements UserMapper {<br>    public List<User> findAll() throws IOException {<br>        InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>        SqlSession sqlSession = sqlSessionFactory.openSession();<br>        List<User> userList = sqlSession.selectList(“userMapper.findAll”);<br>        return userList;<br>    }<br>}<br>（3）测试传统方式</p>
<p>@Test<br>public void testTraditionDao() throws IOException {<br>    UserMapper userMapper = new UserMapperImpl();<br>    List<User> all = userMapper.findAll();<br>    System.out.println(all);<br>}</p>
<h3 id="1-2-代理开发方式"><a href="#1-2-代理开发方式" class="headerlink" title="1.2 代理开发方式"></a>1.2 代理开发方式</h3><p>（1） 代理开发方式介绍</p>
<p>采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。<br>Mapper 接口开发方法只需要程序员编写 Mapper 接口（相当于 Dao 接口），由 Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边 Dao 接口实现类方法。</p>
<p>Mapper 接口开发需要遵循以下规范：<br>① Mapper.xml 文件中的 namespace 与 mapper 接口的全限定名相同<br>② Mapper 接口方法名和 Mapper.xml 中定义的每个 statement 的 id 相同<br>③ Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的类型相同<br>④ Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型相同</p>
<p>（2）编写 UserMapper 接口</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221416816.png" alt="在这里插入图片描述"></p>
<p>（3）测试代理方式</p>
<p>@Test<br>public void testProxyDao() throws IOException {<br>    InputStream resourceAsStream = Resources.getResourceAsStream(“SqlMapConfig.xml”);<br>    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>    SqlSession sqlSession = sqlSessionFactory.openSession();</p>
<pre><code>//获得MyBatis框架生成的UserMapper接口的实现类
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User user = userMapper.findById(1);
System.out.println(user);
sqlSession.close();
</code></pre>
<p>}</p>
<h3 id="1-3-知识小结"><a href="#1-3-知识小结" class="headerlink" title="1.3 知识小结"></a>1.3 知识小结</h3><p>MyBatis 的 Dao 层实现的两种方式：<br>● 手动对 Dao 进行实现：传统开发方式<br>● 代理方式对 Dao 进行实现：</p>
<p>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221416568.png" alt="在这里插入图片描述"></p>
<p>补充：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202161542612.png" alt="image-20220216154215517"></p>
<h1 id="第十三章-MyBatis-映射文件深入"><a href="#第十三章-MyBatis-映射文件深入" class="headerlink" title="第十三章 MyBatis 映射文件深入"></a>第十三章 MyBatis 映射文件深入</h1><h2 id="1-MyBatis-映射文件深入"><a href="#1-MyBatis-映射文件深入" class="headerlink" title="1.MyBatis 映射文件深入"></a>1.MyBatis 映射文件深入</h2><h3 id="1-1-动态-sql-语句"><a href="#1-1-动态-sql-语句" class="headerlink" title="1.1 动态 sql 语句"></a>1.1 动态 sql 语句</h3><p>（1）动态 sql 语句概述<br>Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL 是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。<br>参考的官方文档，描述如下：</p>
<p>（2）动态 SQL 之 <if><br>我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果 username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p>
<select id="findByCondition" parameterType="user" resultType="user">
    select * from user
    <where>
        <if test="id!=0">
            and id=#{id}
        </if>
        <if test="username!=null">
            and username = #{username}
        </if>
        <if test="password!=null">
            and password = #{password}
        </if>
    </where>
</select>
当查询条件 id 和 username 都存在时

<p>//获得MyBatis框架生成的UserMapper接口的实现类<br>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>User condition = new User();<br>condition.setId(1);<br>condition.setUsername(“lucy”);<br>User user = userMapper.findByCondition(condition);<br>控制台打印的 sql 语句如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221430775.png" alt="在这里插入图片描述"></p>
<p>当查询条件只有 id 存在时</p>
<p>//获得MyBatis框架生成的UserMapper接口的实现类<br>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>User condition = new User();<br>condition.setId(1);<br>User user = userMapper.findByCondition(condition);<br>控制台打印的 sql 语句如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221432454.png" alt="image-20220222143244390"></p>
<p>（3）动态 SQL 之 <foreach><br>循环执行 sql 的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。</p>
<select id="findByIds" parameterType="list" resultType="user">
    select * from user
    <where>
        <foreach collection="list" open="id in(" close=")" item="id" separator=",">
            #{id}
        </foreach>
    </where>
</select>
测试代码片段如下：

<p>//获得MyBatis框架生成的UserMapper接口的实现类<br>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>int[] ids = new int[]{2,5};<br>List<User> userList = userMapper.findByIds(ids);<br>System.out.println(userList);</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221434558.png" alt="在这里插入图片描述"></p>
<p>foreach 标签的属性含义如下：<br><foreach> 标签用于遍历集合，它的属性：<br>● collection：代表要遍历的集合元素，注意编写时不要写 #{}<br>● open：代表语句的开始部分<br>● close：代表结束部分<br>● item：代表遍历集合的每个元素，生成的变量名<br>● sperator：代表分隔符</p>
<h3 id="1-2-SQL-片段抽取"><a href="#1-2-SQL-片段抽取" class="headerlink" title="1.2 SQL 片段抽取"></a>1.2 SQL 片段抽取</h3><p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221435231.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-知识小结-1"><a href="#1-3-知识小结-1" class="headerlink" title="1.3 知识小结"></a>1.3 知识小结</h3><p>MyBatis 映射文件配置：</p>
<p><select>：查询<br><insert>：插入<br><update>：修改<br><delete>：删除<br><where>：where 条件<br><if>：if 判断<br><foreach>：循环<br><sql>：sql 片段抽取</p>
<h1 id="第十四章-MyBatis-核心配置文件深入"><a href="#第十四章-MyBatis-核心配置文件深入" class="headerlink" title="第十四章 MyBatis 核心配置文件深入"></a>第十四章 MyBatis 核心配置文件深入</h1><h2 id="1-MyBatis-核心配置文件深入"><a href="#1-MyBatis-核心配置文件深入" class="headerlink" title="1.MyBatis 核心配置文件深入"></a>1.MyBatis 核心配置文件深入</h2><h3 id="1-1-typeHandlers-标签"><a href="#1-1-typeHandlers-标签" class="headerlink" title="1.1 typeHandlers 标签"></a>1.1 typeHandlers 标签</h3><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221436396.png" alt="在这里插入图片描述"></p>
<p>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个 JDBC 类型。例如需求：一个 Java 中的 Date 数据类型，我想将之存到数据库的时候存成一个 1970 年至今的毫秒数，取出来时转换成 java 的 Date，即 java 的 Date 与数据库的 varchar 毫秒值之间转换。</p>
<p>开发步骤：</p>
<p>① 定义转换类继承类 BaseTypeHandler<br>② 覆盖 4 个未实现的方法，其中 setNonNullParameter 为 java 程序设置数据到数据库的回调方法，getNullableResult 为查询时 mysql 的字符串类型转换成 java 的 Type 类型的方法<br>③ 在 MyBatis 核心配置文件中进行注册<br>④ 测试转换是否正确</p>
<p>//想要自定义什么转换类型，对应 &lt;数据类型&gt; 尖括号内写对应数据类型<br>public class MyDateTypeHandler extends BaseTypeHandler<Date> {<br>    /*<br>     preparedStatement.setString（）转换成数据库的类型<br>     i===参数位置<br>     date===参数<br>    */<br>    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) {<br>        preparedStatement.setString(i, date.getTime() + “”);<br>    }<br>    //将数据库类型转为java类型<br>    public Date getNullableResult(ResultSet resultSet, String s) throws SQLException {<br>        return new Date(resultSet.getLong(s));<br>    }<br>    //将数据库类型转为java类型<br>    public Date getNullableResult(ResultSet resultSet, int i) throws SQLException {<br>        return new Date(resultSet.getLong(i));<br>    }<br>    //将数据库类型转为java类型<br>    public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException {<br>        return callableStatement.getDate(i);<br>    }<br>}</p>
<!--注册类型自定义转换器-->
<typeHandlers>
    <typeHandler handler="com.itheima.typeHandlers.MyDateTypeHandler"></typeHandler>
</typeHandlers>
测试添加操作：

<p>user.setBirthday(new Date());<br>userMapper.add2(user);<br>数据库数据：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221436451.png" alt="在这里插入图片描述"></p>
<p>测试查询操作：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221436751.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-plugins-标签"><a href="#1-2-plugins-标签" class="headerlink" title="1.2 plugins 标签"></a>1.2 plugins 标签</h3><p>分页助手 PageHelper</p>
<p>MyBatis 可以使用第三方的插件来对功能进行扩展，分页助手 PageHelper 是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据<br>开发步骤：<br>① 导入通用 PageHelper 的坐标<br>② 在 mybatis 核心配置文件中配置 PageHelper 插件<br>③ 测试分页数据获取</p>
<p>① 导入通用 PageHelper 坐标</p>
<!-- 分页助手 -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>3.7.5</version>
</dependency>
<dependency>
    <groupId>com.github.jsqlparser</groupId>
    <artifactId>jsqlparser</artifactId>
    <version>0.9.1</version>
</dependency>
② 在 mybatis 核心配置文件中配置 PageHelper 插件

<!-- 注意：分页助手的插件 配置在通用馆mapper之前 -->
<plugin interceptor="com.github.pagehelper.PageHelper">
    <!-- 指定方言 -->
    <property name="dialect" value="mysql"/>
</plugin>

<p>③ 测试分页代码实现</p>
<p>@Test<br>public void testPageHelper() {<br>    //设置分页参数(第几页，每页显示几条数据)<br>    PageHelper.startPage(1, 2);<br>    List<User> select = userMapper2.select(null);<br>    for (User user : select) {<br>        System.out.println(user);<br>    }<br>}<br>获得分页相关的其他参数</p>
<p>//其他分页的数据( &lt;泛型‘实体类’&gt;   ，new PageInfo<User>(查询的所有数据);)<br>PageInfo<User> pageInfo = new PageInfo<User>(select);<br>System.out.println(“总条数：” + pageInfo.getTotal());<br>System.out.println(“总页数：” + pageInfo.getPages());<br>System.out.println(“当前页：” + pageInfo.getPageNum());<br>System.out.println(“每页显示长度：” + pageInfo.getPageSize());<br>System.out.println(“是否第一页：” + pageInfo.isIsFirstPage());<br>System.out.println(“是否最后一页：” + pageInfo.isIsLastPage());</p>
<h3 id="1-3-知识小结-2"><a href="#1-3-知识小结-2" class="headerlink" title="1.3 知识小结"></a>1.3 知识小结</h3><p>MyBatis 核心配置文件常用标签：<br>（1）properties 标签：该标签可以加载外部的 properties 文件<br>（2）typeAliases 标签：设置类型别名<br>（3）environments 标签：数据源环境配置标签<br>（4）typeHandlers 标签：配置自定义类型处理器<br>（5）plugins 标签：配置 MyBatis 的插件</p>
<h1 id="第十五章-MyBatis-的多表操作"><a href="#第十五章-MyBatis-的多表操作" class="headerlink" title="第十五章 MyBatis 的多表操作"></a>第十五章 MyBatis 的多表操作</h1><h2 id="1-Mybatis-多表查询"><a href="#1-Mybatis-多表查询" class="headerlink" title="1.Mybatis 多表查询"></a>1.Mybatis 多表查询</h2><h3 id="1-1-一对一查询"><a href="#1-1-一对一查询" class="headerlink" title="1.1 一对一查询"></a>1.1 一对一查询</h3><p>（1）一对一查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221455574.png" alt="在这里插入图片描述"></p>
<p>（2）一对一查询的语句<br>对应的 sql 语句：select *,o.id oid from orders o,user u where o.uid=u.id;<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221455398.png" alt="在这里插入图片描述"></p>
<p>（3）创建 Order 和 User 实体</p>
<p>public class Order {<br>    private int id;<br>    private Date ordertime;<br>    private double total;<br>    //当前订单属于哪一个用户<br>    private User user;<br>}</p>
<p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;<br>    private Date birthday;<br>}<br>（4）创建 OrderMapper 接口</p>
<p>public interface OrderMapper {<br>    //查询全部的方法<br>    public List<Order> findAll();</p>
<p>}<br>（5）配置 OrderMapper.xml</p>
<mapper namespace="com.itheima.mapper.OrderMapper">
    <resultMap id="orderMap" type="order">
        <!--手动指定字段与实体属性的映射关系
            column: 数据表的字段名称
            property：实体的属性名称-->
        <id column="oid" property="id"></id>
        <result column="ordertime" property="ordertime"></result>
        <result column="total" property="total"></result>
        <result column="uid" property="user.id"></result>
        <result column="username" property="user.username"></result>
        <result column="password" property="user.password"></result>
        <result column="birthday" property="user.birthday"></result>
    </resultMap>
    <select id="findAll" resultMap="orderMap">
         select *,o.id oid from orders o,user u where o.uid=u.id;
    </select>
</mapper>
其中还可以配置如下：

<mapper namespace="com.itheima.mapper.OrderMapper">
    <resultMap id="orderMap" type="order">
        <!--手动指定字段与实体属性的映射关系
            column: 数据表的字段名称
            property：实体的属性名称-->
        <id column="oid" property="id"></id>
        <result column="ordertime" property="ordertime"></result>
        <result column="total" property="total"></result>
        <!--实体类映射-->
        <association property="user" javaType="user">
            <id column="uid" property="id"></id>
            <result column="username" property="username"></result>
            <result column="password" property="password"></result>
            <result column="birthday" property="birthday"></result>
        </association>
    </resultMap>
    <select id="findAll" resultMap="orderMap">
         select *,o.id oid from orders o,user u where o.uid=u.id;
    </select>
</mapper>
（6）测试结果

<p>OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);<br>List<Order> all = mapper.findAll();<br>for(Order order : all){<br>    System.out.println(order);<br>}</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221456182.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-一对多查询"><a href="#1-2-一对多查询" class="headerlink" title="1.2 一对多查询"></a>1.2 一对多查询</h3><p>（1）一对多查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221456243.png" alt="在这里插入图片描述"></p>
<p>（2） 一对多查询的语句<br>对应的 sql 语句：select *,o.id oid from user u left join orders o on u.id=o.uid;<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221456048.png" alt="在这里插入图片描述"></p>
<p>（3）修改 User 实体</p>
<p>//订单<br>public class Order {<br>    private int id;<br>    private Date ordertime;<br>    private double total;<br>    //当前订单属于哪一个用户<br>    private User user;<br>}</p>
<p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;<br>    private Date birthday;<br>    //描述的是当前用户存在哪些订单<br>    private List<Order> orderList;<br>}<br>（4）创建 UserMapper 接口</p>
<p>public interface UserMapper {<br>    public List<User> findAll();<br>}<br>（5）配置 UserMapper.xml</p>
<mapper namespace="com.itheima.mapper.UserMapper">
    <resultMap id="userMap" type="user">
        <id column="uid" property="id"></id>
        <result column="username" property="username"></result>
        <result column="password" property="password"></result>
        <result column="birthday" property="birthday"></result>
        <!--配置集合信息
            property:集合名称
            ofType：当前集合中的数据类型-->
        <collection property="orderList" ofType="order">
            <!--封装order的数据-->
            <id column="oid" property="id"></id>
            <result column="ordertime" property="ordertime"></result>
            <result column="total" property="total"></result>
        </collection>
    </resultMap>

<pre><code>&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
    SELECT *,o.id oid FROM USER u,orders o WHERE u.id=o.uid
&lt;/select&gt;
</code></pre>
</mapper>
（6）测试结果

<p>UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>List<User> all = mapper.findAll();<br>for(User user : all){<br>    System.out.println(user.getUsername());<br>    List<Order> orderList = user.getOrderList();<br>    for(Order order : orderList){<br>        System.out.println(order);<br>    }<br>    System.out.println(“———————————-“);<br>}</p>
<p><img src="https://img-blog.csdnimg.cn/158a7b176e6b4401a266650b2b2c5f8e.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-多对多查询"><a href="#1-3-多对多查询" class="headerlink" title="1.3 多对多查询"></a>1.3 多对多查询</h3><p>（1）多对多查询的模型<br>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用<br>多对多查询的需求：查询用户同时查询出该用户的所有角色</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221457100.png" alt="在这里插入图片描述"></p>
<p>（2）多对多查询的语句<br>对应的 sql 语句：SELECT * FROM USER u,sys_user_role ur,sys_role r WHERE u.id=ur.userId AND ur.roleId=r.id;<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221457654.png" alt="img"></p>
<p>（3）创建 Role 实体，修改 User 实体</p>
<p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;<br>    private Date birthday;<br>    //描述的是当前用户具备哪些角色<br>    private List<Role> roleList;<br>}<br>//角色<br>public class Role {<br>    private int id;<br>    private String roleName;<br>    private String roleDesc;<br>}<br>（4）添加 UserMapper 接口方法</p>
<p>public List<User> findUserAndRoleAll();<br>（5）配置 UserMapper.xml</p>
<resultMap id="userRoleMap" type="user">
    <!--user的信息-->
    <id column="userId" property="id"></id>
    <result column="username" property="username"></result>
    <result column="password" property="password"></result>
    <result column="birthday" property="birthday"></result>
    <!--user内部的roleList信息-->
    <collection property="roleList" ofType="role">
        <id column="roleId" property="id"></id>
        <result column="roleName" property="roleName"></result>
        <result column="roleDesc" property="roleDesc"></result>
    </collection>
</resultMap>

<select id="findUserAndRoleAll" resultMap="userRoleMap">
    SELECT * FROM USER u,sys_user_role ur,sys_role r WHERE u.id=ur.userId AND ur.roleId=r.id
</select>
（6）测试结果

<p>UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>List<User> all = mapper.findAllUserAndRole();<br>for(User user : all){<br>    System.out.println(user.getUsername());<br>    List<Role> roleList = user.getRoleList();<br>    for(Role role : roleList){<br>        System.out.println(role);<br>    }<br>    System.out.println(“———————————-“);<br>}</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221457773.png" alt="在这里插入图片描述"></p>
<h3 id="1-4-知识小结"><a href="#1-4-知识小结" class="headerlink" title="1.4 知识小结"></a>1.4 知识小结</h3><p>MyBatis 多表配置方式：<br>一对一配置：使用 <resultMap> 做配置<br>一对多配置：使用 <resultMap>+<collection> 做配置<br>多对多配置：使用 <resultMap>+<collection> 做配置</p>
<h1 id="第十六章-MyBatis-注解开发"><a href="#第十六章-MyBatis-注解开发" class="headerlink" title="第十六章 MyBatis 注解开发"></a>第十六章 MyBatis 注解开发</h1><h2 id="1-Mybatis-的注解开发"><a href="#1-Mybatis-的注解开发" class="headerlink" title="1.Mybatis 的注解开发"></a>1.Mybatis 的注解开发</h2><p>这几年来注解开发越来越流行，Mybatis 也可以使用注解开发方式，这样我们就可以减少编写 Mapper<br>映射文件了。我们先围绕一些基本的 CRUD 来学习，再学习复杂映射多表操作。</p>
<h3 id="1-1-注解"><a href="#1-1-注解" class="headerlink" title="1.1 注解"></a>1.1 注解</h3><p>@Insert：实现新增<br>@Update：实现更新<br>@Delete：实现删除<br>@Select：实现查询<br>@Result：实现结果集封装<br>@Results：可以与 @Result 一起使用，封装多个结果集<br>@One：实现一对一结果集封装<br>@Many：实现一对多结果集封装</p>
<h3 id="1-2-MyBatis-的增删改查"><a href="#1-2-MyBatis-的增删改查" class="headerlink" title="1.2 MyBatis 的增删改查"></a>1.2 MyBatis 的增删改查</h3><p>我们完成简单的 user 表的增删改查的操作</p>
<p>public class MyBatisTest {<br>    private UserMapper mapper;<br>    @Before<br>    public void before() throws IOException {<br>        InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>        SqlSession sqlSession = sqlSessionFactory.openSession(true);<br>        mapper = sqlSession.getMapper(UserMapper.class);<br>    }<br>    @Test<br>    public void testSave(){<br>        User user = new User();<br>        user.setUsername(“tom”);<br>        user.setPassword(“abc”);<br>        mapper.save(user);<br>    }<br>    @Test<br>    public void testUpdate(){<br>        User user = new User();<br>        user.setId(18);<br>        user.setUsername(“lucy”);<br>        user.setPassword(“123”);<br>        mapper.update(user);<br>    }<br>    @Test<br>    public void testDelete(){<br>        mapper.delete(18);<br>    }<br>    @Test<br>    public void testFindById(){<br>        User user = mapper.findById(2);<br>        System.out.println(user);<br>    }<br>    @Test<br>    public void testFindAll(){<br>        List<User> all = mapper.findAll();<br>        for (User user : all) {<br>            System.out.println(user);<br>        }<br>    }<br>}<br>修改 MyBatis 的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的 Mapper 接口即可</p>
<mappers>
    <!--扫描使用注解的类-->
    <mapper class="com.itheima.mapper.UserMapper"></mapper>
</mappers>
或者指定扫描包含映射关系的接口所在的包也可以

<!--加载映射关系-->
<mappers>
    <!--指定接口所在的包-->
    <package name="com.itheima.mapper"></package>
</mappers>
UserMapper 改为注解形式

<p>public interface UserMapper {<br>    @Insert(“insert into user values(#{id},#{username},#{password},#{birthday})”)<br>    public void save(User user);</p>
<pre><code>@Update(&quot;update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;&quot;)
public void update(User user);

@Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)
public void delete(int id);

@Select(&quot;select * from user where id=#&#123;id&#125;&quot;)
public User findById(int id);

@Select(&quot;select * from user&quot;)
public List&lt;User&gt; findAll();
</code></pre>
<p>}</p>
<h3 id="1-3-MyBatis-的注解实现复杂映射开发"><a href="#1-3-MyBatis-的注解实现复杂映射开发" class="headerlink" title="1.3 MyBatis 的注解实现复杂映射开发"></a>1.3 MyBatis 的注解实现复杂映射开发</h3><p>实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用 @Results 注解，@Result 注解，@One 注解，@Many 注解组合完成复杂关系的配置</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221515997.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221515980.png" alt="在这里插入图片描述"></p>
<h3 id="1-4-一对一查询"><a href="#1-4-一对一查询" class="headerlink" title="1.4 一对一查询"></a>1.4 一对一查询</h3><p>（1） 一对一查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221515122.png" alt="在这里插入图片描述"></p>
<p>（2）一对一查询的语句<br>第一种方式：<br>对应的 sql 语句：<br>select *,o.id oid from orders o,user u where o.uid=u.id<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221516576.png" alt="在这里插入图片描述"></p>
<p>第二种方式：<br>select * from orders;<br>select * from user where id=查询出订单的uid;</p>
<p>（3）创建 Order 和 User 实体</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221516079.png" alt="在这里插入图片描述"></p>
<p>（4）创建 OrderMapper 接口</p>
<p>public interface OrderMapper {<br>    public List<Order> findAll();<br>}<br>（5）使用注解配置 Mapper<br>第一种方式：</p>
<p>public interface OrderMapper {<br>    @Select(“select *,o.id oid from orders o,user u where o.uid=u.id”)<br>    @Results({<br>            @Result(column = “oid”,property = “id”),<br>            @Result(column = “ordertime”,property = “ordertime”),<br>            @Result(column = “total”,property = “total”),<br>            @Result(column = “uid”,property = “user.id”),<br>            @Result(column = “username”,property = “user.username”),<br>            @Result(column = “password”,property = “user.password”)<br>    })<br>    public List<Order> findAll();<br>}</p>
<p>public interface UserMapper {<br>    @Select(“select * from user”)<br>    public List<User> findAll();<br>}<br>第二种方式：</p>
<p>public interface OrderMapper {<br>    @Select(“select * from orders”)<br>    @Results({<br>            @Result(column = “id”,property = “id”),<br>            @Result(column = “ordertime”,property = “ordertime”),<br>            @Result(column = “total”,property = “total”),<br>            @Result(<br>                    property = “user”, //要封装的属性名称<br>                    column = “uid”, //根据那个字段去查询user表的数据<br>                    javaType = User.class, //要封装的实体类型<br>                    //select属性 代表查询那个接口的方法获得数据<br>                    one = @One(select = “com.itheima.mapper.UserMapper.findById”)<br>            )<br>    })<br>    public List<Order> findAll();<br>}<br>public interface UserMapper {<br>    @Select(“select * from user where id=#{id}”)<br>    public User findById(int id);<br>}<br>（6）测试结果</p>
<p>@Test<br>public void testSelectOrderAndUser() {<br>    List<Order> all = orderMapper.findAll();<br>    for(Order order : all){<br>        System.out.println(order);<br>    }<br>}</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221516804.png" alt="在这里插入图片描述"></p>
<h3 id="1-5-一对多查询"><a href="#1-5-一对多查询" class="headerlink" title="1.5 一对多查询"></a>1.5 一对多查询</h3><p>（1）一对多查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221517018.png" alt="在这里插入图片描述"></p>
<p>（2）一对多查询的语句<br>对应的 sql 语句：<br>select * from user;<br>select * from orders where uid=查询出用户的id;<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221517663.png" alt="在这里插入图片描述"></p>
<p>（3）修改 User 实体</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221517975.png" alt="在这里插入图片描述"></p>
<p>（4）创建 UserMapper 接口</p>
<p>public List<User> findUserAndOrderAll();<br>（5）使用注解配置 Mapper</p>
<p>public interface UserMapper {<br>    @Select(“select * from user”)<br>    @Results({<br>            @Result(id=true ,column = “id”,property = “id”),<br>            @Result(column = “username”,property = “username”),<br>            @Result(column = “password”,property = “password”),<br>            @Result(<br>                    property = “orderList”,<br>                    column = “id”,<br>                    javaType = List.class,<br>                    many = @Many(select = “com.itheima.mapper.OrderMapper.findByUid”)<br>            )<br>    })<br>    public List<User> findUserAndOrderAll();<br>}<br>public interface OrderMapper {<br>    @Select(“select * from orders where uid=#{uid}”)<br>    public List<Order> findByUid(int uid);<br>}<br>（6）测试结果</p>
<p>List<User> all = userMapper.findAllUserAndOrder();<br>for(User user : all){<br>    System.out.println(user.getUsername());<br>    List<Order> orderList = user.getOrderList();<br>    for(Order order : orderList){<br>        System.out.println(order);<br>    }<br>    System.out.println(“—————————–”);<br>}</p>
<h3 id="1-6-多对多查询"><a href="#1-6-多对多查询" class="headerlink" title="1.6 多对多查询"></a>1.6 多对多查询</h3><p>（1）多对多查询的模型<br>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用<br>多对多查询的需求：查询用户同时查询出该用户的所有角色</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221518453.png" alt="img"></p>
<p>（2）多对多查询的语句<br>对应的 sql 语句：<br>select * from user;<br>select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=用户的id<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221518922.png" alt="在这里插入图片描述"></p>
<p>（3）创建 Role 实体，修改 User 实体</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221519115.png" alt="在这里插入图片描述"></p>
<p>（4）添加 UserMapper 接口方法</p>
<p>public List<User> findUserAndRoleAll();<br>（5）使用注解配置 Mapper</p>
<p>public interface UserMapper {<br>    @Select(“SELECT * FROM USER”)<br>    @Results({<br>            @Result(id = true,column = “id”,property = “id”),<br>            @Result(column = “username”,property = “username”),<br>            @Result(column = “password”,property = “password”),<br>            @Result(<br>                    property = “roleList”,<br>                    column = “id”,<br>                    javaType = List.class,<br>                    many = @Many(select = “com.itheima.mapper.RoleMapper.findByUid”)<br>            )<br>    })<br>    public List<User> findUserAndRoleAll();<br>}<br>public interface RoleMapper {<br>    @Select(“SELECT * FROM sys_user_role ur,sys_role r WHERE ur.roleId=r.id AND ur.userId=#{uid}”)<br>    public List<Role> findByUid(int uid);<br>}<br>（6）测试结果</p>
<p>UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>List<User> all = mapper.findAllUserAndRole();<br>for(User user : all){<br>    System.out.println(user.getUsername());<br>    List<Role> roleList = user.getRoleList();<br>    for(Role role : roleList){<br>        System.out.println(role);<br>    }<br>    System.out.println(“———————————-“);<br>}</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221519937.png" alt="在这里插入图片描述"></p>
<h1 id="第十七章-SSM-整合"><a href="#第十七章-SSM-整合" class="headerlink" title="第十七章 SSM 整合"></a>第十七章 SSM 整合</h1><h2 id="1-SSM-框架整合"><a href="#1-SSM-框架整合" class="headerlink" title="1.SSM 框架整合"></a>1.SSM 框架整合</h2><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>（1）原始方式整合</p>
<p>create table account(<br>    id int primary key auto_increment,<br>    name varchar(100),<br>    money double(7,2)<br>);</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221609652.png" alt="在这里插入图片描述"></p>
<p>（2）创建 Maven 工程</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221610296.png" alt="在这里插入图片描述"></p>
<p>（3）导入 Maven 坐标</p>
<blockquote>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code><br><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</code><br>  <code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code></p>
<p>  <code>&lt;groupId&gt;com.itheima&lt;/groupId&gt;</code><br>  <code>&lt;artifactId&gt;itheima_ssm&lt;/artifactId&gt;</code><br>  <code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code><br>  <code>&lt;packaging&gt;war&lt;/packaging&gt;</code></p>
<p>  <code>&lt;name&gt;itheima_ssm Maven Webapp&lt;/name&gt;</code><br>  <code>&lt;!-- FIXME change it to the project&#39;s website --&gt;</code><br>  <code>&lt;url&gt;http://www.example.com&lt;/url&gt;</code></p>
<p>  <code>&lt;properties&gt;</code><br>    <code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</code><br>    <code>&lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</code><br>    <code>&lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</code><br>  <code>&lt;/properties&gt;</code></p>
<p>  <code>&lt;dependencies&gt;</code><br>    <code>&lt;!--spring相关--&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.aspectj&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;1.8.7&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-test&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--servlet和jsp--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--mybatis相关--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.9.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;jstl&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>  <code>&lt;/dependencies&gt;</code></p>
<p><code>&lt;/project&gt;</code><br>（4）编写实体类</p>
</blockquote>
<p>public class Account {<br>    private int id;<br>    private String name;<br>    private double money;<br>    //省略getter和setter方法<br>}<br>（5）编写 Mapper 接口</p>
<p>public interface AccountMapper {<br>    //保存账户数据<br>    void save(Account account);<br>    //查询账户数据<br>    List<Account> findAll();<br>}<br>（6）编写 Service 接口</p>
<p>public interface AccountService {<br>    void save(Account account); //保存账户数据<br>    List<Account> findAll(); //查询账户数据<br>}<br>（7）编写 Service 接口实现</p>
<p>@Service(“accountService”)<br>public class AccountServiceImpl implements AccountService {<br>    public void save(Account account) {<br>        SqlSession sqlSession = MyBatisUtils.openSession();<br>        AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class);<br>        accountMapper.save(account);<br>        sqlSession.commit();<br>        sqlSession.close();<br>    }<br>    public List<Account> findAll() {<br>        SqlSession sqlSession = MyBatisUtils.openSession();<br>        AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class);<br>        return accountMapper.findAll();<br>    }<br>}<br>（8）编写 Controller</p>
<p>@Controller<br>public class AccountController {<br>    @Autowired<br>    private AccountService accountService;<br>    @RequestMapping(“/save”)<br>    @ResponseBody<br>    public String save(Account account){<br>        accountService.save(account);<br>        return “save success”;<br>    }<br>    @RequestMapping(“/findAll”)<br>    public ModelAndView findAll(){<br>        ModelAndView modelAndView = new ModelAndView();<br>        modelAndView.setViewName(“accountList”);<br>        modelAndView.addObject(“accountList”,accountService.findAll());<br>        return modelAndView;<br>    }<br>}<br>（9）编写添加页面</p>
<p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p>
<html>

<head>
    <title>Title</title>
</head>

<body>
    <h1>保存账户信息表单</h1>
    <form action="${pageContext.request.contextPath}/save.action" method="post">
        用户名称<input type="text" name="name"><br/>
        账户金额<input type="text" name="money"><br/>
        <input type="submit" value="保存"><br/>
    </form>
</body>
</html>
（10）编写列表页面

<table border="1">
    <tr>
        <th>账户id</th>
        <th>账户名称</th>
        <th>账户金额</th>
    </tr>
    <c:forEach items="${accountList}" var="account">
        <tr>
            <td>${account.id}</td>
            <td>${account.name}</td>
            <td>${account.money}</td>
        </tr>
    </c:forEach>
</table>
（11）编写相应配置文件


<p>(12）测试添加账户</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221624284.png" alt="在这里插入图片描述"></p>
<p>（13）测试账户列表</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221624975.png" alt="在这里插入图片描述"></p>
<h2 id="2-Spring-整合-MyBatis"><a href="#2-Spring-整合-MyBatis" class="headerlink" title="2 Spring 整合 MyBatis"></a>2 Spring 整合 MyBatis</h2><p>（1）整合思路</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221625229.png" alt="在这里插入图片描述"></p>
<p>（2）将 SqlSessionFactory 配置到 Spring 容器中</p>
<!--加载jdbc.properties-->
<p>&lt;context:property-placeholder location=”classpath:jdbc.properties”/&gt;</p>
<!--配置数据源-->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}"/>
    <property name="jdbcUrl" value="${jdbc.url}"/>
    <property name="user" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
<!--配置MyBatis的SqlSessionFactory-->
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="configLocation" value="classpath:sqlMapConfig.xml"/>
</bean>
（3）扫描 Mapper，让 Spring 容器产生 Mapper 实现类

<!--配置Mapper扫描-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.itheima.mapper"/>
</bean>
（4）配置声明式事务控制

<!--配置声明式事务控制-->
<!--配置平台事务管理器-->
<bean id="transacionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!--通知  事务的增强-->
<p>&lt;tx:advice id=”txAdvice” transaction-manager=”transacionManager”&gt;<br>    <a href="tx:attributes">tx:attributes</a><br>        &lt;tx:method name=”*”/&gt;<br>    </tx:attributes><br></tx:advice></p>
<!--配置事务的aop织入-->
<p><a href="aop:config">aop:config</a><br>    &lt;aop:pointcut id=”txPointcut” expression=”execution(* com.itheima.service.impl.*.*(..))”/&gt;<br>    &lt;aop:advisor advice-ref=”txAdvice” pointcut-ref=”txPointcut”/&gt;<br></aop:config></p>
<p>（5）修改 Service 实现类代码</p>
<p>@Service(“accountService”)<br>public class AccountServiceImpl implements AccountService {<br>    @Autowired<br>    private AccountMapper accountMapper;<br>    public void save(Account account) {<br>        accountMapper.save(account);<br>    }<br>    public List<Account> findAll() {<br>        return accountMapper.findAll();<br>    }<br>}</p>
]]></content>
  </entry>
  <entry>
    <title>java数据结构</title>
    <url>/2022/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Java/</url>
    <content><![CDATA[<p>数据结构</p>
<span id="more"></span>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.sort;</span><br><span class="line"><span class="comment">//1.定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAge()-o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1,Comparable c2)完成测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComparable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个Student对象，并调用getMax方法，完成测试</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setUsername(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        s1.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s2.setUsername(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        s2.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">max</span> <span class="operator">=</span> getMax(s1, s2);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title function_">getMax</span><span class="params">(Comparable c1,Comparable c2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c1.compareTo(c2);</span><br><span class="line">        <span class="comment">//如果result&lt;0,则c1比c2小；</span></span><br><span class="line">        <span class="comment">//如果result&gt;0，则c1比c2大；</span></span><br><span class="line">        <span class="comment">//如果result==0,则c1和c2一样大；</span></span><br><span class="line">        <span class="keyword">if</span> (result&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> c1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       对数组a中的元素进行排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=a.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//&#123;6,5,4,3,2,1&#125;</span></span><br><span class="line">                <span class="comment">//比较索引j和索引j+1处的值</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较v元素是否大于w元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组元素i和j交换位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Bubble;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Bubble.sort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">//&#123;1,2,3,4,5,6&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       对数组a中的元素进行排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="comment">//需要比较最小索引minIndex处的值和j索引处的值；</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[minIndex],a[j]))&#123;</span><br><span class="line">                    minIndex=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换最小元素所在索引minIndex处的值和索引i处的值</span></span><br><span class="line">            exch(a,i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较v元素是否大于w元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组元素i和j交换位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Selection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//原始数据</span></span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Selection.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));<span class="comment">//&#123;1,2,4,5,7,8,9,10&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       对数组a中的元素进行排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="comment">//比较索引j处的值和索引j-1处的值，如果索引j-1处的值比索引j处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可；</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较v元素是否大于w元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组元素i和j交换位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Insertion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Insertion.sort(a);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(a));<span class="comment">//&#123;1,2,3,4,5,6,10,12&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       对数组a中的元素进行排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//1.根据数组a的长度，确定增长量h的初始值；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;a.length/<span class="number">2</span>)&#123;</span><br><span class="line">            h=<span class="number">2</span>*h+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.希尔排序</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            <span class="comment">//2.1.找到待插入的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=h;i&lt;a.length;i++)&#123;</span><br><span class="line">                <span class="comment">//2.2把待插入的元素插入到有序数列中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i;j&gt;=h;j-=h)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//待插入的元素是a[j],比较a[j]和a[j-h]</span></span><br><span class="line">                    <span class="keyword">if</span> (greater(a[j-h],a[j]))&#123;</span><br><span class="line">                        <span class="comment">//交换元素</span></span><br><span class="line">                        exch(a,j-h,j);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//待插入元素已经找到了合适的位置，结束循环；</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减小h的值</span></span><br><span class="line">            h= h/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较v元素是否大于w元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组元素i和j交换位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Shell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Shell.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));<span class="comment">//&#123;1,2,3,4,5,5,6,7,8,9&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔与插入的比较"><a href="#希尔与插入的比较" class="headerlink" title="希尔与插入的比较"></a>希尔与插入的比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Insertion;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Merge;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Shell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortCompare</span> &#123;</span><br><span class="line">    <span class="comment">//调用不同的测试方法，完成测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建一个ArrayList集合，保存读取出来的整数</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建缓存读取流BufferedReader，读取数据，并存储到ArrayList中；</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(SortCompare.class.getClassLoader().getResourceAsStream(<span class="string">&quot;reverse_arr.txt&quot;</span>)));</span><br><span class="line">        String line=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line=reader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//line是字符串，把line转换成Integer，存储到集合中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(line);</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reader.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.把ArrayList集合转换成数组</span></span><br><span class="line">        Integer[] a = <span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()];</span><br><span class="line">        list.toArray(a);</span><br><span class="line">        <span class="comment">//4.调用测试代码完成测试</span></span><br><span class="line">        <span class="comment">//testInsertion(a);//37499毫秒</span></span><br><span class="line">        testShell(a);<span class="comment">//30毫秒</span></span><br><span class="line"><span class="comment">//        testMerge(a);//70毫秒</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试希尔排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testShell</span><span class="params">(Integer[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取执行之前的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//2.执行算法代码</span></span><br><span class="line">        Shell.sort(a);</span><br><span class="line">        <span class="comment">//3.获取执行之后的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//4.算出程序执行的时间并输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;希尔排序执行的时间为：&quot;</span>+(end-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testInsertion</span><span class="params">(Integer[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取执行之前的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//2.执行算法代码</span></span><br><span class="line">        Insertion.sort(a);</span><br><span class="line">        <span class="comment">//3.获取执行之后的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//4.算出程序执行的时间并输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;插入排序执行的时间为：&quot;</span>+(end-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMerge</span><span class="params">(Integer[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取执行之前的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//2.执行算法代码</span></span><br><span class="line">        Merge.sort(a);</span><br><span class="line">        <span class="comment">//3.获取执行之后的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//4.算出程序执行的时间并输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;归并排序执行的时间为：&quot;</span>+(end-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line">    <span class="comment">//归并所需要的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] assist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       比较v元素是否小于w元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组元素i和j交换位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">           对数组a中的元素进行排序</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="comment">//1.初始化辅助数组assist；</span></span><br><span class="line">        assist = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">        <span class="comment">//2.定义一个lo变量，和hi变量，分别记录数组中最小的索引和最大的索引；</span></span><br><span class="line">        <span class="type">int</span> lo=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> hi=a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素的排序</span></span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对数组a中从lo到hi的元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">//做安全性校验；</span></span><br><span class="line">        <span class="keyword">if</span> (hi&lt;=lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对lo到hi之间的数据进行分为两个组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo+(hi-lo)/<span class="number">2</span>;<span class="comment">//   5,9  mid=7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别对每一组数据进行排序</span></span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再把两个组中的数据进行归并</span></span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">//定义三个指针</span></span><br><span class="line">        <span class="type">int</span> i=lo;</span><br><span class="line">        <span class="type">int</span> p1=lo;</span><br><span class="line">        <span class="type">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处</span></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=hi)&#123;</span><br><span class="line">            <span class="comment">//比较对应索引处的值</span></span><br><span class="line">            <span class="keyword">if</span> (less(a[p1],a[p2]))&#123;</span><br><span class="line">                assist[i++] = a[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                assist[i++]=a[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历，如果p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处</span></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid)&#123;</span><br><span class="line">            assist[i++]=a[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历，如果p2的指针没有走完，那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处</span></span><br><span class="line">        <span class="keyword">while</span>(p2&lt;=hi)&#123;</span><br><span class="line">            assist[i++]=a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把辅助数组中的元素拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> index=lo;index&lt;=hi;index++)&#123;</span><br><span class="line">            a[index]=assist[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Merge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        Merge.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));<span class="comment">//&#123;1,2,3,4,5,6,7,8&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      比较v元素是否小于w元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   数组元素i和j交换位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组a中从索引lo到索引hi之间的元素进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">//安全性校验</span></span><br><span class="line">        <span class="keyword">if</span> (hi&lt;=lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要对数组中lo索引到hi索引处的元素进行分组（左子组和右子组）；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(a, lo, hi);<span class="comment">//返回的是分组的分界值所在的索引，分界值位置变换后的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//让左子组有序</span></span><br><span class="line">        sort(a,lo,partition-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让右子组有序</span></span><br><span class="line">        sort(a,partition+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">       <span class="comment">//确定分界值</span></span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">key</span> <span class="operator">=</span> a[lo];</span><br><span class="line">        <span class="comment">//定义两个指针，分别指向待切分元素的最小索引处和最大索引处的下一个位置</span></span><br><span class="line">        <span class="type">int</span> left=lo;</span><br><span class="line">        <span class="type">int</span> right=hi+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止</span></span><br><span class="line">            <span class="keyword">while</span>(less(key,a[--right]))&#123;</span><br><span class="line">                <span class="keyword">if</span> (right==lo)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再从左往右扫描，移动left指针，找到一个比分界值大的元素，停止</span></span><br><span class="line">            <span class="keyword">while</span>(less(a[++left],key))&#123;</span><br><span class="line">                <span class="keyword">if</span> (left==hi)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断 left&gt;=right,如果是，则证明元素扫描完毕，结束循环，如果不是，则交换元素即可</span></span><br><span class="line">            <span class="keyword">if</span> (left&gt;=right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                exch(a,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换分界值</span></span><br><span class="line">        exch(a,lo,right);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.sort.Quick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a= &#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        Quick.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));<span class="comment">//&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><ul>
<li>头、尾节点，前、后驱元素</li>
</ul>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321151317902.png" alt="image-20220321151317902"></p>
</blockquote>
<ul>
<li><p>实现顺序表的遍历</p>
<blockquote>
<p>1.让SequenceList实现Iterable接口，重写iterator方法；</p>
<p>2.在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；</p>
</blockquote>
</li>
<li><p>顺序表增、删元素    时间复杂度    类比ArrayList的底层实现</p>
</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li><p>链表的结点API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321151935687.png" alt="image-20220321151935687"></p>
</blockquote>
</li>
<li><p>单向链表</p>
<blockquote>
<p>API设计</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321152024769.png" alt="image-20220321152024769"></p>
</blockquote>
</li>
<li><p>双向链表</p>
<blockquote>
<p>节点</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321152137588.png" alt="image-20220321152137588"></p>
</blockquote>
<blockquote>
<p>API设计</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321152214819.png" alt="image-20220321152214819"></p>
</blockquote>
</li>
<li><p>复杂度分析    类比LinkedList实现</p>
</li>
<li><p>单链表的反转</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321152327934.png" alt="image-20220321152327934"></p>
</blockquote>
</li>
<li><p>快慢指针  -&gt;找出链表中间值问题解决方案   判断单向链表是否有环问题 以及 有环列表入口节点问题</p>
</li>
<li><p>循环列表的实现        约瑟夫问题</p>
<blockquote>
<p>41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。 1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈； 2.自退出那个人开始的下一个人再次从1开始报数，以此类推； 3.求出最后退出的那个人的编号。</p>
</blockquote>
</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote>
<p>API设计</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321153039138.png" alt="image-20220321153039138"></p>
</blockquote>
<ul>
<li><p>案例：给定一个字符串，里边可能包含”()”小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现</p>
<blockquote>
<p>1.创建一个栈用来存储左括号 </p>
<p>2.从左往右遍历字符串，拿到每一个字符 </p>
<p>3.判断该字符是不是左括号，如果是，放入栈中存储 </p>
<p>4.判断该字符是不是右括号，如果不是，继续下一次循环</p>
<p> 5.如果该字符是右括号，则从栈中弹出一个元素t；</p>
<p> 6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号</p>
<p> 7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配</p>
</blockquote>
</li>
<li><p>什么是中缀表达式和后缀表达式    逆波兰表达式求值问题（给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果）</p>
<blockquote>
<p>1.创建一个栈对象oprands存储操作数 </p>
<p>2.从左往右遍历逆波兰表达式，得到每一个字符串</p>
<p> 3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中 </p>
<p>4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2 </p>
<p>5.使用该运算符计算o1和o2，得到结果result </p>
<p>6.把该结果压入oprands栈中 </p>
<p>7.遍历结束后，拿出栈中最终的结果返回</p>
</blockquote>
</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><blockquote>
<p>API设计</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321153914819.png" alt="image-20220321153914819"></p>
</blockquote>
<h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><blockquote>
<p>API设计</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321154115348.png" alt="image-20220321154115348"></p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321154132433.png" alt="image-20220321154132433"></p>
</blockquote>
<h3 id="有序符号表的实现"><a href="#有序符号表的实现" class="headerlink" title="有序符号表的实现"></a>有序符号表的实现</h3><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ul>
<li><p>树的特点   </p>
<blockquote>
<p> 1.每个结点有零个或多个子结点； 2.没有父结点的结点为根结点； 3.每一个非根结点只有一个父结点； 4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</p>
</blockquote>
</li>
<li><p>相关术语-&gt;结点的度-&gt;叶结点-&gt;分支结点-&gt;结点的层次-&gt;结点的层序编号-&gt;树的度-&gt;树的高度(深度）-&gt;森林-&gt;孩子结点-&gt;双亲结点(父结点)-&gt;兄弟结点</p>
</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li><p>满二叉树、完全二叉树</p>
</li>
<li><p>节点类API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321154733455.png" alt="image-20220321154733455"></p>
</blockquote>
</li>
<li><p>二叉查找树API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321154809871.png" alt="image-20220321154809871"></p>
</blockquote>
<blockquote>
<p>插入方法put实现思想： </p>
<p>1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用 </p>
<p>2.如果当前树不为空，则从根结点开始： </p>
<p>2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点； </p>
<p>2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点； </p>
<p>2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
</blockquote>
<blockquote>
<p>查询方法get实现思想： 从根节点开始： 1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点； 2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点； 3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
</blockquote>
<blockquote>
<p>删除方法delete实现思想： 1.找到被删除结点； 2.找到被删除结点右子树中的最小结点minNode 3.删除右子树中的最小结点 4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子 树 5.让被删除结点的父节点指向最小结点minNode</p>
</blockquote>
</li>
<li><p>查找二叉树中最小的键</p>
<blockquote>
<table>
<thead>
<tr>
<th>public Key min()</th>
<th>找出树中最小的键</th>
</tr>
</thead>
<tbody><tr>
<td>private Node min(Node x)</td>
<td>找出指定树x中，最小键所在的结点</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>查找二叉树中最大的键</p>
<blockquote>
<table>
<thead>
<tr>
<th>public Key max()</th>
<th>找出树中最大的键</th>
</tr>
</thead>
<tbody><tr>
<td>private Node max(Node x)</td>
<td>找出指定树x中，最大键所在的结点</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>前序遍历</p>
<blockquote>
<p>API：</p>
<p>public Queue preErgodic()：使用前序遍历，获取整个树中的所有键 </p>
<p>private void preErgodic(Node x,Queue keys)：使用前序遍历，把指定树x中的所有键放入到keys队列中</p>
</blockquote>
<blockquote>
<p>1.把当前结点的key放入到队列中; 2.找到当前结点的左子树，如果不为空，递归遍历左子树 3.找到当前结点的右子树，如果不为空，递归遍历右子树</p>
</blockquote>
</li>
<li><p>中序遍历 </p>
<blockquote>
<p>API：</p>
<p> public Queue midErgodic()：使用中序遍历，获取整个树中的所有键</p>
<p> private void midErgodic(Node x,Queue keys)：使用中序遍历，把指定树x中的所有键放入到keys队列中</p>
</blockquote>
<blockquote>
<p>1.找到当前结点的左子树，如果不为空，递归遍历左子树 2.把当前结点的key放入到队列中; 3.找到当前结点的右子树，如果不为空，递归遍历右子树</p>
</blockquote>
</li>
<li><p>后序遍历</p>
<blockquote>
<p>API： </p>
<p>public Queue afterErgodic()：使用后序遍历，获取整个树中的所有键 </p>
<p>private void afterErgodic(Node x,Queue keys)：使用后序遍历，把指定树x中的所有键放入到keys队列中</p>
</blockquote>
<blockquote>
<p>1.找到当前结点的左子树，如果不为空，递归遍历左子树 2.找到当前结点的右子树，如果不为空，递归遍历右子树 3.把当前结点的key放入到队列中</p>
</blockquote>
</li>
<li><p>层序遍历</p>
<blockquote>
<p>API:</p>
<p>public Queue layerErgodic()：使用层序遍历，获取整个树中的所有键</p>
</blockquote>
<blockquote>
<p>1.创建队列，存储每一层的结点； 2.使用循环从队列中弹出一个结点： 2.1获取当前结点的key； 2.2如果当前结点的左子结点不为空，则把左子结点放入到队列中 2.3如果当前结点的右子结点不为空，则把右子结点放入到队列中</p>
</blockquote>
</li>
<li><p>最大深度</p>
<blockquote>
<p>API</p>
<p>public int maxDepth()：计算整个树的最大深度 private int maxDepth(Node x):计算指定树x的最大深度</p>
</blockquote>
<blockquote>
<p>1.如果根结点为空，则最大深度为0； 2.计算左子树的最大深度； 3.计算右子树的最大深度； 4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</p>
</blockquote>
</li>
<li><p>案例：折纸问题</p>
</li>
</ul>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul>
<li><p>堆的实现</p>
<ul>
<li>insert插入方法</li>
<li>delMax方法</li>
</ul>
</li>
<li><p>API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321161805411.png" alt="image-20220321161805411"></p>
</blockquote>
</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li><p>String[] arr = {“S”,”O”,”R”,”T”,”E”,”X”,”A”,”M”,”P”,”L”,”E”} 请对数组中的字符按从小到大排序</p>
<blockquote>
<p>1.构造堆； 2.得到堆顶元素，这个值就是最大值； 3.交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置； 4.对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶； 5.重复2~4这个步骤，直到堆中剩一个元素为止。</p>
</blockquote>
</li>
<li><p>API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321162111732.png" alt="image-20220321162111732"></p>
</blockquote>
</li>
<li><p>堆构造及堆排序问题</p>
<blockquote>
<p> 另外再创建一个和新数组数组，然后从左往右遍历原数组，每得到一个元素后，添加 到新数组中，并通过上浮，对堆进行调整，最后新的数组就是一个堆。////创建一个新数组，把原数组 0<del>length-1的数据拷贝到新数组的1</del>length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后 对扫描到的每一个元素做下沉调整即可</p>
</blockquote>
<blockquote>
<p>1.将堆顶元素和堆中最后一个元素交换位置； 2.通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到 了数组的最右边) 3.重复1~2步骤，直到堆中剩最后一个元素。</p>
</blockquote>
</li>
</ul>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><h3 id="最大优先队列"><a href="#最大优先队列" class="headerlink" title="最大优先队列"></a>最大优先队列</h3><ul>
<li><p>API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321164014911.png" alt="image-20220321164014911"></p>
</blockquote>
</li>
</ul>
<h3 id="最小优先队列"><a href="#最小优先队列" class="headerlink" title="最小优先队列"></a>最小优先队列</h3><ul>
<li><p>最大堆和最小堆</p>
</li>
<li><p>API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321164156922.png" alt="image-20220321164156922"></p>
</blockquote>
</li>
</ul>
<h3 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h3><ul>
<li><p><strong>实现思路</strong></p>
</li>
<li><p>API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321164316565.png" alt="image-20220321164316565"></p>
</blockquote>
</li>
</ul>
<h1 id="树进阶"><a href="#树进阶" class="headerlink" title="树进阶"></a>树进阶</h1><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><ul>
<li><p>查找树定义、查找、<strong>插入</strong></p>
</li>
<li><p>红黑树的定义</p>
</li>
<li><p>结点API</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321170045246.png" alt="image-20220321170045246"></p>
</blockquote>
</li>
<li><p>平衡化之左旋、右旋</p>
<blockquote>
<p>左旋过程： 1.让x的左子结点变为h的右子结点：h.right=x.left; 2.让h成为x的左子结点：x.left=h; 3.让h的color属性变为x的color属性值：x.color=h.color; 4.让h的color属性变为RED：h.color=true;</p>
</blockquote>
<blockquote>
<p>右旋过程： 1. 让x的右子结点成为h的左子结点：h.left = x.right; 2. 让h成为x的右子结点：x.right=h; 3. 让x的color变为h的color属性值：x.color = h.color; 4. 让h的color为RED；</p>
</blockquote>
</li>
<li><p>红黑树API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321170452823.png" alt="image-20220321170452823"></p>
</blockquote>
</li>
<li></li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><ul>
<li>特性、数据的存储  在磁盘文件中的应用</li>
</ul>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><ul>
<li>与B数的差异、数据的存储  两个数的个子有点</li>
<li>在数据库中的应用<ul>
<li>未建立主键索引查询</li>
<li>建立主键索引查询</li>
<li>执行 select * from user where id&gt;=12 and id&lt;=18 ,如果有了索引，由于B+树的叶子结点形成了一个有序链表， 所以我们只需要找到id为12的叶子结点，按照遍历链表的方式顺序往后查即可，效率非常高。</li>
</ul>
</li>
</ul>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul>
<li><p>结构</p>
<blockquote>
<p>1.每个元素都唯一的对应一个结点； 2. 每一组数据中的多个元素都在同一颗树中； 3. 一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系； 4. 元素在树中并没有子父级关系的硬性要求；</p>
</blockquote>
</li>
<li><p>API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321171546067.png" alt="image-20220321171546067"></p>
</blockquote>
</li>
<li><p>实现步骤</p>
<ul>
<li><strong>UF(int N)构造方法实现</strong></li>
<li><strong>union(int p,int q)合并方法实现</strong></li>
</ul>
</li>
<li><p>应用场景</p>
</li>
<li><p>UF_Tree算法优化、优化后性能分析  API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321171739713.png" alt="image-20220321171739713"></p>
</blockquote>
</li>
<li><p>方法实现</p>
<ul>
<li>find(int p)方法实现</li>
<li>union(int p,int q)合并方法实现</li>
</ul>
</li>
<li><p>路径压缩    API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321172050767.png" alt="image-20220321172050767"></p>
</blockquote>
</li>
<li><p>案例 - 畅通工程</p>
<blockquote>
<p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目 标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问 最少还需要建设多少条道路？</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321172300948.png" alt="image-20220321172300948"></p>
</blockquote>
<blockquote>
<p>1.创建一个并查集UF_Tree_Weighted(20); 2.分别调用union(0,1),union(6,9),union(3,8),union(5,11),union(2,12),union(6,10),union(4,8)，表示已经修建好的 道路把对应的城市连接起来； 3.如果城市全部连接起来，那么并查集中剩余的分组数目为1，所有的城市都在一个树中，所以，只需要获取当前 并查集中剩余的数目，减去1，就是还需要修建的道路数目；</p>
</blockquote>
</li>
</ul>
<h1 id="图的入门"><a href="#图的入门" class="headerlink" title="图的入门"></a>图的入门</h1><ul>
<li>图的定义及分类  </li>
</ul>
<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><ul>
<li><p>  术语-&gt;相邻顶点-&gt;度-&gt;子图-&gt;路径-&gt;环-&gt;连通图-&gt;连通子图</p>
</li>
<li><p>存储结构、邻接矩阵、邻接表</p>
</li>
<li><p>有向图</p>
</li>
<li><p>图的实现 API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321172516022.png" alt="image-20220321172516022"></p>
</blockquote>
</li>
<li><p>深度优先搜索    API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321172606828.png" alt="image-20220321172606828"></p>
</blockquote>
</li>
<li><p>广度优先搜索    API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321172636939.png" alt="image-20220321172636939"></p>
</blockquote>
</li>
<li><p>案例 - 畅通工程续</p>
<blockquote>
<p>思路：</p>
<p>1.创建一个图Graph对象，表示城市； 2.分别调用 addEdge(0,1),addEdge(6,9),addEdge(3,8),addEdge(5,11),addEdge(2,12),addEdge(6,10),addEdge(4,8)，表示已 经修建好的道路把对应的城市连接起来； 3.通过Graph对象和顶点9，构建DepthFirstSearch对象或BreadthFirstSearch对象； 4.调用搜索对象的marked(10)方法和marked(8)方法，即可得到9和城市与10号城市以及9号城市与8号城市是否相通</p>
</blockquote>
</li>
<li><p>路径查找  API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321172807914.png" alt="image-20220321172807914"></p>
</blockquote>
</li>
</ul>
<h1 id="图的进阶"><a href="#图的进阶" class="headerlink" title="图的进阶"></a>图的进阶</h1><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><ul>
<li><p>定义 术语 -出度-&gt;入度-&gt;有向路径-&gt;有向环</p>
</li>
<li><p>一副有向图中两个顶点v和w存在的四种关系</p>
</li>
<li><p>API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321174506555.png" alt="image-20220321174506555"></p>
</blockquote>
</li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li><p>检测图中的有向环 API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321174625816.png" alt="image-20220321174625816"></p>
</blockquote>
<blockquote>
<p>在API中添加了onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时： </p>
<ol>
<li>在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈； </li>
<li>如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈； </li>
<li>如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环；</li>
</ol>
</blockquote>
</li>
<li><p>基于深度优先的顶点排序  API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321174814888.png" alt="image-20220321174814888"></p>
<p>如何实现</p>
</blockquote>
</li>
<li><p>拓扑排序实现    API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321174906699.png" alt="image-20220321174906699"></p>
</blockquote>
</li>
</ul>
<h3 id="加权无向图"><a href="#加权无向图" class="headerlink" title="加权无向图"></a>加权无向图</h3><ul>
<li><p>加权无向图的表示  API</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321174958670.png" alt="image-20220321174958670"></p>
</blockquote>
</li>
<li><p>加权无向图的实现  API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321175032730.png" alt="image-20220321175032730"></p>
</blockquote>
</li>
</ul>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul>
<li><p>定义、约定</p>
</li>
<li><p>树的性质、切分定理</p>
</li>
<li><p>贪心算法</p>
</li>
<li><p>Prim算法API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321175247222.png" alt="image-20220321175247222"></p>
<p>实现原理</p>
</blockquote>
</li>
<li><p>kruskal算法API设计        与Prim的区别</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321175404250.png" alt="image-20220321175404250"></p>
<p>实现原理</p>
</blockquote>
</li>
</ul>
<h3 id="加权有向图"><a href="#加权有向图" class="headerlink" title="加权有向图"></a>加权有向图</h3><ul>
<li><p>加权有向图的表示API</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321175533285.png" alt="image-20220321175533285"></p>
</blockquote>
</li>
<li><p>实现API</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321175607753.png" alt="image-20220321175607753"></p>
</blockquote>
</li>
</ul>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul>
<li><p>定义、性质</p>
</li>
<li><p>最短路径树API设计</p>
<blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220321175721111.png" alt="image-20220321175721111"></p>
</blockquote>
</li>
<li><p>松弛技术-&gt;边的松弛  顶点松弛</p>
</li>
<li><p>Dijstra算法的实现</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/04/17/%E8%AE%B0%E5%BD%95mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>安装bug心得</p>
<span id="more"></span>

<p>mysql误删了一个系统文件，之后卸载了文件，删了注册表（HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL 目录删除      2、HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL 目录删除 　　3、HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL），发现重新初始化就行，然而为时已晚</p>
<p>之后被无法关闭服务折磨，又发现sc query mysql 和 sc delete mysql命令，一直用错误的方式打开终端，应该在搜索里搜命令提示符，再右键以管理员身份运行。之后再按照教程安装。</p>
<p>hexo的安装，因为直接已经弄过github的ssh密钥，现在只用下载hexo，用脚手架初始化都不用（因为已经有了myblog里的一些文件），只需要在下载个hexo的git，就可以部署了。</p>
<p>还有node的安装，安装后现在的东西在C盘不要动</p>
<p>尤其cnpm的安装，注意教程。</p>
]]></content>
  </entry>
</search>
