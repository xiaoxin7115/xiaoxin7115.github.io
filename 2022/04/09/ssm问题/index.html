<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>ssm | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="xiaoxin">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.4.3',
    localsearch:{
      "enable": true,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'search.xml'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/css/main.min.css">
  
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/js/jquery.jside.menu.min.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 5.4.1"></head>
<body>
<div class="single">
<div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Search..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>

<div id="page">
<div class="header">
  <div id="lx-aside" style="background-image: url(https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/images/post_cover.min.jpeg)" data-stellar-background-ratio="0.5">
    <div class="overlay">
      <a href="javascript:;" class="popup-trigger" title="search"><i class="menu-item-icon fa fa-search fa-fw"></i></a>
      <div class="page-title">
        <div class="avatar"><a href="/"><img src="https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/images/avatar.min.jpeg" alt="xiaoxin"></a></div>
        <span>2022-04-09</span>
        <h2>ssm</h2>
        
        
      </div>
    </div>
  </div>
</div>
<div id="lx-main-content">
  <div class="lx-post">
    <div class="lx-entry padding">
      <div>
        <p>SSM</p>
<span id="more"></span>

<hr>
<hr>
<h1 id="第一章-Spring-的-IoC-和-DI"><a href="#第一章-Spring-的-IoC-和-DI" class="headerlink" title="第一章 Spring 的 IoC 和 DI"></a>第一章 Spring 的 IoC 和 DI</h1><h2 id="1-Spring-快速入门"><a href="#1-Spring-快速入门" class="headerlink" title="1.Spring 快速入门"></a>1.Spring 快速入门</h2><h3 id="1-1-Spring-程序开发步骤"><a href="#1-1-Spring-程序开发步骤" class="headerlink" title="1.1 Spring 程序开发步骤"></a>1.1 Spring 程序开发步骤</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212123861.png" alt="image-20220221212347738"></p>
</blockquote>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212124142.png" alt="img"></p>
</blockquote>
<h3 id="1-2-导入-Spring-开发的基本包坐标"><a href="#1-2-导入-Spring-开发的基本包坐标" class="headerlink" title="1.2 导入 Spring 开发的基本包坐标"></a>1.2 导入 Spring 开发的基本包坐标</h3><blockquote>
<properties>
    <spring.version>5.0.5.RELEASE</spring.version>
</properties>
<dependencies>
    <!--导入spring的context坐标，context依赖core、beans、expression-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>${spring.version}</version>
    </dependency>
</dependencies>
</blockquote>
<h3 id="1-3-编写-Dao-接口和实现类"><a href="#1-3-编写-Dao-接口和实现类" class="headerlink" title="1.3 编写 Dao 接口和实现类"></a>1.3 编写 Dao 接口和实现类</h3><blockquote>
<p>public interface UserDao {<br>    public void save();<br>}</p>
<p>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao save method running….”);<br>    }<br>}</p>
</blockquote>
<h3 id="1-4-创建-Spring-核心配置文件"><a href="#1-4-创建-Spring-核心配置文件" class="headerlink" title="1.4 创建 Spring 核心配置文件"></a>1.4 创建 Spring 核心配置文件</h3><p>在类路径下（resources）创建 applicationContext.xml 配置文件</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"></p>
</beans>

<h3 id="1-5-在-Spring-配置文件中配置-UserDaoImpl"><a href="#1-5-在-Spring-配置文件中配置-UserDaoImpl" class="headerlink" title="1.5 在 Spring 配置文件中配置 UserDaoImpl"></a>1.5 在 Spring 配置文件中配置 UserDaoImpl</h3><?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean></p>
</beans>

<h3 id="1-6-使用-Spring-的-API-获得-Bean-实例"><a href="#1-6-使用-Spring-的-API-获得-Bean-实例" class="headerlink" title="1.6 使用 Spring 的 API 获得 Bean 实例"></a>1.6 使用 Spring 的 API 获得 Bean 实例</h3><p>public class UseDaoDemo {<br>    public static void main(String[] args) {<br>        ApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        UserDao userDao = (UserDao) app.getBean(“userDao”);<br>        userDao.save();<br>    }<br>}</p>
<h3 id="1-7-知识要点"><a href="#1-7-知识要点" class="headerlink" title="1.7 知识要点"></a>1.7 知识要点</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212130136.png" alt="img"></p>
</blockquote>
<h2 id="2-Spring-配置文件"><a href="#2-Spring-配置文件" class="headerlink" title="2.Spring 配置文件"></a>2.Spring 配置文件</h2><h3 id="2-1-Bean-标签基本配置"><a href="#2-1-Bean-标签基本配置" class="headerlink" title="2.1 Bean 标签基本配置"></a>2.1 Bean 标签基本配置</h3><p>用于配置对象交由 Spring 来创建。<br>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。<br>基本属性：<br>● id：Bean 实例在 Spring 容器中的唯一标识<br>● class：Bean 的全限定名称</p>
<h3 id="2-2-Bean-标签范围配置"><a href="#2-2-Bean-标签范围配置" class="headerlink" title="2.2 Bean 标签范围配置"></a>2.2 Bean 标签范围配置</h3><p>scope：指对象的作用范围，取值如下：</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212133968.png" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212133230.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-3-Bean-生命周期配置"><a href="#2-3-Bean-生命周期配置" class="headerlink" title="2.3 Bean 生命周期配置"></a>2.3 Bean 生命周期配置</h3><p>● init-method：指定类中的初始化方法名称<br>● destroy-method：指定类中销毁方法名称</p>
<h3 id="2-4-Bean-实例化三种方式"><a href="#2-4-Bean-实例化三种方式" class="headerlink" title="2.4 Bean 实例化三种方式"></a>2.4 Bean 实例化三种方式</h3><p>1） 使用无参构造方法实例化<br>它会根据默认无参构造方法来创建类对象，如果 bean 中没有默认无参构造函数，将会创建失败</p>
<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>
2） 工厂静态方法实例化
工厂的静态方法返回 Bean 实例

<p>public class StaticFactoryBean {<br>    public static UserDao createUserDao(){<br>        return new UserDaoImpl();<br>    }<br>}<br><bean id="userDao" class="com.itheima.factory.StaticFactoryBean" factory-method="createUserDao" /><br>3） 工厂实例方法实例化<br>工厂的非静态方法返回 Bean 实例</p>
<p>public class DynamicFactoryBean {<br>    public UserDao createUserDao(){<br>        return new UserDaoImpl();<br>    }<br>}<br><bean id="factoryBean" class="com.itheima.factory.DynamicFactoryBean"/><br><bean id="userDao" factory-bean="factoryBean" factory-method="createUserDao"/></p>
<p><strong>对象已在spring容器中，需要自己去取</strong></p>
<h3 id="2-5-Bean-的依赖注入入门"><a href="#2-5-Bean-的依赖注入入门" class="headerlink" title="2.5 Bean 的依赖注入入门"></a>2.5 Bean 的依赖注入入门</h3><p>① 创建 UserService，UserService 内部在调用 UserDao 的 save () 方法</p>
<p>public class UserServiceImpl implements UserService {<br>    @Override<br>    public void save() {<br>        ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        UserDao userDao = (UserDao) app.getBean(“userDao”);<br>        userDao.save();<br>    }<br>}<br>② 将 UserServiceImpl 的创建权交给 Spring</p>
<bean id="userService" class="com.itheima.service.impl.UserServiceImpl"/>
③ 从 Spring 容器中获得 UserService 进行操作

<p>ApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>UserService userService = (UserService) app.getBean(“userService”);<br>userService.save();</p>
<h3 id="2-6-Bean-的依赖注入分析"><a href="#2-6-Bean-的依赖注入分析" class="headerlink" title="2.6 Bean 的依赖注入分析"></a>2.6 Bean 的依赖注入分析</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212140993.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212140861.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-7-Bean-的依赖注入概念"><a href="#2-7-Bean-的依赖注入概念" class="headerlink" title="2.7 Bean 的依赖注入概念"></a>2.7 Bean 的依赖注入概念</h3><p>依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。</p>
<p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。<br>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p>
<p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。<br>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p>
<p>怎么将 UserDao 怎样注入到 UserService 内部呢？<br>● 构造方法<br>● set 方法</p>
<p>1）set 方法注入<br>在 UserServiceImpl 中添加 setUserDao 方法</p>
<p>public class UserServiceImpl implements UserService {<br>    private UserDao userDao;<br>    public void setUserDao(UserDao userDao) {<br>        this.userDao = userDao;<br>    }<br>    @Override<br>    public void save() {<br>        userDao.save();<br>    }<br>}<br>配置 Spring 容器调用 set 方法进行注入</p>
<p><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean><br><bean id="userService" class="com.itheima.service.impl.UserServiceImpl"><br>    <property name="userDao" ref="userDao"></property><br></bean><br>P 命名空间注入本质也是 set 方法注入，但比起上述的 set 方法注入更加方便，主要体现在配置文件中，如下：<br>首先，需要引入 P 命名空间：</p>
<p>xmlns:p=”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/p&quot;">http://www.springframework.org/schema/p&quot;</a><br>其次，需要修改注入方式</p>
<p><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean><br><bean id="userService" class="com.itheima.service.impl.UserServiceImpl" p:userDao-ref="userDao"></bean><br>2）构造方法注入<br>创建有参构造</p>
<p>public UserServiceImpl() {</p>
<p>}</p>
<p>public UserServiceImpl(UserDao userDao) {<br>        this.userDao = userDao;<br>}<br>配置 Spring 容器调用有参构造时进行注入</p>
<p><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean><br><bean id="userService" class="com.itheima.service.impl.UserServiceImpl"><br>    <constructor-arg name="userDao" ref="userDao"></constructor-arg><br></bean></p>
<h3 id="2-8-Bean-的依赖注入的数据类型"><a href="#2-8-Bean-的依赖注入的数据类型" class="headerlink" title="2.8 Bean 的依赖注入的数据类型"></a>2.8 Bean 的依赖注入的数据类型</h3><p>上面的操作，都是注入的引用 Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p>
<p>注入数据的三种数据类型<br>● 普通数据类型<br>● 引用数据类型<br>● 集合数据类型</p>
<p>其中引用数据类型，此处就不再赘述了，之前的操作都是对 UserDao 对象的引用进行注入的，下面将以 set 方法注入为例，演示普通数据类型和集合数据类型的注入。</p>
<p>1） 普通数据类型的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private int age;<br>    private String name;<br>    public void setAge(int age) {<br>        this.age = age;<br>    }<br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>     public void save() {<br>        System.out.println(name + “============” + age);<br>    }<br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>        <property name="name" value="zhangsan"></property><br>        <property name="age" value="18"></property><br></bean><br>2）集合数据类型（List）的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private List<String> strList;<br>    public void setStrList(List<String> strList) {<br>        this.strList = strList;<br>    }<br>    public void save() {<br>        System.out.println(strList);<br>    }<br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>        <property name="strList"><br>            <list><br>                <value>aaa</value><br>                <value>bbb</value><br>                <value>ccc</value><br>            </list><br>        </property><br></bean><br>3）集合数据类型（List）的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private List<User> userList;<br>    public void setUserList(List<User> userList) {<br>        this.userList = userList;<br>    }<br>    public void save() {<br>        System.out.println(userList);<br>        System.out.println(“UserDao save method running….”);<br>    }<br>}<br><bean id="user1" class="com.itheima.domain.User"><br>    <property name="name" value="tom"></property><br>    <property name="addr" value="beijing"></property><br></bean><br><bean id="user2" class="com.itheima.domain.User"><br>    <property name="name" value="lucy"></property><br>    <property name="addr" value="tianjing"></property><br></bean><br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>    <property name="userList"><br>        <list><br>            <ref bean="user1"></ref><br>            <ref bean="user2"></ref><br>        </list><br>    </property><br></bean><br>4）集合数据类型（ Map&lt;String,User&gt; ）的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private Map&lt;String,User&gt; userMap;<br>    public void setUserMap(Map&lt;String, User&gt; userMap) {<br>        this.userMap = userMap;<br>    }<br>    public void save() {<br>        System.out.println(userMap);<br>    }<br>}<br><bean id="user1" class="com.itheima.domain.User"><br>    <property name="name" value="tom"></property><br>    <property name="addr" value="beijing"></property><br></bean><br><bean id="user2" class="com.itheima.domain.User"><br>    <property name="name" value="lucy"></property><br>    <property name="addr" value="tianjing"></property><br></bean><br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>    <property name="userMap"><br>        <map><br>            <entry key="u1" value-ref="user1"></entry><br>            <entry key="u2" value-ref="user2"></entry><br>        </map><br>    </property><br></bean><br>5）集合数据类型（Properties）的注入</p>
<p>public class UserDaoImpl implements UserDao {<br>    private Properties properties;<br>    public void setProperties(Properties properties) {<br>        this.properties = properties;<br>    }<br>    public void save() {<br>        System.out.println(properties);<br>        System.out.println(“UserDao save method running….”);<br>    }<br>}<br><bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"><br>    <property name="properties"><br>        <props><br>            <prop key="p1">ppp1</prop><br>            <prop key="p2">ppp2</prop><br>            <prop key="p3">ppp3</prop><br>        </props><br>    </property><br></bean></p>
<h3 id="2-9-引入其他配置文件（分模块开发）"><a href="#2-9-引入其他配置文件（分模块开发）" class="headerlink" title="2.9 引入其他配置文件（分模块开发）"></a>2.9 引入其他配置文件（分模块开发）</h3><p>实际开发中，Spring 的配置内容非常多，这就导致 Spring 配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在 Spring 主配置文件通过 import 标签进行加载</p>
<import resource="applicationContext-xxx.xml"/>

<h3 id="2-10-知识要点"><a href="#2-10-知识要点" class="headerlink" title="2.10 知识要点"></a>2.10 知识要点</h3><p>Spring 的重点配置</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212158848.png" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="3-Spring-相关-API"><a href="#3-Spring-相关-API" class="headerlink" title="3.Spring 相关 API"></a>3.Spring 相关 API</h2><h3 id="3-1-ApplicationContext-的继承体系"><a href="#3-1-ApplicationContext-的继承体系" class="headerlink" title="3.1 ApplicationContext 的继承体系"></a>3.1 ApplicationContext 的继承体系</h3><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212200328.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-2-ApplicationContext-的实现类"><a href="#3-2-ApplicationContext-的实现类" class="headerlink" title="3.2 ApplicationContext 的实现类"></a>3.2 ApplicationContext 的实现类</h3><p>1）ClassPathXmlApplicationContext</p>
<p>它是从类的根路径下加载配置文件 推荐使用这种<br>例如：</p>
<p>ApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>2）FileSystemXmlApplicationContext</p>
<p>它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。<br>例如：</p>
<p>ApplicationContext app1 = new FileSystemXmlApplicationContext(“D:\IDEA\IdeaProjects\Spring\itheima_spring_ioc\src\main\resources\applicationContext.xml”)<br>3）AnnotationConfigApplicationContext</p>
<p>当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p>
<h3 id="3-3-getBean-方法使用"><a href="#3-3-getBean-方法使用" class="headerlink" title="3.3 getBean () 方法使用"></a>3.3 getBean () 方法使用</h3><p>public Object getBean(String name) throws BeansException {<br>    assertBeanFactoryActive();<br>    return getBeanFactory().getBean(name);<br>}<br>public <T> T getBean(Class<T> requiredType) throws BeansException {<br>    assertBeanFactoryActive();<br>    return getBeanFactory().getBean(requiredType);<br>}<br>其中，当参数的数据类型是字符串时，表示根据 Bean 的 id 从容器中获得 Bean 实例，返回是 Object，需要强转。<br>当参数的数据类型是 Class 类型时，表示根据类型从容器中匹配 Bean 实例，当容器中相同类型的 Bean 有多个时，则此方法会报错。</p>
<p>ApplicationContext applicationContext = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>UserService userService1 = (UserService)applicationContext.getBean(“userService”);<br>UserService userService2 = applicationContext.getBean(UserService.class);</p>
<h3 id="3-4-知识要点"><a href="#3-4-知识要点" class="headerlink" title="3.4 知识要点"></a>3.4 知识要点</h3><p>Spring 的重点 API</p>
<p>ApplicationContext app = new ClasspathXmlApplicationContext(“xml文件”)<br>app.getBean(“id”)<br>app.getBean(Class)</p>
<h1 id="第二章-IoC-和-DI-注解开发"><a href="#第二章-IoC-和-DI-注解开发" class="headerlink" title="第二章 IoC 和 DI 注解开发"></a>第二章 IoC 和 DI 注解开发</h1><h2 id="1-Spring-配置数据源"><a href="#1-Spring-配置数据源" class="headerlink" title="1.Spring 配置数据源"></a>1.Spring 配置数据源</h2><h3 id="1-1-数据源（连接池）的作用"><a href="#1-1-数据源（连接池）的作用" class="headerlink" title="1.1 数据源（连接池）的作用"></a>1.1 数据源（连接池）的作用</h3><p>● 数据源 (连接池) 是提高程序性能如出现的<br>● 事先实例化数据源，初始化部分连接资源<br>● 使用连接资源时从数据源中获取<br>● 使用完毕后将连接资源归还给数据源</p>
<p>常见的数据源 (连接池)：DBCP、C3P0、BoneCP、Druid 等</p>
<p>数据源的开发步骤：<br>① 导入数据源的坐标和数据库驱动坐标<br>② 创建数据源对象<br>③ 设置数据源的基本连接数据<br>④ 使用数据源获取连接资源和归还连接资源</p>
<h3 id="1-2-数据源的手动创建"><a href="#1-2-数据源的手动创建" class="headerlink" title="1.2 数据源的手动创建"></a>1.2 数据源的手动创建</h3><p>① 导入 c3p0 和 druid 的坐标</p>
<!-- C3P0连接池 -->
<dependency>
    <groupId>c3p0</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.1.2</version>
</dependency>
<!-- Druid连接池 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.10</version>
</dependency>
导入 mysql 数据库驱动坐标

<!-- mysql驱动 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.39</version>
</dependency>
② 创建 C3P0 连接池

<p>@Test<br>public void testC3P0() throws Exception {<br>    //创建数据源<br>    ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>    //设置数据库连接参数<br>    dataSource.setDriverClass(“com.mysql.jdbc.Driver”);<br>    dataSource.setJdbcUrl(“jdbc:mysql://localhost:3306/test”);<br>    dataSource.setUser(“root”);<br>    dataSource.setPassword(“root”);<br>    //获得连接对象<br>    Connection connection = dataSource.getConnection();<br>    System.out.println(connection);<br>}<br>② 创建 Druid 连接池</p>
<p>@Test<br>public void testDruid() throws Exception {<br>    //创建数据源<br>    DruidDataSource dataSource = new DruidDataSource();<br>    //设置数据库连接参数<br>    dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);<br>    dataSource.setUrl(“jdbc:mysql://localhost:3306/test”);<br>    dataSource.setUsername(“root”);<br>    dataSource.setPassword(“root”);<br>    //获得连接对象<br>    Connection connection = dataSource.getConnection();<br>    System.out.println(connection);<br>}<br>③ 提取 jdbc.properties 配置文件</p>
<p>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/test<br>jdbc.username=root<br>jdbc.password=root<br>④ 读取 jdbc.properties 配置文件创建连接池</p>
<p>@Test<br>public void testC3P0ByProperties() throws Exception {<br>    //加载类路径下的jdbc.properties<br>    ResourceBundle rb = ResourceBundle.getBundle(“jdbc”);<br>    ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>    dataSource.setDriverClass(rb.getString(“jdbc.driver”));<br>    dataSource.setJdbcUrl(rb.getString(“jdbc.url”));<br>    dataSource.setUser(rb.getString(“jdbc.username”));<br>    dataSource.setPassword(rb.getString(“jdbc.password”));<br>    Connection connection = dataSource.getConnection();<br>    System.out.println(connection);<br>}</p>
<h3 id="1-3-Spring-配置数据源"><a href="#1-3-Spring-配置数据源" class="headerlink" title="1.3 Spring 配置数据源"></a>1.3 Spring 配置数据源</h3><p>可以将 DataSource 的创建权交由 Spring 容器去完成<br>● DataSource 有无参构造方法，而 Spring 默认就是通过无参构造方法实例化对象的<br>● DataSource 要想使用需要通过 set 方法设置数据库连接信息，而 Spring 可以通过 set 方法进行字符串注入</p>
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
</bean>
测试从容器当中获取数据源

<p>ApplicationContext applicationContext = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>DataSource dataSource = (DataSource)<br>applicationContext.getBean(“dataSource”);<br>Connection connection = dataSource.getConnection();<br>System.out.println(connection);</p>
<h4 id="1-4-抽取-jdbc-配置文件"><a href="#1-4-抽取-jdbc-配置文件" class="headerlink" title="1.4 抽取 jdbc 配置文件"></a>1.4 抽取 jdbc 配置文件</h4><p>applicationContext.xml 加载 jdbc.properties 配置文件获得连接信息。<br>首先，需要引入 context 命名空间和约束路径：<br>● 命名空间：xmlns:context=“<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context%E2%80%9D">http://www.springframework.org/schema/context”</a><br>● 约束路径：<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br><a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></p>
<p>&lt;context:property-placeholder location=”classpath:jdbc.properties”/&gt;<br><bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>    <property name="driverClass" value="${jdbc.driver}"/><br>    <property name="jdbcUrl" value="${jdbc.url}"/><br>    <property name="user" value="${jdbc.username}"/><br>    <property name="password" value="${jdbc.password}"/><br></bean></p>
<h3 id="1-5-知识要点"><a href="#1-5-知识要点" class="headerlink" title="1.5 知识要点"></a>1.5 知识要点</h3><p>Spring 容器加载 properties 文件</p>
<p>&lt;context:property-placeholder location=”xx.properties”/&gt;<br><property name="" value="${key}"/></p>
<h2 id="2-Spring-注解开发"><a href="#2-Spring-注解开发" class="headerlink" title="2.Spring 注解开发"></a>2.Spring 注解开发</h2><h3 id="2-1-Spring-原始注解"><a href="#2-1-Spring-原始注解" class="headerlink" title="2.1 Spring 原始注解"></a>2.1 Spring 原始注解</h3><p>Spring 是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替 xml 配置文件可以简化配置，提高开发效率。</p>
<p>Spring 原始注解主要是替代的配置</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212216426.png" alt="在这里插入图片描述"></p>
<p>注意：<br>使用注解进行开发时，需要在 applicationContext.xml 中配置组件扫描，作用是指定哪个包及其子包下的 Bean 需要进行扫描以便识别使用注解配置的类、字段和方法。</p>
<!--注解的组件扫描-->
<p>&lt;context:component-scan base-package=”com.itheima”&gt;</context:componentscan><br>● 使用 @Compont 或 @Repository 标识 UserDaoImpl 需要 Spring 进行实例化。</p>
<p>//@Component(“userDao”)<br>@Repository(“userDao”)<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“save running… …”);<br>    }<br>}<br>● 使用 @Compont 或 @Service 标识 UserServiceImpl 需要 Spring 进行实例化<br>● 使用 @Autowired 或者 @Autowired+@Qulifier 或者 @Resource 进行 userDao 的注入</p>
<p>//@Component(“userService”)<br>@Service(“userService”)<br>public class UserServiceImpl implements UserService {<br>    /*<br>    @Autowired //按照数据类型从Spring容器中进行匹配的<br>    @Qualifier(“userDao”)  //是按照id值从容器中进行匹配的 但是注意@Qualifier要结合@Autowired一起使用<br>    */<br>    @Resource(name=”userDao”)<br>    private UserDao userDao;<br>    @Override<br>    public void save() {<br>        userDao.save();<br>    }<br>}<br>● 使用 @Value 进行字符串的注入</p>
<p>@Repository(“userDao”)<br>public class UserDaoImpl implements UserDao {<br>    @Value(“注入普通数据”)<br>    private String str;<br>    @Value(“${jdbc.driver}”)<br>    private String driver;<br>    @Override<br>    public void save() {<br>        System.out.println(str);<br>        System.out.println(driver);<br>        System.out.println(“save running… …”);<br>    }<br>}<br>● 使用 @Scope 标注 Bean 的范围</p>
<p>//@Scope(“prototype”)<br>@Scope(“singleton”)<br>public class UserDaoImpl implements UserDao {<br>    //此处省略代码<br>}<br>● 使用 @PostConstruct 标注初始化方法，使用 @PreDestroy 标注销毁方法</p>
<p>@PostConstruct<br>public void init(){<br>    System.out.println(“初始化方法….”);<br>}<br>@PreDestroy<br>public void destroy(){<br>    System.out.println(“销毁方法…..”);<br>}</p>
<h3 id="2-2-Spring-新注解"><a href="#2-2-Spring-新注解" class="headerlink" title="2.2 Spring 新注解"></a>2.2 Spring 新注解</h3><p>使用上面的注解还不能全部替代 xml 配置文件，还需要使用注解替代的配置如下：<br>● 非自定义的 Bean 的配置：<bean><br>● 加载 properties 文件的配置：<a href="context:property-placeholder">context:property-placeholder</a><br>● 组件扫描的配置：<a href="context:component-scan">context:component-scan</a><br>● 引入其他文件：<import></p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212226869.png" alt="在这里插入图片描述"></p>
<p>● @Configuration<br>● @ComponentScan<br>● @Import</p>
<p>@Configuration  //标志该类是Spring的核心配置类<br>@ComponentScan(“com.itheima”)<br>@Import({DataSourceConfiguration.class})<br>public class SpringConfiguration {<br>}<br>● @PropertySource<br>● @value</p>
<p>@PropertySource(“classpath:jdbc.properties”)<br>public class DataSourceConfiguration {<br>    @Value(“${jdbc.driver}”)<br>    private String driver;<br>    @Value(“${jdbc.url}”)<br>    private String url;<br>    @Value(“${jdbc.username}”)<br>    private String username;<br>    @Value(“${jdbc.password}”)<br>    private String password;<br>}<br>● @Bean</p>
<p>@Bean(name=”dataSource”)  //Spring会将当前方法的返回值以指定名称存储到Spring容器中<br>public DataSource getDataSource() throws PropertyVetoException {<br>    ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>    dataSource.setDriverClass(driver);<br>    dataSource.setJdbcUrl(url);<br>    dataSource.setUser(username);<br>    dataSource.setPassword(password);<br>    return dataSource;<br>}<br>测试加载核心配置类创建 Spring 容器</p>
<p>@Test<br>public void testAnnoConfiguration() throws Exception {<br>  ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class);<br>    UserService userService = (UserService) applicationContext.getBean(“userService”);<br>    userService.save();<br>    DataSource dataSource = (DataSource) applicationContext.getBean(“dataSource”);<br>    Connection connection = dataSource.getConnection();<br>    System.out.println(connection);<br>}</p>
<h2 id="3-Spring-集成-Junit"><a href="#3-Spring-集成-Junit" class="headerlink" title="3.Spring 集成 Junit"></a>3.Spring 集成 Junit</h2><h3 id="3-1-原始-Junit-测试-Spring-的问题"><a href="#3-1-原始-Junit-测试-Spring-的问题" class="headerlink" title="3.1 原始 Junit 测试 Spring 的问题"></a>3.1 原始 Junit 测试 Spring 的问题</h3><p>在测试类中，每个测试方法都有以下两行代码：</p>
<p>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>IAccountService as = ac.getBean(“accountService”,IAccountService.class);<br>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p>
<h3 id="3-2-上述问题解决思路"><a href="#3-2-上述问题解决思路" class="headerlink" title="3.2 上述问题解决思路"></a>3.2 上述问题解决思路</h3><p>● 让 SpringJunit 负责创建 Spring 容器，但是需要将配置文件的名称告诉它<br>● 将需要进行测试 Bean 直接在测试类中进行注入</p>
<h3 id="3-3-Spring-集成-Junit-步骤"><a href="#3-3-Spring-集成-Junit-步骤" class="headerlink" title="3.3 Spring 集成 Junit 步骤"></a>3.3 Spring 集成 Junit 步骤</h3><p>① 导入 spring 集成 Junit 的坐标<br>② 使用 @Runwith 注解替换原来的运行期<br>③ 使用 @ContextConfiguration 指定配置文件或配置类<br>④ 使用 @Autowired 注入需要测试的对象<br>⑤ 创建测试方法进行测试</p>
<h3 id="3-4-Spring-集成-Junit-代码实现"><a href="#3-4-Spring-集成-Junit-代码实现" class="headerlink" title="3.4 Spring 集成 Junit 代码实现"></a>3.4 Spring 集成 Junit 代码实现</h3><p>① 导入 spring 集成 Junit 的坐标</p>
<!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>

<p>② 使用 @Runwith 注解替换原来的运行期</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>public class SpringJunitTest {<br>}<br>③ 使用 @ContextConfiguration 指定配置文件或配置类</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>//加载spring核心配置文件<br>//@ContextConfiguration(value = {“classpath:applicationContext.xml”})<br>//加载spring核心配置类<br>@ContextConfiguration(classes = {SpringConfiguration.class})<br>public class SpringJunitTest {<br>}<br>④ 使用 @Autowired 注入需要测试的对象</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = {SpringConfiguration.class})<br>public class SpringJunitTest {<br>    @Autowired<br>    private UserService userService;<br>}<br>⑤ 创建测试方法进行测试</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = {SpringConfiguration.class})<br>public class SpringJunitTest {<br>    @Autowired<br>    private UserService userService;<br>    @Test<br>    public void testUserService(){<br>        userService.save();<br>    }<br>}</p>
<h3 id="3-5-知识要点"><a href="#3-5-知识要点" class="headerlink" title="3.5 知识要点"></a>3.5 知识要点</h3><p>Spring 集成 Junit 步骤<br>① 导入 spring 集成 Junit 的坐标<br>② 使用 @Runwith 注解替换原来的运行期<br>③ 使用 @ContextConfiguration 指定配置文件或配置类<br>④ 使用 @Autowired 注入需要测试的对象<br>⑤ 创建测试方法进行测试</p>
<h1 id="第三章-SpringMVC-入门"><a href="#第三章-SpringMVC-入门" class="headerlink" title="第三章 SpringMVC 入门"></a>第三章 SpringMVC 入门</h1><h2 id="1-Spring-集成-web-环境"><a href="#1-Spring-集成-web-环境" class="headerlink" title="1.Spring 集成 web 环境"></a>1.Spring 集成 web 环境</h2><h3 id="1-1-ApplicationContext-应用上下文获取方式"><a href="#1-1-ApplicationContext-应用上下文获取方式" class="headerlink" title="1.1 ApplicationContext 应用上下文获取方式"></a>1.1 ApplicationContext 应用上下文获取方式</h3><p>应用上下文对象是通过 new ClasspathXmlApplicationContext (spring 配置文件) 方式获取的，但是每次从容器中获得 Bean 时都要编写 new ClasspathXmlApplicationContext (spring 配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p>
<p>在 Web 项目中，可以使用 ServletContextListener 监听 Web 应用的启动，我们可以在 Web 应用启动时，就加载 Spring 的配置文件，创建应用上下文对象 ApplicationContext，在将其存储到最大的域 servletContext 域中，这样就可以在任意位置从域中获得应用上下文 ApplicationContext 对象了。</p>
<h3 id="1-2-Spring-提供获取应用上下文的工具"><a href="#1-2-Spring-提供获取应用上下文的工具" class="headerlink" title="1.2 Spring 提供获取应用上下文的工具"></a>1.2 Spring 提供获取应用上下文的工具</h3><p>上面的分析不用手动实现，Spring 提供了一个监听器 ContextLoaderListener 就是对上述功能的封装，该监听器内部加载 Spring 配置文件，创建应用上下文对象，并存储到 ServletContext 域中，提供了一个客户端工具 WebApplicationContextUtils 供使用者获得应用上下文对象。</p>
<p>所以我们需要做的只有两件事：<br>① 在 web.xml 中配置 ContextLoaderListener 监听器（导入 spring-web 坐标）<br>② 使用 WebApplicationContextUtils 获得应用上下文对象 ApplicationContext</p>
<h3 id="1-3-导入-Spring-集成-web-的坐标"><a href="#1-3-导入-Spring-集成-web-的坐标" class="headerlink" title="1.3 导入 Spring 集成 web 的坐标"></a>1.3 导入 Spring 集成 web 的坐标</h3><dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>

<h3 id="1-4-配置-ContextLoaderListener-监听器"><a href="#1-4-配置-ContextLoaderListener-监听器" class="headerlink" title="1.4 配置 ContextLoaderListener 监听器"></a>1.4 配置 ContextLoaderListener 监听器</h3><!--全局初始化参数-->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <!--Spring的总配置文件-->
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>

<!--配置监听器-->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<h3 id="1-5-通过工具获得应用上下文对象"><a href="#1-5-通过工具获得应用上下文对象" class="headerlink" title="1.5 通过工具获得应用上下文对象"></a>1.5 通过工具获得应用上下文对象</h3><p>//先获取上下文对象getServletContext(),将参数放入<br>ApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(servletContext);<br>UserService userService = app.getBean(UserService.class);</p>
<h3 id="1-6-知识要点"><a href="#1-6-知识要点" class="headerlink" title="1.6 知识要点"></a>1.6 知识要点</h3><p>Spring 集成 web 环境步骤<br>① 配置 ContextLoaderListener 监听器<br>② 使用 WebApplicationContextUtils 获得应用上下文</p>
<h2 id="2-SpringMVC-简介"><a href="#2-SpringMVC-简介" class="headerlink" title="2.SpringMVC 简介"></a>2.SpringMVC 简介</h2><h3 id="2-1-SpringMVC-概述"><a href="#2-1-SpringMVC-概述" class="headerlink" title="2.1 SpringMVC 概述"></a>2.1 SpringMVC 概述</h3><p>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。</p>
<p>SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。</p>
<p>SpringMVC 雏形</p>
<h3 id="2-2-SpringMVC-快速入门"><a href="#2-2-SpringMVC-快速入门" class="headerlink" title="2.2 SpringMVC 快速入门"></a>2.2 SpringMVC 快速入门</h3><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。<br>开发步骤：<br>① 导入 SpringMVC 相关坐标<br>② 配置 SpringMVC 核心控制器 DispathcerServlet<br>③ 创建 Controller 类和视图页面<br>④ 使用注解配置 Controller 类中业务方法的映射地址<br>⑤ 配置 SpringMVC 核心文件 spring-mvc.xml<br>⑥ 客户端发起请求测试</p>
<p>① 导入 Spring 和 SpringMVC 的坐标</p>
<!--Spring坐标-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>
<!--SpringMVC坐标-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>
① 导入 Servlet 和 Jsp 的坐标

<!--Servlet坐标-->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>servlet-api</artifactId>
    <version>2.5</version>
     <!-- 因为Tomcat有这个包，所有在打包的时候，不扫描这个包-->
    <scope>provided</scope>
</dependency>
<!--Jsp坐标-->
<dependency>
    <groupId>javax.servlet.jsp</groupId>
    <artifactId>jsp-api</artifactId>
    <version>2.0</version>
     <!-- 因为Tomcat有这个包，所有在打包的时候，不扫描这个包-->
    <scope>provided</scope>
</dependency>
② 在 web.xml 配置 SpringMVC 的核心控制器

<!--配置SpringMVC的前端控制器-->
<servlet>
    <servlet-name>DispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>DispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
③ 创建 Controller 和业务方法

<p>public class UserController {<br>    public String save(){<br>        System.out.println(“Controller save running…”);<br>        return “success.jsp”;<br>    }<br>}<br>③ 创建视图页面 success.jsp</p>
<html>
<body>
    <h1>Success!</h1>
</body>
</html>
④ 配置注解

<p>@Controller<br>public class UserController {<br>    //请求地址：<a target="_blank" rel="noopener" href="http://localhost:8080/quick">http://localhost:8080/quick</a><br>    @RequestMapping(“/quick”)<br>    public String save(){<br>        System.out.println(“Controller save running…”);<br>        //  <strong>加/代表从web路径下加载资源，如果不加/代表从/user目录下加载资源，会报错</strong><br>        return “/success.jsp”;<br>    }<br>}<br>⑤ 创建 spring-mvc.xml</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"></p>
<pre><code>&lt;!--Controller的组件扫描--&gt;
&lt;context:component-scan base-package=&quot;com.itheima.controller&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<p>​<br></beans><br>⑥ 访问测试地址</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/quick">http://localhost:8080/quick</a></p>
<p>Spring 访问流程（代码角度）</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212254106.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-3-SpringMVC-流程图示"><a href="#2-3-SpringMVC-流程图示" class="headerlink" title="2.3 SpringMVC 流程图示"></a>2.3 SpringMVC 流程图示</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212255814.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-4-知识要点"><a href="#2-4-知识要点" class="headerlink" title="2.4 知识要点"></a>2.4 知识要点</h3><p>SpringMVC 的开发步骤<br>① 导入 SpringMVC 相关坐标<br>② 配置 SpringMVC 核心控制器 DispathcerServlet<br>③ 创建 Controller 类和视图页面<br>④ 使用注解配置 Controller 类中业务方法的映射地址<br>⑤ 配置 SpringMVC 核心文件 spring-mvc.xml<br>⑥ 客户端发起请求测试</p>
<h2 id="3-SpringMVC-组件解析"><a href="#3-SpringMVC-组件解析" class="headerlink" title="3.SpringMVC 组件解析"></a>3.SpringMVC 组件解析</h2><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212256494.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-1-SpringMVC-的执行流程"><a href="#3-1-SpringMVC-的执行流程" class="headerlink" title="3.1 SpringMVC 的执行流程"></a>3.1 SpringMVC 的执行流程</h3><p>① 用户发送请求至前端控制器 DispatcherServlet。<br>② DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。<br>③ 处理器映射器找到具体的处理器 (可以根据 xml 配置、注解进行查找)，生成处理器对象及处理器拦截器 (如果有则生成) 一并返回给 DispatcherServlet。<br>④ DispatcherServlet 调用 HandlerAdapter 处理器适配器。<br>⑤ HandlerAdapter 经过适配调用具体的处理器 (Controller，也叫后端控制器)。<br>⑥ Controller 执行完成返回 ModelAndView。<br>⑦ HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。<br>⑧ DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。<br>⑨ ViewReslover 解析后返回具体 View。<br>⑩ DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet 响应用户。</p>
<h3 id="3-2-SpringMVC-组件解析"><a href="#3-2-SpringMVC-组件解析" class="headerlink" title="3.2 SpringMVC 组件解析"></a>3.2 SpringMVC 组件解析</h3><p>前端控制器：DispatcherServlet</p>
<p>用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p>处理器映射器：HandlerMapping</p>
<p>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p>处理器适配器：HandlerAdapter</p>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<p>处理器：Handler</p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。</p>
<p>视图解析器：View Resolver</p>
<p>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
<p>视图：View</p>
<p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p>
<h3 id="3-3-SpringMVC-注解解析"><a href="#3-3-SpringMVC-注解解析" class="headerlink" title="3.3 SpringMVC 注解解析"></a>3.3 SpringMVC 注解解析</h3><p>@RequestMapping<br>作用：用于建立请求 URL 和处理请求方法之间的对应关系</p>
<p>位置：<br>● 类上，请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录<br>● 方法上，请求 URL 的第二级访问目录，与类上的使用 @ReqquestMapping 标注的一级目录一起组成访问虚拟路径</p>
<p>属性：<br>● value：用于指定请求的 URL。它和 path 属性的作用是一样的<br>● method：用于指定请求的方式<br>● params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样</p>
<p>例如：<br>● params = {“accountName”}，表示请求参数必须有 accountName<br>● params = {“moeny!100”}，表示请求参数中 money 不能是 100</p>
<p>1.mvc 命名空间引入</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212259070.png" alt="在这里插入图片描述"></p>
</blockquote>
<ol start="2">
<li>组件扫描<br>SpringMVC 基于 Spring 容器，所以在进行 SpringMVC 操作时，需要将 Controller 存储到 Spring 容器中，如果使用 @Controller 注解标注的话，就需要使用 &lt;context:component-scan base-package=“com.itheima.controller”/&gt; 进行组件扫描。</li>
</ol>
<h3 id="3-4-SpringMVC-的-XML-配置解析"><a href="#3-4-SpringMVC-的-XML-配置解析" class="headerlink" title="3.4 SpringMVC 的 XML 配置解析"></a>3.4 SpringMVC 的 XML 配置解析</h3><p>视图解析器</p>
<p>SpringMVC 有默认组件配置，默认组件都是 DispatcherServlet.properties 配置文件中配置的，该配置文件地址 org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：<br>org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</p>
<p>翻看该解析器源码，可以看到该解析器的默认设置，如下：</p>
<p>REDIRECT_URL_PREFIX = “redirect:” –重定向前缀<br>FORWARD_URL_PREFIX = “forward:” –转发前缀（默认值）<br>prefix = “”; –视图名称前缀<br>suffix = “”; –视图名称后缀<br>我们可以通过属性注入的方式修改视图的的前后缀</p>
<!--配置内部资源视图解析器-->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <!-- /jsp/success.jsp -->
    <property name="prefix" value="/jsp/"></property>
    <property name="suffix" value=".jsp"></property>
</bean>

<h3 id="3-5-知识要点-1"><a href="#3-5-知识要点-1" class="headerlink" title="3.5 知识要点"></a>3.5 知识要点</h3><p>SpringMVC 的相关组件<br>・前端控制器：DispatcherServlet<br>・处理器映射器：HandlerMapping<br>・处理器适配器：HandlerAdapter<br>・处理器：Handler<br>・视图解析器：View Resolver<br>・视图：View</p>
<p>SpringMVC 的注解和配置<br>・请求映射注解：@RequestMapping<br>・视图解析器配置：</p>
<p>REDIRECT_URL_PREFIX = “redirect:” –重定向前缀<br>FORWARD_URL_PREFIX = “forward:” –转发前缀（默认值）<br>prefix = “”; –视图名称前缀<br>suffix = “”; –视图名称后缀</p>
<h1 id="第四章-SpringMVC-的请求和响应"><a href="#第四章-SpringMVC-的请求和响应" class="headerlink" title="第四章 SpringMVC 的请求和响应"></a>第四章 SpringMVC 的请求和响应</h1><h2 id="1-SpringMVC-的数据响应"><a href="#1-SpringMVC-的数据响应" class="headerlink" title="1.SpringMVC 的数据响应"></a>1.SpringMVC 的数据响应</h2><h3 id="1-1-SpringMVC-的数据响应方式"><a href="#1-1-SpringMVC-的数据响应方式" class="headerlink" title="1.1 SpringMVC 的数据响应方式"></a>1.1 SpringMVC 的数据响应方式</h3><p>1） 页面跳转</p>
<p>● 直接返回字符串<br>● 通过 ModelAndView 对象返回</p>
<p>2） 回写数据</p>
<p>● 直接返回字符串<br>● 返回对象或集合</p>
<h3 id="1-2-页面跳转"><a href="#1-2-页面跳转" class="headerlink" title="1.2 页面跳转"></a>1.2 页面跳转</h3><p>（1）返回字符串形式</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212303404.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。</p>
<p>返回带有前缀的字符串：<br>转发：forward:/WEB-INF/views/index.jsp<br>重定向：redirect:/index.jsp(因为 webinfo 文件夹 [即 WEB-INF] 是受保护的，所以要把重定向的 jsp 放到可以直接访问的地方)</p>
<p>（2）返回 ModelAndView 对象</p>
<p>@RequestMapping(value = “/quick2”)<br>public ModelAndView save2() {<br>    /*<br>        Model:模型 作用封装数据<br>        View：视图 作用展示数据<br>     */<br>    ModelAndView modelAndView = new ModelAndView();<br>    //设置模型数据<br>    modelAndView.addObject(“username”, “itcast”);<br>    //设置视图名称<br>    modelAndView.setViewName(“success”);<br>    return modelAndView;<br>}<br>@RequestMapping(value = “/quick4”)<br>public String save4(Model model) {<br>    model.addAttribute(“username”, “博学谷”);<br>    return “success”;<br>}<br>（3）向 request 域存储数据</p>
<p>在进行转发时，往往要向 request 域中存储数据，在 jsp 页面中显示，那么 Controller 中怎样向 request 域中存储数据呢？</p>
<p>① 通过 SpringMVC 框架注入的 request 对象 setAttribute () 方法设置</p>
<p>@RequestMapping(value = “/quick5”)<br>public String save5(HttpServletRequest request) {<br>    request.setAttribute(“username”,”酷丁鱼”);<br>    return “success”;<br>}</p>
<p>② 通过 ModelAndView 的 addObject () 方法设置</p>
<p>@RequestMapping(value = “/quick3”)<br>public ModelAndView save3(ModelAndView modelAndView) {<br>    modelAndView.addObject(“username”, “itheima”);<br>    modelAndView.setViewName(“success”);<br>    return modelAndView;<br>}</p>
<h3 id="1-3-回写数据"><a href="#1-3-回写数据" class="headerlink" title="1.3 回写数据"></a>1.3 回写数据</h3><p>（1）直接返回字符串</p>
<p>Web 基础阶段，客户端访问服务器端，如果想直接回写字符串作为响应体返回的话，只需要使用 response.getWriter ().print (“hello world”) 即可，那么在 Controller 中想直接回写字符串该怎样呢？</p>
<p>① 通过 SpringMVC 框架注入的 response 对象，使用 response.getWriter ().print (“hello world”) 回写数<br>据，此时不需要视图跳转，业务方法返回值为 void。</p>
<p>@RequestMapping(value = “/quick6”)<br>public void save6(HttpServletResponse response) throws IOException {<br>    response.getWriter().println(“hello itcast”);<br>}<br>② 将需要回写的字符串直接返回，但此时需要通过 @ResponseBody 注解告知 SpringMVC 框架，方法<br>返回的字符串不是跳转是直接在 http 响应体中返回。</p>
<p>@RequestMapping(value = “/quick7”)<br>@ResponseBody   //告诉SpringMVC框架 不进行页面跳转 直接进行数据响应<br>public String save7() {<br>    return “hello itheima”;<br>}<br>在异步项目中，客户端与服务器端往往要进行 json 格式字符串交互，此时我们可以手动拼接 json 字符串返回。</p>
<p>@RequestMapping(value = “/quick8”)<br>@ResponseBody   //告诉SpringMVC框架 不进行页面跳转 直接进行数据响应<br>public String save8() {<br>    return “{&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18)}”;<br>}<br>上述方式手动拼接 json 格式字符串的方式很麻烦，开发中往往要将复杂的 java 对象转换成 json 格式的字符串，我们可以使用 web 阶段学习过的 json 转换工具 jackson 进行转换，导入 jackson 坐标。</p>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.9.0</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.0</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.9.0</version>
</dependency>
通过 jackson 转换 json 格式字符串，回写字符串。

<p>@RequestMapping(value = “/quick9”)<br>@ResponseBody   //告诉SpringMVC框架 不进行页面跳转 直接进行数据响应<br>public String save9() throws JsonProcessingException {<br>    User user = new User();<br>    user.setAge(30);<br>    user.setUsername(“lisi”);<br>    //使用json的转换工具将对象转换成json格式字符串再返回<br>    ObjectMapper objectMapper = new ObjectMapper();<br>    String json = objectMapper.writeValueAsString(user);<br>    return json;<br>}</p>
<p>（2）返回对象或集合</p>
<p>通过 SpringMVC 帮助我们对对象或集合进行 json 字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用 jackson 进行对象或集合的转换，因此需要在 spring-mvc.xml 中进行如下配置：</p>
<!--配置处理映射器-->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
    <property name="messageConverters">
       <list>
           <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"></bean>
       </list>
    </property>
</bean>
@RequestMapping(value = "/quick10")
@ResponseBody   //告诉SpringMVC框架 不进行页面跳转 直接进行数据响应
public User save10() {
    User user = new User();
    user.setAge(32);
    user.setUsername("lisi2");
    return user;
}
在方法上添加 @ResponseBody 就可以返回 json 格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用 mvc 的注解驱动代替上述配置。

<!--mvc的注解驱动-->
<p><a href="mvc:annotation-driven">mvc:annotation-driven</a></mvc:annotation-driven><br>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。<br>使用 mvc:annotation-driven 自动加载 RequestMappingHandlerMapping（处理映射器）和<br>RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在 Spring-xml.xml 配置文件中使用 mvc:annotation-driven 替代注解处理器和适配器的配置。<br>同时使用 mvc:annotation-driven 默认底层就会集成 jackson 进行对象或集合的 json 格式字符串的转换。</p>
<h3 id="1-4-知识要点"><a href="#1-4-知识要点" class="headerlink" title="1.4 知识要点"></a>1.4 知识要点</h3><p>SpringMVC 的数据响应方式<br>1） 页面跳转<br>● 直接返回字符串<br>● 通过 ModelAndView 对象返回</p>
<p>2） 回写数据<br>● 直接返回字符串<br>● 返回对象或集合</p>
<h2 id="2-SpringMVC-获得请求数据"><a href="#2-SpringMVC-获得请求数据" class="headerlink" title="2.SpringMVC 获得请求数据"></a>2.SpringMVC 获得请求数据</h2><h3 id="2-1-获得请求参数"><a href="#2-1-获得请求参数" class="headerlink" title="2.1 获得请求参数"></a>2.1 获得请求参数</h3><p>客户端请求参数的格式是：name=value&amp;name=value… …<br>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC 可以接收如下类型的参数：<br>● 基本类型参数<br>● POJO 类型参数<br>● 数组类型参数<br>● 集合类型参数</p>
<h3 id="2-2-获得基本类型参数"><a href="#2-2-获得基本类型参数" class="headerlink" title="2.2 获得基本类型参数"></a>2.2 获得基本类型参数</h3><p>Controller 中的业务方法的参数名称要与请求参数的 name 一致，参数值会自动映射匹配。</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/user/quick11?username=zhangsan&amp;age=12">http://localhost:8080/user/quick11?username=zhangsan&amp;age=12</a></p>
<p>@RequestMapping(value = “/quick11”)<br>@ResponseBody<br>public void save11(String username, int age) {<br>    System.out.println(username);<br>    System.out.println(age);<br>}</p>
<h3 id="2-3-获得-POJO-类型参数"><a href="#2-3-获得-POJO-类型参数" class="headerlink" title="2.3 获得 POJO 类型参数"></a>2.3 获得 POJO 类型参数</h3><p>Controller 中的业务方法的 POJO 参数的属性名与请求参数的 name 一致，参数值会自动映射匹配。</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/user/quick12?username=zhangsan&amp;age=12">http://localhost:8080/user/quick12?username=zhangsan&amp;age=12</a></p>
<p>public class User {<br>    private String username;<br>    private int age;<br>    getter/setter…<br>}<br>@RequestMapping(value = “/quick12”)<br>@ResponseBody<br>public void save12(User user) {<br>    System.out.println(user);<br>}</p>
<h3 id="2-4-获得数组类型参数"><a href="#2-4-获得数组类型参数" class="headerlink" title="2.4 获得数组类型参数"></a>2.4 获得数组类型参数</h3><p>Controller 中的业务方法数组名称与请求参数的 name 一致，参数值会自动映射匹配。</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/user/quick11?strs=111&amp;strs=222&amp;strs=333">http://localhost:8080/user/quick11?strs=111&amp;strs=222&amp;strs=333</a></p>
<p>@RequestMapping(value = “/quick13”)<br>@ResponseBody<br>public void save13(String[] strs) {<br>    System.out.println(Arrays.asList(strs));<br>}</p>
<h3 id="2-5-获得集合类型参数"><a href="#2-5-获得集合类型参数" class="headerlink" title="2.5 获得集合类型参数"></a>2.5 获得集合类型参数</h3><p>获得集合参数时，要将集合参数包装到一个 POJO 中才可以。</p>
<p>public class Vo(){<br>    private List<User> userList;<br>    //get和set方法，重写toString</p>
<p>}</p>
<form action="${pageContext.request.contextPath}/user/quick14" method="post">
    <%--表明是第几个User对象的username age--%>
    <input type="text" name =  "userList[0].username"><br/>
    <input type="text" name =  "userList[0].age"><br/>
    <input type="text" name =  "userList[1].username"><br/>
    <input type="text" name =  "userList[1].age"><br/>
    <input type="submit" value="提交">
</form>

<p>@RequestMapping(value = “/quick14”)<br>@ResponseBody<br>public void save14(VO vo) {<br>    System.out.println(vo);<br>}<br>当使用 ajax 提交时，可以指定 contentType 为 json 形式，那么在方法参数位置使用 @RequestBody 可以<br>直接接收集合数据而无需使用 POJO 进行包装。</p>
<script src="${pageContext.request.contextPath}/js/jquery-3.3.1.js"></script>
<script>
    var userList = new Array();
    userList.push({username: "zhangsan", age: 18});
    userList.push({username: "lisi", age: 28});
$.ajax({
    type: "POST",
    url: "${pageContext.request.contextPath}/user/quick15",
    data: JSON.stringify(userList),
    contextType: "application/json;charset=utf-8"
});
</script>
<p>当使用 ajax 提交时，可以指定 contentType 为 json 形式，那么在方法参数位置使用 @RequestBody 可以<br>直接接收集合数据而无需使用 POJO 进行包装。]</p>
<p>@RequestMapping(value = “/quick15”)<br>@ResponseBody<br>public void save15(@RequestBody List<User> userList) {<br>    System.out.println(userList);<br>}<br>注意：通过谷歌开发者工具抓包发现，没有加载到 jquery 文件，原因是 SpringMVC 的前端控制器 DispatcherServlet 的 url-pattern 配置的是 /, 代表对所有的资源都进行过滤操作，我们可以通过以下两种<br>方式指定放行静态资源：<br>● 在 spring-mvc.xml 配置文件中指定放行的资源</p>
<p>&lt;mvc:resources mapping=”/js/**” location=”/js/“/&gt;<br>● 使用 <a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a> 标签</p>
<h3 id="2-6-请求数据乱码问题"><a href="#2-6-请求数据乱码问题" class="headerlink" title="2.6 请求数据乱码问题"></a>2.6 请求数据乱码问题</h3><p>当 post 请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p>
<!--配置全局过滤的filter-->
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

<h3 id="2-7-参数绑定注解-requestParam"><a href="#2-7-参数绑定注解-requestParam" class="headerlink" title="2.7 参数绑定注解 @requestParam"></a>2.7 参数绑定注解 @requestParam</h3><p>当请求的参数名称与 Controller 的业务方法参数名称不一致时，就需要通过 @RequestParam 注解显示的绑定。</p>
<p>@RequestMapping(value = “/quick16”)<br>@ResponseBody<br>public void save16(@RequestParam(“name”) String username) {<br>    System.out.println(username);<br>}<br>注解 @RequestParam 还有如下参数可以使用：<br>● value：与请求参数名称<br>● required：此在指定的请求参数是否必须包括，默认是 true，提交时如果没有此参数则报错<br>● defaultValue：当没有指定请求参数时，则使用指定的默认值赋值</p>
<p>@RequestMapping(value = “/quick16”)<br>@ResponseBody<br>public void save16(@RequestParam(value = “name”, required = false, defaultValue = “itcast”) String username) {<br>    System.out.println(username);<br>}</p>
<h3 id="2-8-获得-Restful-风格的参数"><a href="#2-8-获得-Restful-风格的参数" class="headerlink" title="2.8 获得 Restful 风格的参数"></a>2.8 获得 Restful 风格的参数</h3><p>Restful 是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p>
<p>Restful 风格的请求是使用 “url + 请求方式” 表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：<br>● GET：用于获取资源<br>● POST：用于新建资源<br>● PUT：用于更新资源<br>● DELETE：用于删除资源</p>
<p>例如：<br>● /user/1 GET ： 得到 id = 1 的 user<br>● /user/1 DELETE： 删除 id = 1 的 user<br>● /user/1 PUT： 更新 id = 1 的 user<br>● /user POST： 新增 user</p>
<p>上述 url 地址 /user/1 中的 1 就是要获得的请求参数，在 SpringMVC 中可以使用占位符进行参数绑定。地址 /user/1 可以写成 /user/{id}，占位符 {id} 对应的就是 1 的值。在业务方法中我们可以使用 @PathVariable 注解进行占位符的匹配获取工作。</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/user/quick17/zhangsan">http://localhost:8080/user/quick17/zhangsan</a></p>
<p>@RequestMapping(value = “/quick17/{name}”)<br>@ResponseBody<br>public void save17(@PathVariable (value = “name”) String username) {<br>    System.out.println(username);<br>}</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212340500.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-9-自定义类型转换器"><a href="#2-9-自定义类型转换器" class="headerlink" title="2.9 自定义类型转换器"></a>2.9 自定义类型转换器</h3><p>● SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成 int 型进行参数设置。<br>● 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</p>
<p>自定义类型转换器的开发步骤：<br>① 定义转换器类实现 Converter 接口<br>② 在配置文件中声明转换器<br>③ 在中引用转换器</p>
<p>① 定义转换器类实现 Converter 接口</p>
<p>public class DataConverter implements Converter&lt;String, Date&gt; {<br>    @Override<br>    public Date convert(String dateStr) {<br>        //将日期字符串转换成日期对象返回<br>        SimpleDateFormat format = new SimpleDateFormat(“yyyy-MM-dd”);<br>        Date date = null;<br>        try {<br>            date = format.parse(dateStr);<br>        } catch (ParseException e) {<br>            e.printStackTrace();<br>        }<br>        return date;<br>    }<br>}<br>② 在配置文件中声明转换器</p>
<!--声明转换器-->
<bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <list>
            <bean class="com.itheima.converter.DataConverter"></bean>
        </list>
    </property>
</bean>
③ 在 <annotation-driven> 中引用转换器

<!--mvc的注解驱动-->
<p>&lt;mvc:annotation-driven conversion-service=”conversionService”&gt;</mvc:annotation-driven></p>
<h3 id="2-10-获得-Servlet-相关-API"><a href="#2-10-获得-Servlet-相关-API" class="headerlink" title="2.10 获得 Servlet 相关 API"></a>2.10 获得 Servlet 相关 API</h3><p>SpringMVC 支持使用原始 ServletAPI 对象作为控制器方法的参数进行注入，常用的对象如下：<br>● HttpServletRequest<br>● HttpServletResponse<br>● HttpSession</p>
<p>@RequestMapping(value = “/quick19”)<br>@ResponseBody<br>public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) {<br>    System.out.println(request);<br>    System.out.println(response);<br>    System.out.println(session);<br>}<br>输出：</p>
<p>org.apache.catalina.connector.RequestFacade@143935e<br>org.apache.catalina.connector.ResponseFacade@14ac0c3<br>org.apache.catalina.session.StandardSessionFacade@1daa35e<br>这里输出的是 catalina，等价于这里生成的三个对象是 tomcat 原生产生的，然后传给 springmvc 框架，调用方法时引用传递给参数。</p>
<h3 id="2-11-获得请求头"><a href="#2-11-获得请求头" class="headerlink" title="2.11 获得请求头"></a>2.11 获得请求头</h3><p>（1）@RequestHeader</p>
<p>使用 @RequestHeader 可以获得请求头信息，相当于 web 阶段学习的 request.getHeader (name)<br>@RequestHeader 注解的属性如下：<br>● value：请求头的名称<br>● required：是否必须携带此请求头</p>
<p>@RequestMapping(value = “/quick20”)<br>@ResponseBody<br>public void save20(@RequestHeader(value = “User-Agent”,required = false) String user_agent) {<br>    System.out.println(user_agent);<br>}<br>（2）@CookieValue</p>
<p>使用 @CookieValue 可以获得指定 Cookie 的值<br>@CookieValue 注解的属性如下：<br>● value：指定 cookie 的名称<br>● required：是否必须携带此 cookie</p>
<p>@RequestMapping(value = “/quick21”)<br>@ResponseBody<br>public void save21(@CookieValue(value = “JSESSIONID”,required = false) String jsessionId) {<br>    System.out.println(jsessionId);<br>}</p>
<h3 id="2-12-文件上传"><a href="#2-12-文件上传" class="headerlink" title="2.12 文件上传"></a>2.12 文件上传</h3><p>（1）文件上传客户端三要素<br>● 表单项 type=“file”<br>● 表单的提交方式是 post<br>● 表单的 enctype 属性是多部分表单形式，及 enctype=“multipart/form-data”</p>
<form action="${pageContext.request.contextPath}/user/quick22" method="post" enctype="multipart/form-data">
    名称：<input type="text" name="username"><br/>
    文件：<input type="file" name="uploadFile"><br/>
    <input type="submit" value="提交">
</form>
![在这里插入图片描述](https://gitee.com/an-menghe/img/raw/master/test/202202212349096.png)

<p>（2）文件上传原理<br>● 当 form 表单修改为多部分表单时，request.getParameter () 将失效。<br>● enctype=“application/x-www-form-urlencoded” 时，form 表单的正文内容格式是：<br>key=value&amp;key=value&amp;key=value<br>● 当 form 表单的 enctype 取值为 Mutilpart/form-data 时，请求正文内容就变成多部分形式：</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212349938.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-13-单文件上传步骤"><a href="#2-13-单文件上传步骤" class="headerlink" title="2.13 单文件上传步骤"></a>2.13 单文件上传步骤</h3><p>① 导入 fileupload 和 io 坐标<br>② 配置文件上传解析器<br>③ 编写文件上传代码</p>
<h3 id="2-14-单文件上传实现"><a href="#2-14-单文件上传实现" class="headerlink" title="2.14 单文件上传实现"></a>2.14 单文件上传实现</h3><p>① 导入 fileupload 和 io 坐标</p>
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.1</version>
</dependency>
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.3</version>
</dependency>
② 配置文件上传解析器

<!--配置文件上传解析器-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <!--上传文件的编码类型-->
    <property name="defaultEncoding" value="UTF-8"></property>
    <!--上传文件的总大小-->
    <property name="maxUploadSize" value="5242800"></property>
    <!--上传单个文件的大小-->
    <property name="maxUploadSizePerFile" value="5242800"></property>
</bean>
③ 编写文件上传代码

<p>@RequestMapping(value = “/quick22”)<br>@ResponseBody<br>public void save22(String username, MultipartFile uploadFile) throws IOException {<br>    System.out.println(username);<br>    //获得上传文件的名称<br>    String originalFilename = uploadFile.getOriginalFilename();<br>    uploadFile.transferTo(new File(“E:\图片\“ + originalFilename));<br>}</p>
<h3 id="2-15-多文件上传实现"><a href="#2-15-多文件上传实现" class="headerlink" title="2.15 多文件上传实现"></a>2.15 多文件上传实现</h3><p>多文件上传，只需要将页面修改为多个文件上传项，将方法参数 MultipartFile 类型修改为 MultipartFile [] 即可</p>
<form action="${pageContext.request.contextPath}/user/quick23" method="post" enctype="multipart/form-data">
    名称：<input type="text" name="username"><br/>
    文件1：<input type="file" name="uploadFile"><br/>
    文件2：<input type="file" name="uploadFile"><br/>
    文件3：<input type="file" name="uploadFile"><br/>
    <input type="submit" value="提交">
</form>
@RequestMapping(value = "/quick23")
@ResponseBody
public void save23(String username, MultipartFile[] uploadFile) throws IOException {
    System.out.println(username);
    for (MultipartFile multipartFile : uploadFile) {
        String originalFilename = multipartFile.getOriginalFilename();
        multipartFile.transferTo(new File("E:\\图片\\" + originalFilename));
    }
}

<h3 id="2-16-知识要点"><a href="#2-16-知识要点" class="headerlink" title="2.16 知识要点"></a>2.16 知识要点</h3><p>MVC 实现数据请求方式<br>● 基本类型参数<br>● POJO 类型参数<br>● 数组类型参数<br>● 集合类型参数</p>
<p>MVC 获取数据细节<br>● 中文乱码问题<br>● @RequestParam 和 @PathVariable<br>● 自定义类型转换器<br>● 获得 Servlet 相关 API<br>● @RequestHeader 和 @CookieValue<br>● 文件上传</p>
<h1 id="第五章-JdbcTemplate"><a href="#第五章-JdbcTemplate" class="headerlink" title="第五章 JdbcTemplate"></a>第五章 JdbcTemplate</h1><h2 id="1-Spring-JdbcTemplate-基本使用"><a href="#1-Spring-JdbcTemplate-基本使用" class="headerlink" title="1.Spring JdbcTemplate 基本使用"></a>1.Spring JdbcTemplate 基本使用</h2><h3 id="1-1-JdbcTemplate-概述"><a href="#1-1-JdbcTemplate-概述" class="headerlink" title="1.1 JdbcTemplate 概述"></a>1.1 JdbcTemplate 概述</h3><p>它是 spring 框架中提供的一个对象，是对原始繁琐的 Jdbc API 对象的简单封装。spring 框架为我们提供了很多的操作模板类。例如：操作关系型数据的 JdbcTemplate 和 HibernateTemplate，操作 nosql 数据库的 RedisTemplate，操作消息队列的 JmsTemplate 等等。</p>
<h3 id="1-2-JdbcTemplate-开发步骤"><a href="#1-2-JdbcTemplate-开发步骤" class="headerlink" title="1.2 JdbcTemplate 开发步骤"></a>1.2 JdbcTemplate 开发步骤</h3><p>① 导入 spring-jdbc 和 spring-tx 坐标<br>② 创建数据库表和实体<br>③ 创建 JdbcTemplate 对象<br>④ 执行数据库操作</p>
<h3 id="1-3-JdbcTemplate-快速入门"><a href="#1-3-JdbcTemplate-快速入门" class="headerlink" title="1.3 JdbcTemplate 快速入门"></a>1.3 JdbcTemplate 快速入门</h3><p>① 导入坐标</p>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>5.0.5.RELEASE</version>
</dependency>
② 创建 accout 表和 Accout 实体

<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202212354675.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>③ 创建 JdbcTemplate 对象<br>④ 执行数据库操作</p>
<p>//创建数据源对象<br>ComboPooledDataSource dataSource = new ComboPooledDataSource();<br>dataSource.setDriverClass(“com.mysql.jdbc.Driver”);<br>dataSource.setJdbcUrl(“jdbc:mysql://localhost:3306/test”);<br>dataSource.setUser(“root”);<br>dataSource.setPassword(“”);</p>
<p>JdbcTemplate jdbcTemplate = new JdbcTemplate();<br>//设置数据源对象 知道数据库在哪<br>jdbcTemplate.setDataSource(dataSource);<br>//执行操作<br>int row = jdbcTemplate.update(“insert into account values(?,?)”, “tom”, 5000);<br>System.out.println(row);</p>
<h3 id="1-4-Spring-产生-JdbcTemplate-对象"><a href="#1-4-Spring-产生-JdbcTemplate-对象" class="headerlink" title="1.4 Spring 产生 JdbcTemplate 对象"></a>1.4 Spring 产生 JdbcTemplate 对象</h3><p>我们可以将 JdbcTemplate 的创建权交给 Spring，将数据源 DataSource 的创建权也交给 Spring，在 Spring 容器内部将数据源 DataSource 注入到 JdbcTemplate 模版对象中，配置如下：</p>
<p>jdbc.properties：</p>
<p>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/test<br>jdbc.username=root<br>jdbc.password=root</p>
<!--加载jdbc.properties-->
<p>&lt;context:property-placeholder location=”jdbc.properties”&gt;</context:property-placeholder></p>
<!--数据源对象-->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}"></property>
    <property name="jdbcUrl" value="${jdbc.url}"></property>
    <property name="user" value="${jdbc.username}"></property>
    <property name="password" value="${jdbc.password}"></property>
</bean>

<!--jdbc模板对象-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="dataSource"></property>
</bean>

<p>从容器中获得 JdbcTemplate 进行添加操作</p>
<p>@Test<br>//测试Spring产生JdbcTemplate对象<br>public void test2() {<br>    ApplicationContext app = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>    JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class);<br>    int row = jdbcTemplate.update(“insert into account values(?,?)”, “zhangsan”, 5000);<br>    System.out.println(row);<br>}</p>
<h3 id="1-5-JdbcTemplate-的常用操作"><a href="#1-5-JdbcTemplate-的常用操作" class="headerlink" title="1.5 JdbcTemplate 的常用操作"></a>1.5 JdbcTemplate 的常用操作</h3><p>修改操作</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class JdbcTemplateCRUDTest {<br>     @Autowired<br>     JdbcTemplate jdbcTemplate;</p>
<pre><code> @Test
 public void testUpdate() &#123;
      jdbcTemplate.update(&quot;update account set money=? where name=?&quot;, 10000, &quot;tom&quot;);
 &#125;
</code></pre>
<p>}<br>删除和查询全部操作</p>
<p>@Test<br>public void testDelete() {<br>    jdbcTemplate.update(“delete from account where name=?”, “tom”);<br>}</p>
<p>@Test<br>public void testQueryAll(){</p>
<pre><code>//new BeanPropertyRowMapper&lt;封装的实体类&gt;

List&lt;Account&gt; accountList = jdbcTemplate.query(&quot;select* from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class));
System.out.println(accountList);
</code></pre>
<p>}<br>查询单个数据操作操作</p>
<p>@Test<br>//测试查询单个对象操作<br>public void testQueryOne(){<br>    Account account = jdbcTemplate.queryForObject(“select * from account where name=?”, new BeanPropertyRowMapper<Account>(Account.class), “tom”);<br>    System.out.println(account);<br>}</p>
<p>@Test<br>//测试查询单个简单数据操作(聚合查询)<br>public void testQueryCount(){<br>    Long count = jdbcTemplate.queryForObject(“select count(*) from account”, Long.class);<br>    System.out.println(count);<br>}</p>
<h3 id="1-6-知识要点-1"><a href="#1-6-知识要点-1" class="headerlink" title="1.6 知识要点"></a>1.6 知识要点</h3><p>① 导入 spring-jdbc 和 spring-tx 坐标<br>② 创建数据库表和实体<br>③ 创建 JdbcTemplate 对象</p>
<p>JdbcTemplate jdbcTemplate = new JdbcTemplate();<br>jdbcTemplate.setDataSource(dataSource);</p>
<p>④ 执行数据库操作</p>
<p>更新操作：<br>jdbcTemplate.update (sql,params)<br>查询操作：<br>jdbcTemplate.query (sql,Mapper,params)<br>jdbcTemplate.queryForObject(sql,Mapper,params)</p>
<h1 id="第六章-Spring-练习"><a href="#第六章-Spring-练习" class="headerlink" title="第六章 Spring 练习"></a>第六章 Spring 练习</h1><h2 id="1-Spring-练习环境搭建"><a href="#1-Spring-练习环境搭建" class="headerlink" title="1.Spring 练习环境搭建"></a>1.Spring 练习环境搭建</h2><h3 id="1-1-Spring-环境搭建步骤"><a href="#1-1-Spring-环境搭建步骤" class="headerlink" title="1.1 Spring 环境搭建步骤"></a>1.1 Spring 环境搭建步骤</h3><p>① 创建工程（Project&amp;Module）<br>② 导入静态页面（见资料 jsp 页面）<br>③ 导入需要坐标（见资料中的 pom.xml）<br>④ 创建包结构（controller、service、dao、domain、utils）<br>⑤ 导入数据库脚本（见资料 test.sql）<br>⑥ 创建 POJO 类（见资料 User.java 和 Role.java）<br>⑦ 创建配置文件（applicationContext.xml、spring-mvc.xml、jdbc.properties、log4j.properties）</p>
<p>web.xml</p>
<!--全局的初始化参数-->
<!--Spring集成Web环境的配置-->
<context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>classpath:applicationContext.xml</param-value>
</context-param>

<!--Spring的监听器-->
<!--Spring集成Web环境的配置-->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>



<!--SpringMVC的前端控制器-->
<servlet>
  <servlet-name>DispatcherServlet</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  <init-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring-mvc.xml</param-value>
  </init-param>
  <load-on-startup>2</load-on-startup>
</servlet>

<servlet-mapping>
  <servlet-name>DispatcherServlet</servlet-name>
  <url-pattern>/</url-pattern>
</servlet-mapping>
spring-mvc.xml

<!--1、mvc注解驱动-->
<p><a href="mvc:annotation-driven/">mvc:annotation-driven/</a></p>
<!--2、配置视图解析器-->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/pages/"></property>
    <property name="suffix" value=".jsp"></property>
</bean>

<!--3、静态资源权限开放-->
<p><a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a><br>applicationContext.xml</p>
<!--1、加载jdbc.properties-->
<p>&lt;context:property-placeholder location=”jdbc.properties”&gt;</context:property-placeholder></p>
<!--2、配置数据源对象-->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}"></property>
    <property name="jdbcUrl" value="${jdbc.url}"></property>
    <property name="user" value="${jdbc.username}"></property>
    <property name="password" value="${jdbc.password}"></property>
</bean>

<!--3、配置JdbcTemplate对象-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="dataSource"></property>
</bean>

<h3 id="1-2-用户和角色的关系"><a href="#1-2-用户和角色的关系" class="headerlink" title="1.2 用户和角色的关系"></a>1.2 用户和角色的关系</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220004746.png" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220004414.png" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="2-角色列表的展示和添加操作"><a href="#2-角色列表的展示和添加操作" class="headerlink" title="2.角色列表的展示和添加操作"></a>2.角色列表的展示和添加操作</h2><h3 id="2-1-角色列表的展示效果"><a href="#2-1-角色列表的展示效果" class="headerlink" title="2.1 角色列表的展示效果"></a>2.1 角色列表的展示效果</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220006201.png" alt="img"></p>
</blockquote>
<p>2.2 角色列表的展示步骤分析<br>① 点击角色管理菜单发送请求到服务器端（修改角色管理菜单的 url 地址）<br>② 创建 RoleController 和 showList () 方法<br>③ 创建 RoleService 和 showList () 方法<br>④ 创建 RoleDao 和 findAll () 方法<br>⑤ 使用 JdbcTemplate 完成查询操作<br>⑥ 将查询数据存储到 Model 中</p>
<p>导入 c 命名 &lt;%@ taglib prefix=”c” uri=”<a target="_blank" rel="noopener" href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</p>
<p>使用</p>
<blockquote>
<p>&lt;c:forEach items=”” var=””&gt;</p>
<tr>
<td>${}</td>
<td>${}</td>
<td>${}</td>
<td>${}</td>
<td>${}</td>
<td>${}</td>
</tr>
</c:forEach>
⑦ 转发到 role-list.jsp 页面进行展示
</blockquote>
<h2 id="2-3-角色添加的效果"><a href="#2-3-角色添加的效果" class="headerlink" title="2.3 角色添加的效果"></a>2.3 角色添加的效果</h2><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220014241.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="2-4-角色添加的步骤分析"><a href="#2-4-角色添加的步骤分析" class="headerlink" title="2.4 角色添加的步骤分析"></a>2.4 角色添加的步骤分析</h3><p>① 点击列表页面新建按钮跳转到角色添加页面<br>② 输入角色信息，点击保存按钮，表单数据提交服务器<br>③ 编写 RoleController 的 save () 方法<br>④ 编写 RoleService 的 save () 方法<br>⑤ 编写 RoleDao 的 save () 方法<br>⑥ 使用 JdbcTemplate 保存 Role 数据到 sys_role<br>⑦ 跳转回角色列表页面</p>
<h2 id="3-用户列表的展示和添加操作"><a href="#3-用户列表的展示和添加操作" class="headerlink" title="3.用户列表的展示和添加操作"></a>3.用户列表的展示和添加操作</h2><h3 id="3-1-用户列表的展示效果"><a href="#3-1-用户列表的展示效果" class="headerlink" title="3.1 用户列表的展示效果"></a>3.1 用户列表的展示效果</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220016093.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-2-用户列表的展示步骤分析"><a href="#3-2-用户列表的展示步骤分析" class="headerlink" title="3.2 用户列表的展示步骤分析"></a>3.2 用户列表的展示步骤分析</h3><p>① 点击用户管理菜单发送请求到服务器端（修改用户管理菜单的 url 地址）<br>② 创建 RoleController 和 showList () 方法<br>③ 创建 RoleService 和 showList () 方法<br>④ 创建 RoleDao 和 findAll () 方法<br>⑤ 使用 JdbcTemplate 完成查询操作<br>⑥ 将查询数据存储到 Model 中<br>⑦ 转发到 user-list.jsp 页面进行展示</p>
<h3 id="3-3-用户添加的效果"><a href="#3-3-用户添加的效果" class="headerlink" title="3.3 用户添加的效果"></a>3.3 用户添加的效果</h3><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220017546.png" alt="在这里插入图片描述"></p>
<h3 id="3-4-用户添加的步骤分析"><a href="#3-4-用户添加的步骤分析" class="headerlink" title="3.4 用户添加的步骤分析"></a>3.4 用户添加的步骤分析</h3><p>① 点击列表页面新建按钮（访问 /saveUI）跳转到角色添加页面</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220024232.png" alt="image-20220222002415111"></p>
</blockquote>
<p>方法查询了角色表，并返回视图和数据</p>
<p>导入 c 命名 &lt;%@ taglib prefix=”c” uri=”<a target="_blank" rel="noopener" href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</p>
<p>使用</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220025167.png" alt="image-20220222002551029"></p>
<p>② 输入角色信息，点击保存按钮，表单数据提交服务器<br>③ 编写 RoleController 的 save () 方法</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220027507.png" alt="image-20220222002758440"></p>
<p>④ 编写 RoleService 的 save () 方法</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220027806.png" alt="image-20220222002718739"></p>
<p>⑤ 编写 RoleDao 的 save () 方法</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220028389.png" alt="image-20220222002855258"></p>
<p>因为数据库的主键是递增的无法第一时间获取 userId，运行会报错，所以这里的解决办法是（学习 Mybatishou, 就特别好解决 ，这里的解决方法只做了解）</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220032096.png" alt="image-20220222003212971"></p>
<p>⑥ 使用 JdbcTemplate 保存 Role 数据到 sys_role<br>⑦ 跳转回角色列表页面</p>
<h2 id="4-删除用户操作"><a href="#4-删除用户操作" class="headerlink" title="4.删除用户操作"></a>4.删除用户操作</h2><h3 id="4-1-删除用户的效果"><a href="#4-1-删除用户的效果" class="headerlink" title="4.1 删除用户的效果"></a>4.1 删除用户的效果</h3><h3 id="4-2-删除用户的步骤分析"><a href="#4-2-删除用户的步骤分析" class="headerlink" title="4.2 删除用户的步骤分析"></a>4.2 删除用户的步骤分析</h3><p>① 点击用户列表的删除按钮，发送请求到服务器端<br>② 编写 UserController 的 deleteById () 方法<br>③ 编写 UserService 的 deleteById () 方法<br>④ 编写 UserDao 的 deleteById () 方法<br>⑤ 编写 UserDao 的 deleteRelByUid () 方法<br>⑥ 跳回当前用户列表页面</p>
<h1 id="第七章-SpringMVC-拦截器"><a href="#第七章-SpringMVC-拦截器" class="headerlink" title="第七章 SpringMVC 拦截器"></a>第七章 SpringMVC 拦截器</h1><h2 id="1-SpringMVC-拦截器"><a href="#1-SpringMVC-拦截器" class="headerlink" title="1.SpringMVC 拦截器"></a>1.SpringMVC 拦截器</h2><h3 id="1-1-拦截器（interceptor）的作用"><a href="#1-1-拦截器（interceptor）的作用" class="headerlink" title="1.1 拦截器（interceptor）的作用"></a>1.1 拦截器（interceptor）的作用</h3><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p>
<p>将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是 AOP 思想的具体实现。</p>
<h3 id="1-2-拦截器和过滤器区别"><a href="#1-2-拦截器和过滤器区别" class="headerlink" title="1.2 拦截器和过滤器区别"></a>1.2 拦截器和过滤器区别</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220035906.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-3-拦截器的快速入门"><a href="#1-3-拦截器的快速入门" class="headerlink" title="1.3 拦截器的快速入门"></a>1.3 拦截器的快速入门</h3><p>自定义拦截器很简单，只有如下三步：<br>① 创建拦截器类实现 HandlerInterceptor 接口<br>② 配置拦截器<br>③ 测试拦截器的拦截效果</p>
<p>① 创建拦截器类实现 HandlerInterceptor 接口</p>
<p>public class MyInterceptor1 implements HandlerInterceptor {<br>    //在目标方法执行之前 执行<br>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {<br>        System.out.println(“preHandle…..”);<br>        //设置true 表示放行<br>        return true;<br>    }<br>    //在目标方法执行之后 视图对象返回之前执行<br>    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {<br>        System.out.println(“postHandle…”);<br>    }<br>    //在流程都执行完毕后 执行<br>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {<br>        System.out.println(“afterCompletion….”);<br>    }<br>}<br>② 配置拦截器</p>
<!--配置拦截器-->
<p><a href="mvc:interceptors">mvc:interceptors</a><br>    <a href="mvc:interceptor">mvc:interceptor</a><br>        <!--对哪些资源进行拦截操作  (这里是所有)--><br>        &lt;mvc:mapping path=”/**”/&gt;<br>        <bean class="com.itheima.interceptor.MyInterceptor1"></bean><br>    </mvc:interceptor><br></mvc:interceptors></p>
<p>③ 测试拦截器的拦截效果（编写目标方法）</p>
<p>@Controller<br>public class TargetController {<br>    @RequestMapping(“/target”)<br>    public ModelAndView show(){<br>        System.out.println(“目标资源执行……”);<br>        ModelAndView modelAndView = new ModelAndView();<br>        modelAndView.addObject(“name”,”itcast”);<br>        modelAndView.setViewName(“index”);<br>        return modelAndView;<br>    }<br>}<br>访问网址：<a target="_blank" rel="noopener" href="http://localhost:8080/target">http://localhost:8080/target</a><br>控制台打印结果</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220037230.png" alt="img"></p>
<h3 id="1-4-多拦截器操作"><a href="#1-4-多拦截器操作" class="headerlink" title="1.4 多拦截器操作"></a>1.4 多拦截器操作</h3><p>同上，再编写一个 MyHandlerInterceptor2 操作，测试执行顺序</p>
<p>public class MyInterceptor2 implements HandlerInterceptor {<br>    //在目标方法执行之前 执行<br>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {<br>        System.out.println(“preHandle2222…..”);<br>        return true;<br>    }<br>    //在目标方法执行之后 视图对象返回之前执行<br>    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {<br>        modelAndView.addObject(“name”,”itheima”);<br>        System.out.println(“postHandle2222…”);<br>    }<br>    //在流程都执行完毕后 执行<br>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {<br>        System.out.println(“afterCompletion2222….”);<br>    }<br>}</p>
<!--配置拦截器-->
<p><a href="mvc:interceptors">mvc:interceptors</a><br>    <a href="mvc:interceptor">mvc:interceptor</a><br>        <!--对哪些资源进行拦截操作--><br>        &lt;mvc:mapping path=”/**”/&gt;<br>        <bean class="com.itheima.interceptor.MyInterceptor1"></bean><br>    </mvc:interceptor><br>    <a href="mvc:interceptor">mvc:interceptor</a><br>        <!--对哪些资源进行拦截操作--><br>        &lt;mvc:mapping path=”/**”/&gt;<br>        <bean class="com.itheima.interceptor.MyInterceptor2"></bean><br>    </mvc:interceptor><br></mvc:interceptors><br>输出结果：(拦截顺序 与 配置拦截器的前后位置有关，，，遵循前进后出原则)</p>
<p>preHandle…..<br>preHandle2222…..<br>目标资源执行……<br>postHandle2222…<br>postHandle…<br>afterCompletion2222….<br>afterCompletion….</p>
<h3 id="1-5-拦截器方法说明"><a href="#1-5-拦截器方法说明" class="headerlink" title="1.5 拦截器方法说明"></a>1.5 拦截器方法说明</h3><blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220041752.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-6-知识要点-2"><a href="#1-6-知识要点-2" class="headerlink" title="1.6 知识要点"></a>1.6 知识要点</h3><p>自定义拦截器步骤<br>① 创建拦截器类实现 HandlerInterceptor 接口<br>② 配置拦截器<br>③ 测试拦截器的拦截效果</p>
<h3 id="1-7-案例-用户登录权限控制"><a href="#1-7-案例-用户登录权限控制" class="headerlink" title="1.7 案例 - 用户登录权限控制"></a>1.7 案例 - 用户登录权限控制</h3><p>需求：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作</p>
<p>1—- 需要放行登录请求路径</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220045115.png" alt="image-20220222004554024"></p>
<p>2—- 登录的用户，会在 HttpSession session 中放一个 key 值为 user</p>
<p>3—- 根据 HttpSession session 的 session.getAttribute (“user”) 是否为空值 ，来进行放行</p>
<p> 为 null ,return false 拦截，并重定向到登录页面</p>
<p> 不为空，,return true 放行 正常跳转</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202220055379.png" alt="在这里插入图片描述"></p>
<h1 id="第八章-SpringMVC-异常处理机制"><a href="#第八章-SpringMVC-异常处理机制" class="headerlink" title="第八章 SpringMVC 异常处理机制"></a>第八章 SpringMVC 异常处理机制</h1><h2 id="1-SpringMVC-异常处理"><a href="#1-SpringMVC-异常处理" class="headerlink" title="1.SpringMVC 异常处理"></a>1.SpringMVC 异常处理</h2><h3 id="1-1-异常处理的思路"><a href="#1-1-异常处理的思路" class="headerlink" title="1.1 异常处理的思路"></a>1.1 异常处理的思路</h3><p>系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p>
<p>系统的 Dao、Service、Controller 出现都通过 throws Exception 向上抛出，最后由 SpringMVC 前端控制器交由异常处理器进行异常处理，如下图：</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221121080.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-2-异常处理两种方式"><a href="#1-2-异常处理两种方式" class="headerlink" title="1.2 异常处理两种方式"></a>1.2 异常处理两种方式</h3><p>● 使用 Spring MVC 提供的简单异常处理器 SimpleMappingExceptionResolver<br>● 实现 Spring 的异常处理接口 HandlerExceptionResolver 自定义自己的异常处理器</p>
<h3 id="1-3-简单异常处理器-SimpleMappingExceptionResolver"><a href="#1-3-简单异常处理器-SimpleMappingExceptionResolver" class="headerlink" title="1.3 简单异常处理器 SimpleMappingExceptionResolver"></a>1.3 简单异常处理器 SimpleMappingExceptionResolver</h3><p>SpringMVC 已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置</p>
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <!--没有其他要求，配这一个就可以-->
    <property name="defaultErrorView" value="error"/>
    <property name="exceptionMappings">

<pre><code>    &lt;map&gt;
        &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error1&quot;/&gt;
        &lt;entry key=&quot;com.itheima.exception.MyException&quot; value=&quot;error2&quot;/&gt;
    &lt;/map&gt;
</code></pre>
<p>​    </property><br></bean></p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221122088.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-4-自定义异常处理步骤"><a href="#1-4-自定义异常处理步骤" class="headerlink" title="1.4 自定义异常处理步骤"></a>1.4 自定义异常处理步骤</h3><p>① 创建异常处理器类实现 HandlerExceptionResolver<br>② 配置异常处理器<br>③ 编写异常页面<br>④ 测试异常跳转</p>
<p>① 创建异常处理器类实现 HandlerExceptionResolver</p>
<p>public class MyExceptionResolver implements HandlerExceptionResolver {<br>    /*<br>       参数Exception：异常对象<br>       返回值ModelAndView：跳转到错误视图信息<br>    */<br>    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {<br>        ModelAndView modelAndView = new ModelAndView();<br>        if (e instanceof MyException) {<br>            modelAndView.addObject(“info”, “自定义异常”);<br>        } else if (e instanceof ClassCastException) {<br>            modelAndView.addObject(“info”, “类转换异常”);<br>        }<br>        modelAndView.setViewName(“error”);<br>        return modelAndView;<br>    }<br>}<br>② 配置异常处理器</p>
<!--自定义异常处理器-->
<p><bean class="com.itheima.resolver.MyExceptionResolver"></bean>③ 编写异常页面<br>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p>
<html>

<head>
    <title>Title</title>
</head>

<body>
    
<pre><code>&lt;h1&gt;通用的错误提示页面&lt;/h1&gt;
&lt;h1&gt;$&#123;info&#125;&lt;/h1&gt;
</code></pre>
</body>
</html>
④ 测试异常跳转

<h3 id="1-5-知识要点-1"><a href="#1-5-知识要点-1" class="headerlink" title="1.5 知识要点"></a>1.5 知识要点</h3><p>异常处理方式<br>● 配置简单异常处理器 SimpleMappingExceptionResolver<br>● 自定义异常处理器</p>
<p>自定义异常处理步骤<br>① 创建异常处理器类实现 HandlerExceptionResolver<br>② 配置异常处理器<br>③ 编写异常页面<br>④ 测试异常跳转</p>
<h1 id="第九章-面向切面编程-AOP"><a href="#第九章-面向切面编程-AOP" class="headerlink" title="第九章 面向切面编程 AOP"></a>第九章 面向切面编程 AOP</h1><h2 id="1-Spring-的-AOP-简介"><a href="#1-Spring-的-AOP-简介" class="headerlink" title="1.Spring 的 AOP 简介"></a>1.Spring 的 AOP 简介</h2><h3 id="1-1-什么是-AOP"><a href="#1-1-什么是-AOP" class="headerlink" title="1.1 什么是 AOP"></a>1.1 什么是 AOP</h3><p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>AOP 是 OOP 的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h3 id="1-2-AOP-的作用及其优势"><a href="#1-2-AOP-的作用及其优势" class="headerlink" title="1.2 AOP 的作用及其优势"></a>1.2 AOP 的作用及其优势</h3><p>● 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强<br>● 优势：减少重复代码，提高开发效率，并且便于维护</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221253383.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-AOP-的底层实现"><a href="#1-3-AOP-的底层实现" class="headerlink" title="1.3 AOP 的底层实现"></a>1.3 AOP 的底层实现</h3><p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring 通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p>
<h3 id="1-4-AOP-的动态代理技术"><a href="#1-4-AOP-的动态代理技术" class="headerlink" title="1.4 AOP 的动态代理技术"></a>1.4 AOP 的动态代理技术</h3><p>常用的动态代理技术<br>● JDK 代理：基于接口的动态代理技术<br>● cglib 代理：基于父类的动态代理技术</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221254107.png" alt="在这里插入图片描述"></p>
<h3 id="1-5-JDK-的动态代理"><a href="#1-5-JDK-的动态代理" class="headerlink" title="1.5 JDK 的动态代理"></a>1.5 JDK 的动态代理</h3><p>① 目标类接口</p>
<p>public interface TargetInterface {<br>    public void save();<br>}<br>② 目标类</p>
<p>public class Target implements TargetInterface {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>    }<br>}<br>③ 增强代码</p>
<p>public class Advice {<br>    public void before() {<br>        System.out.println(“前置增强….”);<br>    }<br>    public void afterReturning() {<br>        System.out.println(“后置增强….”);<br>    }<br>}<br>④ 动态代理代码</p>
<p>//目标对象<br>final Target target = new Target();</p>
<p>//增强对象<br>final Advice advice = new Advice();</p>
<p>//返回值 就是动态生成的代理对象<br>TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(<br>        target.getClass().getClassLoader(), //目标对象类加载器<br>        target.getClass().getInterfaces(), //目标对象相同的接口字节码对象数组<br>        new InvocationHandler() {<br>            //调用代理对象的任何方法  实质执行的都是invoke方法<br>            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>                advice.before(); //前置增强<br>                Object invoke = method.invoke(target, args);//执行目标方法<br>                advice.afterReturning(); //后置增强<br>                return invoke;<br>            }<br>        }<br>);<br>⑤ 调用代理对象的方法测试</p>
<p>//调用代理对象的方法<br>proxy.save();<br>输出结果：</p>
<p>前置增强….<br>save running…..</p>
<p>后置增强….</p>
<h3 id="1-6-cglib-的动态代理"><a href="#1-6-cglib-的动态代理" class="headerlink" title="1.6 cglib 的动态代理"></a>1.6 cglib 的动态代理</h3><p>① 目标类</p>
<p>public class Target {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>    }<br>}<br>② 动态代理代码</p>
<p>//目标对象<br>final Target target = new Target();<br>//增强对象<br>final Advice advice = new Advice();<br>//返回值 就是动态生成的代理对象  基于cglib<br>//1、创建增强器<br>Enhancer enhancer = new Enhancer();<br>//2、设置父类（目标）<br>enhancer.setSuperclass(Target.class);<br>//3、设置回调<br>enhancer.setCallback(new MethodInterceptor() {<br>    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {<br>        advice.before(); //执行前置<br>        Object invoke = method.invoke(target, args);//执行目标<br>        advice.afterReturning(); //执行后置<br>        return invoke;<br>    }<br>});<br>//4、创建代理对象<br>Target proxy = (Target) enhancer.create();<br>③ 调用代理对象的方法测试</p>
<p>proxy.save();<br>前置增强….<br>save running…..<br>后置增强….</p>
<h3 id="1-7-AOP-相关概念"><a href="#1-7-AOP-相关概念" class="headerlink" title="1.7 AOP 相关概念"></a>1.7 AOP 相关概念</h3><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p>
<p>在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：<br>● Target（目标对象）：代理的目标对象<br>● Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类<br>● Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在 spring 中，这些点指的是方法，因为 spring 只支持方法类型的连接点。通俗的说，可以被增强的方法叫连接点<br>● Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义<br>● Advice（通知 / 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知<br>● Aspect（切面）：是切入点和通知（引介）的结合<br>● Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入</p>
<h3 id="1-8-AOP-开发明确的事项"><a href="#1-8-AOP-开发明确的事项" class="headerlink" title="1.8 AOP 开发明确的事项"></a>1.8 AOP 开发明确的事项</h3><p>（1）需要编写的内容<br>● 编写核心业务代码（目标类的目标方法）<br>● 编写切面类，切面类中有通知 (增强功能方法)<br>● 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</p>
<p>（2）AOP 技术实现的内容<br>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>
<p>（3）AOP 底层使用哪种代理方式<br>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p>
<h3 id="1-9-知识要点"><a href="#1-9-知识要点" class="headerlink" title="1.9 知识要点"></a>1.9 知识要点</h3><p>● aop：面向切面编程<br>● aop 底层实现：基于 JDK 的动态代理 和 基于 Cglib 的动态代理<br>● aop 的重点概念：<br>Pointcut（切入点）：被增强的方法<br>Advice（通知 / 增强）：封装增强业务逻辑的方法<br>Aspect（切面）：切点 + 通知<br>Weaving（织入）：将切点与通知结合的过程</p>
<p>● 开发明确事项：<br>谁是切点（切点表达式配置）<br>谁是通知（切面类中的增强方法）<br>将切点和通知进行织入配置</p>
<h2 id="2-基于-XML-的-AOP-开发"><a href="#2-基于-XML-的-AOP-开发" class="headerlink" title="2.基于 XML 的 AOP 开发"></a>2.基于 XML 的 AOP 开发</h2><h3 id="2-1-快速入门"><a href="#2-1-快速入门" class="headerlink" title="2.1 快速入门"></a>2.1 快速入门</h3><p>① 导入 AOP 相关坐标<br>② 创建目标接口和目标类（内部有切点）<br>③ 创建切面类（内部有增强方法）<br>④ 将目标类和切面类的对象创建权交给 spring<br>⑤ 在 applicationContext.xml 中配置织入关系<br>⑥ 测试代码</p>
<p>① 导入 AOP 相关坐标</p>
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-context</artifactId>
  <version>5.0.5.RELEASE</version>
</dependency>
<!--AOP织-->
<dependency>
  <groupId>org.aspectj</groupId>
  <artifactId>aspectjweaver</artifactId>
  <version>1.8.4</version>
</dependency>
② 创建目标接口和目标类（内部有切点）

<p>public interface TargetInterface {<br>    public void save();<br>}</p>
<p>public class Target implements TargetInterface {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>    }<br>}<br>③ 创建切面类（内部有增强方法）</p>
<p>public class MyAspect {<br>    public void before(){<br>        System.out.println(“前置增强……….”);<br>    }<br>}<br>④ 将目标类和切面类的对象创建权交给 spring</p>
<!--目标对象-->
<p><bean id="target" class="com.itheima.aop.Target"></bean></p>
<!--切面对象-->
<p><bean id="myAspect" class="com.itheima.aop.MyAspect"></bean><br>⑤ 在 applicationContext.xml 中配置织入关系<br>导入 aop 命名空间</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
"></p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221302641.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>配置切点表达式和前置增强的织入关系</p>
<!--配置织入：告诉spring框架 哪些方法(切点)需要进行哪些增强(前置、后置...)-->
<p><a href="aop:config">aop:config</a><br>    <!--声明切面--><br>    &lt;aop:aspect ref=”myAspect”&gt;<br>        <!--切面：切点+通知--><br>        &lt;aop:before method=”before” pointcut=”execution(public void com.itheima.aop.Target.save())”&gt;                 </aop:before><br>    </aop:aspect><br></aop:config><br>⑥ 测试代码</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class AopTest {<br>    @Autowired<br>    private TargetInterface target;<br>    @Test<br>    public void test1(){<br>        target.save();<br>    }<br>}<br>⑦ 测试结果</p>
<p>前置增强……….<br>save running…..</p>
<h3 id="2-2-XML-配置-AOP-详解"><a href="#2-2-XML-配置-AOP-详解" class="headerlink" title="2.2 XML 配置 AOP 详解"></a>2.2 XML 配置 AOP 详解</h3><p>（1）切点表达式的写法<br>表达式语法：</p>
<p>execution ([修饰符] 返回值类型 包名。类名。方法名 (参数))</p>
<p>● 访问修饰符可以省略<br>● 返回值类型、包名、类名、方法名可以使用星号 * 代表任意<br>● 包名与类名之间一个点。代表当前包下的类，两个点 .. 表示当前包及其子包下的类<br>● 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p>
<p>例如：</p>
<p>execution(public void com.itheima.aop.Target.method())<br>execution(void com.itheima.aop.Target.<em>(..))<br>execution(</em> com.itheima.aop.<em>.</em>(..))<br>execution(* com.itheima.aop..<em>.</em>(..))<br>execution(* <em>..</em>.*(..))<br>（2）通知的类型<br>通知的配置语法：</p>
<p>&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式”&gt;&lt;/aop:通知类型&gt;</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221306661.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>（3）切点表达式的抽取<br>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p>
<p><a href="aop:config">aop:config</a><br>    <!--引用myAspect的Bean为切面对象--><br>    &lt;aop:aspect ref=”myAspect”&gt;<br>        &lt;aop:pointcut id=”myPointcut” expression=”execution(* com.itheima.aop.*.*(..))”/&gt;<br>        &lt;aop:before method=”before” pointcut-ref=”myPointcut”&gt;</aop:before><br>    </aop:aspect></p>
<p></aop:config></p>
<h3 id="2-3-知识要点"><a href="#2-3-知识要点" class="headerlink" title="2.3 知识要点"></a>2.3 知识要点</h3><p>● aop 织入的配置</p>
<p><a href="aop:config">aop:config</a><br>    &lt;aop:aspect ref=“切面类”&gt;<br>        &lt;aop:before method=“通知方法名称” pointcut=“切点表达式”&gt;</aop:before><br>    </aop:aspect><br></aop:config><br>● 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知<br>● 切点表达式的写法：</p>
<p>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</p>
<h2 id="3-基于注解的-AOP-开发"><a href="#3-基于注解的-AOP-开发" class="headerlink" title="3.基于注解的 AOP 开发"></a>3.基于注解的 AOP 开发</h2><h3 id="3-1-快速入门"><a href="#3-1-快速入门" class="headerlink" title="3.1 快速入门"></a>3.1 快速入门</h3><p>基于注解的 aop 开发步骤：<br>① 创建目标接口和目标类（内部有切点）<br>② 创建切面类（内部有增强方法）<br>③ 将目标类和切面类的对象创建权交给 spring<br>④ 在切面类中使用注解配置织入关系<br>⑤ 在配置文件中开启组件扫描和 AOP 的自动代理<br>⑥ 测试</p>
<p>① 创建目标接口和目标类（内部有切点）</p>
<p>public interface TargetInterface {<br>    public void save();<br>}</p>
<p>public class Target implements TargetInterface {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>    }<br>}<br>② 创建切面类（内部有增强方法）</p>
<p>public class MyAspect {<br>    //前置增强方法<br>    public void before(){<br>        System.out.println(“前置增强……….”);<br>    }<br>}<br>③ 将目标类和切面类的对象创建权交给 spring</p>
<p>@Component(“target”)<br>public class Target implements TargetInterface {<br>    public void save() {<br>        System.out.println(“save running…..”);<br>        //int i = 1/0;<br>    }<br>}</p>
<p>@Component(“myAspect”)<br>public class MyAspect {<br>    public void before(){<br>        System.out.println(“前置增强……….”);<br>    }<br>}</p>
<p>④ 在切面类中使用注解配置织入关系</p>
<p>@Component(“myAspect”)<br>@Aspect //标注当前MyAspect是一个切面类<br>public class MyAspect {<br>    //配置前置通知<br>    @Before(“execution(* com.itheima.anno.<em>.</em>(..))”)<br>    public void before(){<br>        System.out.println(“前置增强……….”);<br>    }<br>}</p>
<p>⑤ 在配置文件中开启组件扫描和 AOP 的自动代理</p>
<!--组件扫描-->
<p>&lt;context:component-scan base-package=”com.itheima.anno”&gt;</context:component-scan></p>
<!--aop自动代理-->
<p><a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a></aop:aspectj-autoproxy><br>⑥ 测试代码</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(“classpath:applicationContext-anno.xml”)<br>public class AnnoTest {<br>    @Autowired<br>    private TargetInterface target;</p>
<pre><code>@Test
public void test1()&#123;
     target.save();
&#125;
</code></pre>
<p>}<br>⑦ 测试结果</p>
<p>前置增强……….<br>save running…..</p>
<h3 id="3-2-注解配置-AOP-详解"><a href="#3-2-注解配置-AOP-详解" class="headerlink" title="3.2 注解配置 AOP 详解"></a>3.2 注解配置 AOP 详解</h3><p>（1）注解通知的类型<br>通知的配置语法：@通知注解 (“切点表达式”)</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221318308.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>（2） 切点表达式的抽取<br>同 xml 配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用 @Pointcut 注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p>
<p>@Component(“myAspect”)<br>@Aspect //标注当前MyAspect是一个切面类<br>public class MyAspect {<br>    //Proceeding JoinPoint:  正在执行的连接点===切点<br>    //@Around(“execution(* com.itheima.anno.<em>.</em>(..))”)<br>    @Around(“pointcut()”)<br>    public Object around(ProceedingJoinPoint pjp) throws Throwable {<br>        System.out.println(“环绕前增强….”);<br>        Object proceed = pjp.proceed();//切点方法<br>        System.out.println(“环绕后增强….”);<br>        return proceed;<br>    }<br>    //@After(“execution(* com.itheima.anno.<em>.</em>(..))”)<br>    @After(“MyAspect.pointcut()”)<br>    public void after(){<br>        System.out.println(“最终增强……….”);<br>    }</p>
<pre><code>//定义切点表达式
@Pointcut(&quot;execution(* com.itheima.anno.*.*(..))&quot;)
public void pointcut()&#123;&#125;
</code></pre>
<p>}</p>
<h3 id="3-3-知识要点"><a href="#3-3-知识要点" class="headerlink" title="3.3 知识要点"></a>3.3 知识要点</h3><p>● 注解 aop 开发步骤<br>① 使用 @Aspect 标注切面类<br>② 使用 @通知注解标注通知方法<br>③ 在配置文件中配置 aop 自动代理 <a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a></p>
<p>● 通知注解类型</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221320563.png" alt="在这里插入图片描述"></p>
<h1 id="第十章-声明式事务控制"><a href="#第十章-声明式事务控制" class="headerlink" title="第十章 声明式事务控制"></a>第十章 声明式事务控制</h1><h2 id="1-编程式事务控制相关对象"><a href="#1-编程式事务控制相关对象" class="headerlink" title="1.编程式事务控制相关对象"></a>1.编程式事务控制相关对象</h2><h3 id="1-1-PlatformTransactionManager"><a href="#1-1-PlatformTransactionManager" class="headerlink" title="1.1 PlatformTransactionManager"></a>1.1 PlatformTransactionManager</h3><p>PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221333535.png" alt="img"></p>
</blockquote>
<p>注意：<br>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是 jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager<br>Dao 层技术是 hibernate 时：org.springframework.orm.hibernate5.HibernateTransactionManager</p>
<h3 id="1-2-TransactionDefinition"><a href="#1-2-TransactionDefinition" class="headerlink" title="1.2 TransactionDefinition"></a>1.2 TransactionDefinition</h3><p>TransactionDefinition 是事务的定义信息对象，里面有如下方法：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221334387.png" alt="在这里插入图片描述"></p>
<p>（1）事务隔离级别</p>
<p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。<br>● ISOLATION_DEFAULT<br>● ISOLATION_READ_UNCOMMITTED<br>● ISOLATION_READ_COMMITTED<br>● ISOLATION_REPEATABLE_READ<br>● ISOLATION_SERIALIZABLE</p>
<p>（2）事务传播行为</p>
<p>● REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）<br>● SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）<br>● MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常<br>● REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。<br>● NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起<br>● NEVER：以非事务方式运行，如果当前存在事务，抛出异常<br>● NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作<br>● 超时时间：默认值是 - 1，没有超时限制。如果有，以秒为单位进行设置<br>● 是否只读：建议查询时设置为只读</p>
<h3 id="1-3-TransactionStatus"><a href="#1-3-TransactionStatus" class="headerlink" title="1.3 TransactionStatus"></a>1.3 TransactionStatus</h3><p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。</p>
<blockquote>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221335866.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="1-4-知识要点-1"><a href="#1-4-知识要点-1" class="headerlink" title="1.4 知识要点"></a>1.4 知识要点</h3><p>编程式事务控制三大对象<br>● PlatformTransactionManager<br>● TransactionDefinition<br>● TransactionStatus</p>
<p>平台对象操作事务行为，定义对象设置事务属性，状态对象反馈事务运行过程中的信息。换句话说，状态对象由管理器和事务信息共同决定的。</p>
<h2 id="2-基于-XML-的声明式事务控制"><a href="#2-基于-XML-的声明式事务控制" class="headerlink" title="2.基于 XML 的声明式事务控制"></a>2.基于 XML 的声明式事务控制</h2><h3 id="2-1-什么是声明式事务控制"><a href="#2-1-什么是声明式事务控制" class="headerlink" title="2.1 什么是声明式事务控制"></a>2.1 什么是声明式事务控制</h3><p>Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p>
<p>声明式事务处理的作用<br>● 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可<br>● 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p>
<p>注意：Spring 声明式事务控制底层就是 AOP。业务对象是切点，事务管理是增强 (切面)。</p>
<h3 id="2-2-声明式事务控制的实现"><a href="#2-2-声明式事务控制的实现" class="headerlink" title="2.2 声明式事务控制的实现"></a>2.2 声明式事务控制的实现</h3><p>声明式事务控制明确事项：<br>● 谁是切点？<br>● 谁是通知？<br>● 配置切面？</p>
<p>① 引入 tx 命名空间</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
"><br>② 配置事务增强</p>
<!--配置平台事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <!--配置数据源-->
    <property name="dataSource" ref="dataSource"></property>
</bean>

<!--通知  事务的增强-->
<p>&lt;tx:advice id=”txAdvice” transaction-manager=”transactionManager”&gt;<br>    <!--设置事务的属性信息--><br>    <a href="tx:attributes">tx:attributes</a><br>        &lt;tx:method name=”transfer” isolation=”REPEATABLE_READ” propagation=”REQUIRED” read-only=”false”/&gt;<br>        &lt;tx:method name=”save” isolation=”REPEATABLE_READ” propagation=”REQUIRED” read-only=”false”/&gt;<br>        &lt;tx:method name=”findAll” isolation=”REPEATABLE_READ” propagation=”REQUIRED” read-only=”true”/&gt;<br>        <!--代表update开头的所有方法--><br>        &lt;tx:method name=”update*” isolation=”REPEATABLE_READ” propagation=”REQUIRED” read-only=”true”/&gt;<br>        &lt;tx:method name=”*”/&gt;<br>    </tx:attributes><br></tx:advice><br>③ 配置事务 AOP 织入</p>
<!--配置事务的aop织入-->
<p><a href="aop:config">aop:config</a><br>    &lt;aop:advisor advice-ref=”txAdvice” pointcut=”execution(* com.itheima.service.impl.*.*(..))”&gt;                 </aop:advisor><br></aop:config><br>④ 测试事务控制转账业务代码</p>
<p>@Override<br>public void transfer(String outMan, String inMan, double money) {<br>    accountDao.out(outMan,money);<br>    int i = 1/0;<br>    accountDao.in(inMan,money);<br>}</p>
<h3 id="2-3-切点方法的事务参数的配置"><a href="#2-3-切点方法的事务参数的配置" class="headerlink" title="2.3 切点方法的事务参数的配置"></a>2.3 切点方法的事务参数的配置</h3><!--事务增强配置-->
<p>&lt;tx:advice id=”txAdvice” transaction-manager=”transactionManager”&gt;<br>    <a href="tx:attributes">tx:attributes</a><br>        &lt;tx:method name=”*”/&gt;<br>    </tx:attributes><br></tx:advice><br>其中，<a href="tx:method">tx:method</a> 代表切点方法的事务参数的配置，例如：</p>
<p>&lt;tx:method name=”transfer” isolation=”REPEATABLE_READ” propagation=”REQUIRED” timeout=”-1” read-only=”false”/&gt;<br>● name：切点方法名称<br>● isolation: 事务的隔离级别<br>● propogation：事务的传播行为<br>● timeout：超时时间<br>● read-only：是否只读</p>
<h3 id="2-4-知识要点-1"><a href="#2-4-知识要点-1" class="headerlink" title="2.4 知识要点"></a>2.4 知识要点</h3><p>声明式事务控制的配置要点<br>● 平台事务管理器配置<br>● 事务通知的配置<br>● 事务 aop 织入的配置</p>
<h2 id="3-基于注解的声明式事务控制"><a href="#3-基于注解的声明式事务控制" class="headerlink" title="3.基于注解的声明式事务控制"></a>3.基于注解的声明式事务控制</h2><h3 id="3-1-使用注解配置声明式事务控制"><a href="#3-1-使用注解配置声明式事务控制" class="headerlink" title="3.1 使用注解配置声明式事务控制"></a>3.1 使用注解配置声明式事务控制</h3><p>（1）编写 AccoutDao</p>
<p>@Repository(“accountDao”)<br>public class AccountDaoImpl implements AccountDao {<br>    @Autowired<br>    private JdbcTemplate jdbcTemplate;<br>    public void out(String outMan, double money) {<br>        jdbcTemplate.update(“update account set money=money-? where name=?”,money,outMan);<br>    }<br>    public void in(String inMan, double money) {<br>        jdbcTemplate.update(“update account set money=money+? where name=?”,money,inMan);<br>    }<br>}<br>（2） 编写 AccoutService</p>
<p>@Repository<br>@Transactional//这里没有写参数，代表采用默认配置；这里声明事务，代表这个类的所有方法都会开启事务<br>public class AccountServiceImpl implements AccountService {<br>    @Autowired<br>    private AccountDao accountDao;<br>    @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)//这里又定义了事务，则此方法以这个事务定义为准<br>    public void transfer(String outMan, String inMan, double money) {<br>        accountDao.out(outMan, money);<br>        //int i = 1 / 0;<br>        accountDao.in(inMan, money);<br>    }<br>}<br>（3）编写 applicationContext.xml 配置文件</p>
<!--之前省略datsSource、jdbcTemplate、平台事务管理器的配置-->
<!--组件扫描-->
<p>&lt;context:component-scan base-package=”com.itheima”&gt;</context:component-scan></p>
<!--事务的注解驱动-->
<p>&lt;tx:annotation-driven transaction-manager=”transactionManager”&gt;</tx:annotation-driven></p>
<h3 id="3-2-注解配置声明式事务控制解析"><a href="#3-2-注解配置声明式事务控制解析" class="headerlink" title="3.2 注解配置声明式事务控制解析"></a>3.2 注解配置声明式事务控制解析</h3><p>① 使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。<br>② 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。<br>③ 使用在方法上，不同的方法可以采用不同的事务参数配置。<br>④ Xml 配置文件中要开启事务的注解驱动 &lt;tx:annotation-driven /&gt;</p>
<h3 id="3-3-知识要点-1"><a href="#3-3-知识要点-1" class="headerlink" title="3.3 知识要点"></a>3.3 知识要点</h3><p>注解声明式事务控制的配置要点<br>● 平台事务管理器配置（xml 方式）<br>● 事务通知的配置（@Transactional 注解配置）<br>● 事务注解驱动的配置 <a href="tx:annotation-driven/">tx:annotation-driven/</a></p>
<h1 id="第十一章-MyBatis-入门操作"><a href="#第十一章-MyBatis-入门操作" class="headerlink" title="第十一章 MyBatis 入门操作"></a>第十一章 MyBatis 入门操作</h1><h2 id="1-Mybatis-简介"><a href="#1-Mybatis-简介" class="headerlink" title="1.Mybatis 简介"></a>1.Mybatis 简介</h2><h3 id="1-1-原始-jdbc-操作（查询数据）"><a href="#1-1-原始-jdbc-操作（查询数据）" class="headerlink" title="1.1 原始 jdbc 操作（查询数据）"></a>1.1 原始 jdbc 操作（查询数据）</h3><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221344619.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-原始-jdbc-操作（插入数据）"><a href="#1-1-原始-jdbc-操作（插入数据）" class="headerlink" title="1.1 原始 jdbc 操作（插入数据）"></a>1.1 原始 jdbc 操作（插入数据）</h3><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221345438.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-原始-jdbc-操作的分析"><a href="#1-2-原始-jdbc-操作的分析" class="headerlink" title="1.2 原始 jdbc 操作的分析"></a>1.2 原始 jdbc 操作的分析</h3><p>原始 jdbc 开发存在的问题如下：<br>① 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能<br>② sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。<br>③ 查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到 sql 语句的占位符位置</p>
<p>应对上述问题给出的解决方案：<br>① 使用数据库连接池初始化连接资源<br>② 将 sql 语句抽取到 xml 配置文件中<br>③ 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p>
<h3 id="1-3-什么是-Mybatis"><a href="#1-3-什么是-Mybatis" class="headerlink" title="1.3 什么是 Mybatis"></a>1.3 什么是 Mybatis</h3><p>● mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。<br>● mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句。<br>● 最后 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</p>
<h2 id="2-Mybatis-的快速入门"><a href="#2-Mybatis-的快速入门" class="headerlink" title="2.Mybatis 的快速入门"></a>2.Mybatis 的快速入门</h2><h3 id="2-1-MyBatis-开发步骤"><a href="#2-1-MyBatis-开发步骤" class="headerlink" title="2.1 MyBatis 开发步骤"></a>2.1 MyBatis 开发步骤</h3><p>① 添加 MyBatis 的坐标<br>② 创建 user 数据表<br>③ 编写 User 实体类<br>④ 编写映射文件 UserMapper.xml<br>⑤ 编写核心文件 SqlMapConfig.xml<br>⑥ 编写测试类</p>
<h3 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h3><p>（1）导入 MyBatis 的坐标和其他相关坐标</p>
<!--mybatis坐标-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.32</version>
</dependency>
<!--mysql驱动坐标-->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.4.6</version>
</dependency>
<!--单元测试坐标-->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
</dependency>
<!--日志坐标-->
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
（2）创建 user 数据表

<p>（3）编写 User 实体</p>
<p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;<br>    //省略get和set方法<br>}<br>（4）编写 UserMapper 映射文件</p>
<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="userMapper">
    <select id="findAll" resultType="com.itheima.domain.User">
        select * from user
    </select>
</mapper>
（5）编写 MyBatis 核心文件

<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>


<pre><code>&lt;!--数据源环境--&gt;
&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;


&lt;!--加载映射文件--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt;
&lt;/mappers&gt;
</code></pre>
</configuration>

<h3 id="2-3-编写测试代码"><a href="#2-3-编写测试代码" class="headerlink" title="2.3 编写测试代码"></a>2.3 编写测试代码</h3><p>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>//获得session回话对象<br>SqlSession sqlSession = sqlSessionFactory.openSession();<br>//执行操作  参数：namespace+id<br>List<User> userList = sqlSession.selectList(“userMapper.findAll”);<br>//打印数据<br>System.out.println(userList);<br>//释放资源<br>sqlSession.close();</p>
<h3 id="2-4-知识小结"><a href="#2-4-知识小结" class="headerlink" title="2.4 知识小结"></a>2.4 知识小结</h3><p>MyBatis 开发步骤：<br>① 添加 MyBatis 的坐标<br>② 创建 user 数据表<br>③ 编写 User 实体类<br>④ 编写映射文件 UserMapper.xml<br>⑤ 编写核心文件 SqlMapConfig.xml<br>⑥ 编写测试类</p>
<h2 id="3-MyBatis-的映射文件概述"><a href="#3-MyBatis-的映射文件概述" class="headerlink" title="3.MyBatis 的映射文件概述"></a>3.MyBatis 的映射文件概述</h2><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221401630.png" alt="在这里插入图片描述"></p>
<h2 id="4-MyBatis-的增删改查操作"><a href="#4-MyBatis-的增删改查操作" class="headerlink" title="4.MyBatis 的增删改查操作"></a>4.MyBatis 的增删改查操作</h2><h3 id="4-1-MyBatis-的插入数据操作"><a href="#4-1-MyBatis-的插入数据操作" class="headerlink" title="4.1 MyBatis 的插入数据操作"></a>4.1 MyBatis 的插入数据操作</h3><p>（1）编写 UserMapper 映射文件</p>
<!--插入操作-->
<insert id="save" parameterType="com.itheima.domain.User">
    insert into user values(#{id},#{username},#{password})
</insert>
（2）编写插入实体 User 的代码

<p>//模拟user对象<br>User user = new User();<br>user.setUsername(“xxx”);<br>user.setPassword(“abc”);<br>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>//获得session回话对象<br>SqlSession sqlSession = sqlSessionFactory.openSession();<br>//执行操作  参数：namespace+id<br>sqlSession.insert(“userMapper.save”,user);<br>//mybatis执行更新操作  提交事务<br>sqlSession.commit();<br>//释放资源<br>sqlSession.close();<br>（3）插入操作注意问题<br>● 插入语句使用 insert 标签<br>● 在映射文件中使用 parameterType 属性指定要插入的数据类型<br>● Sql 语句中使用 #{实体属性名} 方式引用实体中的属性值<br>● 插入操作使用的 API 是 sqlSession.insert (“命名空间.id”, 实体对象);<br>● 插入操作涉及数据库数据变化，所以要使用 sqlSession 对象显示的提交事务，即 sqlSession.commit ()</p>
<h3 id="4-2-MyBatis-的修改数据操作"><a href="#4-2-MyBatis-的修改数据操作" class="headerlink" title="4.2 MyBatis 的修改数据操作"></a>4.2 MyBatis 的修改数据操作</h3><p>（1）编写 UserMapper 映射文件</p>
<!--修改操作-->
<update id="update" parameterType="com.itheima.domain.User">
    update user set username=#{username},password=#{password} where id=#{id}
</update>
（2）编写修改实体 User 的代码

<p>//模拟user对象<br>User user = new User();<br>user.setId(0);<br>user.setUsername(“lucy”);<br>user.setPassword(“123”);<br>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>//获得session回话对象<br>SqlSession sqlSession = sqlSessionFactory.openSession();<br>//执行操作  参数：namespace+id<br>sqlSession.update(“userMapper.update”, user);<br>//mybatis执行更新操作  提交事务<br>sqlSession.commit();<br>//释放资源<br>sqlSession.close();<br>（3）修改操作注意问题<br>● 修改语句使用 update 标签<br>● 修改操作使用的 API 是 sqlSession.update (“命名空间.id”, 实体对象);</p>
<h3 id="4-3-MyBatis-的删除数据操作"><a href="#4-3-MyBatis-的删除数据操作" class="headerlink" title="4.3 MyBatis 的删除数据操作"></a>4.3 MyBatis 的删除数据操作</h3><p>（1）编写 UserMapper 映射文件</p>
<!--删除操作-->
<delete id="delete" parameterType="java.lang.Integer">
    delete  from user where id=#{id}
</delete>
（2）编写删除数据的代码

<p>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>//获得session回话对象<br>SqlSession sqlSession = sqlSessionFactory.openSession();<br>//执行操作  参数：namespace+id<br>sqlSession.delete(“userMapper.delete”, 0);<br>//mybatis执行更新操作  提交事务<br>sqlSession.commit();<br>//释放资源<br>sqlSession.close();<br>（3）删除操作注意问题<br>● 删除语句使用 delete 标签<br>● Sql 语句中使用 #{任意字符串} 方式引用传递的单个参数<br>● 删除操作使用的 API 是 sqlSession.delete (“命名空间.id”,Object);</p>
<h3 id="4-4-知识小结"><a href="#4-4-知识小结" class="headerlink" title="4.4 知识小结"></a>4.4 知识小结</h3><p>增删改查映射配置与 API：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221401412.png" alt="在这里插入图片描述"></p>
<h2 id="5-MyBatis-核心配置文件概述"><a href="#5-MyBatis-核心配置文件概述" class="headerlink" title="5.MyBatis 核心配置文件概述"></a>5.MyBatis 核心配置文件概述</h2><h3 id="5-1-MyBatis-核心配置文件层级关系"><a href="#5-1-MyBatis-核心配置文件层级关系" class="headerlink" title="5.1 MyBatis 核心配置文件层级关系"></a>5.1 MyBatis 核心配置文件层级关系</h3><p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221406205.png" alt="在这里插入图片描述"></p>
<h3 id="5-2-MyBatis-常用配置解析"><a href="#5-2-MyBatis-常用配置解析" class="headerlink" title="5.2 MyBatis 常用配置解析"></a>5.2 MyBatis 常用配置解析</h3><p>（1）environments 标签<br>数据库环境的配置，支持多环境配置</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221406943.png" alt="在这里插入图片描述"></p>
<p>其中，事务管理器（transactionManager）类型有两种：</p>
<p>● JDBC：这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。<br>● MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p>
<p>其中，数据源（dataSource）类型有三种：</p>
<p>● UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。<br>● POOLED：这种数据源的实现利用 “池” 的概念将 JDBC 连接对象组织起来。<br>● JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
<p>（2）mapper 标签<br>该标签的作用是加载映射的，加载方式有如下几种：<br>● 使用相对于类路径的资源引用，例如：<br>● 使用完全限定资源定位符（URL），例如：<br>● 使用映射器接口实现类的完全限定类名，例如：<br>● 将包内的映射器接口实现全部注册为映射器，例如：</p>
<p>（3）Properties 标签<br>实际开发中，习惯将数据源的配置信息单独抽取成一个 properties 文件，该标签可以加载额外配置的 properties 文件</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221407868.png" alt="在这里插入图片描述"></p>
<p>（4） typeAliases 标签<br>类型别名是为 Java 类型设置一个短的名字。原来的类型名称配置如下</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221408809.png" alt="在这里插入图片描述"></p>
<p>上面我们是自定义的别名，mybatis 框架已经为我们设置好的一些常用的类型的别名：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221408900.png" alt="在这里插入图片描述"></p>
<h3 id="5-3-知识小结"><a href="#5-3-知识小结" class="headerlink" title="5.3 知识小结"></a>5.3 知识小结</h3><p>核心配置文件常用配置：<br>（1）properties 标签：该标签可以加载外部的 properties 文件</p>
<p><properties resource="jdbc.properties"></properties><br>（2）typeAliases 标签：设置类型别名</p>
<typeAliases>
    <typeAlias type="com.itheima.domain.User" alias="user"></typeAlias>
</typeAliases>
（3）mappers 标签：加载映射配置

<mappers>
    <mapper resource="com/itheima/mapper/UserMapper.xml"></mapper>
</mappers>
（4）environments 标签：数据源环境配置标签

<environments default="development">
    <environment id="development">
        <transactionManager type="JDBC"></transactionManager>
        <dataSource type="POOLED">
            <property name="driver" value="${jdbc.driver}"/>
            <property name="url" value="${jdbc. url}"/>
            <property name="username" value="${jdbc.username}"/>
            <property name="password" value="${jdbc.password}"/>
        </dataSource>
    </environment>
</environments>

<h2 id="6-MyBatis-相应-API"><a href="#6-MyBatis-相应-API" class="headerlink" title="6.MyBatis 相应 API"></a>6.MyBatis 相应 API</h2><h3 id="6-1-SqlSession-工厂构建器-SqlSessionFactoryBuilder"><a href="#6-1-SqlSession-工厂构建器-SqlSessionFactoryBuilder" class="headerlink" title="6.1 SqlSession 工厂构建器 SqlSessionFactoryBuilder"></a>6.1 SqlSession 工厂构建器 SqlSessionFactoryBuilder</h3><p>常用 API：SqlSessionFactory build (InputStream inputStream)<br>通过加载 mybatis 的核心文件的输入流的形式构建一个 SqlSessionFactory 对象</p>
<p>String resource = “org/mybatis/builder/mybatis-config.xml”;<br>InputStream inputStream = Resources.getResourceAsStream(resource);<br>SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();<br>SqlSessionFactory factory = builder.build(inputStream);<br>//获得核心配置文件<br>InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>//获得session工厂对象<br>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p>
<h3 id="6-2-SqlSession-工厂对象-SqlSessionFactory"><a href="#6-2-SqlSession-工厂对象-SqlSessionFactory" class="headerlink" title="6.2 SqlSession 工厂对象 SqlSessionFactory"></a>6.2 SqlSession 工厂对象 SqlSessionFactory</h3><blockquote>
<p>SqlSessionFactory 有多个个方法创建 SqlSession 实例。常用的有如下两个：<img src="https://gitee.com/an-menghe/img/raw/master/test/202202221413472.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="6-3-SqlSession-会话对象"><a href="#6-3-SqlSession-会话对象" class="headerlink" title="6.3 SqlSession 会话对象"></a>6.3 SqlSession 会话对象</h3><p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。执行语句的方法主要有：</p>
<p><T> T selectOne(String statement, Object parameter)<br><E> List<E> selectList(String statement, Object parameter)<br>int insert(String statement, Object parameter)<br>int update(String statement, Object parameter)<br>int delete(String statement, Object parameter)<br>操作事务的方法主要有：</p>
<p>void commit()<br>void rollback()</p>
<h1 id="第十二章-MyBatis-的-Dao-层实现方式"><a href="#第十二章-MyBatis-的-Dao-层实现方式" class="headerlink" title="第十二章 MyBatis 的 Dao 层实现方式"></a>第十二章 MyBatis 的 Dao 层实现方式</h1><h2 id="1-Mybatis-的-Dao-层实现"><a href="#1-Mybatis-的-Dao-层实现" class="headerlink" title="1.Mybatis 的 Dao 层实现"></a>1.Mybatis 的 Dao 层实现</h2><h3 id="1-1-传统开发方式"><a href="#1-1-传统开发方式" class="headerlink" title="1.1 传统开发方式"></a>1.1 传统开发方式</h3><p>（1）编写 UserDao 接口</p>
<p>public interface UserMapper {<br>    public List<User> findAll() throws IOException;<br>}<br>（2）编写 UserDaoImpl 实现</p>
<p>public class UserMapperImpl implements UserMapper {<br>    public List<User> findAll() throws IOException {<br>        InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>        SqlSession sqlSession = sqlSessionFactory.openSession();<br>        List<User> userList = sqlSession.selectList(“userMapper.findAll”);<br>        return userList;<br>    }<br>}<br>（3）测试传统方式</p>
<p>@Test<br>public void testTraditionDao() throws IOException {<br>    UserMapper userMapper = new UserMapperImpl();<br>    List<User> all = userMapper.findAll();<br>    System.out.println(all);<br>}</p>
<h3 id="1-2-代理开发方式"><a href="#1-2-代理开发方式" class="headerlink" title="1.2 代理开发方式"></a>1.2 代理开发方式</h3><p>（1） 代理开发方式介绍</p>
<p>采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。<br>Mapper 接口开发方法只需要程序员编写 Mapper 接口（相当于 Dao 接口），由 Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边 Dao 接口实现类方法。</p>
<p>Mapper 接口开发需要遵循以下规范：<br>① Mapper.xml 文件中的 namespace 与 mapper 接口的全限定名相同<br>② Mapper 接口方法名和 Mapper.xml 中定义的每个 statement 的 id 相同<br>③ Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的类型相同<br>④ Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型相同</p>
<p>（2）编写 UserMapper 接口</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221416816.png" alt="在这里插入图片描述"></p>
<p>（3）测试代理方式</p>
<p>@Test<br>public void testProxyDao() throws IOException {<br>    InputStream resourceAsStream = Resources.getResourceAsStream(“SqlMapConfig.xml”);<br>    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>    SqlSession sqlSession = sqlSessionFactory.openSession();</p>
<pre><code>//获得MyBatis框架生成的UserMapper接口的实现类
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User user = userMapper.findById(1);
System.out.println(user);
sqlSession.close();
</code></pre>
<p>}</p>
<h3 id="1-3-知识小结"><a href="#1-3-知识小结" class="headerlink" title="1.3 知识小结"></a>1.3 知识小结</h3><p>MyBatis 的 Dao 层实现的两种方式：<br>● 手动对 Dao 进行实现：传统开发方式<br>● 代理方式对 Dao 进行实现：</p>
<p>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221416568.png" alt="在这里插入图片描述"></p>
<p>补充：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202161542612.png" alt="image-20220216154215517"></p>
<h1 id="第十三章-MyBatis-映射文件深入"><a href="#第十三章-MyBatis-映射文件深入" class="headerlink" title="第十三章 MyBatis 映射文件深入"></a>第十三章 MyBatis 映射文件深入</h1><h2 id="1-MyBatis-映射文件深入"><a href="#1-MyBatis-映射文件深入" class="headerlink" title="1.MyBatis 映射文件深入"></a>1.MyBatis 映射文件深入</h2><h3 id="1-1-动态-sql-语句"><a href="#1-1-动态-sql-语句" class="headerlink" title="1.1 动态 sql 语句"></a>1.1 动态 sql 语句</h3><p>（1）动态 sql 语句概述<br>Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL 是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。<br>参考的官方文档，描述如下：</p>
<p>（2）动态 SQL 之 <if><br>我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果 username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p>
<select id="findByCondition" parameterType="user" resultType="user">
    select * from user
    <where>
        <if test="id!=0">
            and id=#{id}
        </if>
        <if test="username!=null">
            and username = #{username}
        </if>
        <if test="password!=null">
            and password = #{password}
        </if>
    </where>
</select>
当查询条件 id 和 username 都存在时

<p>//获得MyBatis框架生成的UserMapper接口的实现类<br>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>User condition = new User();<br>condition.setId(1);<br>condition.setUsername(“lucy”);<br>User user = userMapper.findByCondition(condition);<br>控制台打印的 sql 语句如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221430775.png" alt="在这里插入图片描述"></p>
<p>当查询条件只有 id 存在时</p>
<p>//获得MyBatis框架生成的UserMapper接口的实现类<br>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>User condition = new User();<br>condition.setId(1);<br>User user = userMapper.findByCondition(condition);<br>控制台打印的 sql 语句如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221432454.png" alt="image-20220222143244390"></p>
<p>（3）动态 SQL 之 <foreach><br>循环执行 sql 的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。</p>
<select id="findByIds" parameterType="list" resultType="user">
    select * from user
    <where>
        <foreach collection="list" open="id in(" close=")" item="id" separator=",">
            #{id}
        </foreach>
    </where>
</select>
测试代码片段如下：

<p>//获得MyBatis框架生成的UserMapper接口的实现类<br>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>int[] ids = new int[]{2,5};<br>List<User> userList = userMapper.findByIds(ids);<br>System.out.println(userList);</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221434558.png" alt="在这里插入图片描述"></p>
<p>foreach 标签的属性含义如下：<br><foreach> 标签用于遍历集合，它的属性：<br>● collection：代表要遍历的集合元素，注意编写时不要写 #{}<br>● open：代表语句的开始部分<br>● close：代表结束部分<br>● item：代表遍历集合的每个元素，生成的变量名<br>● sperator：代表分隔符</p>
<h3 id="1-2-SQL-片段抽取"><a href="#1-2-SQL-片段抽取" class="headerlink" title="1.2 SQL 片段抽取"></a>1.2 SQL 片段抽取</h3><p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221435231.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-知识小结-1"><a href="#1-3-知识小结-1" class="headerlink" title="1.3 知识小结"></a>1.3 知识小结</h3><p>MyBatis 映射文件配置：</p>
<p><select>：查询<br><insert>：插入<br><update>：修改<br><delete>：删除<br><where>：where 条件<br><if>：if 判断<br><foreach>：循环<br><sql>：sql 片段抽取</p>
<h1 id="第十四章-MyBatis-核心配置文件深入"><a href="#第十四章-MyBatis-核心配置文件深入" class="headerlink" title="第十四章 MyBatis 核心配置文件深入"></a>第十四章 MyBatis 核心配置文件深入</h1><h2 id="1-MyBatis-核心配置文件深入"><a href="#1-MyBatis-核心配置文件深入" class="headerlink" title="1.MyBatis 核心配置文件深入"></a>1.MyBatis 核心配置文件深入</h2><h3 id="1-1-typeHandlers-标签"><a href="#1-1-typeHandlers-标签" class="headerlink" title="1.1 typeHandlers 标签"></a>1.1 typeHandlers 标签</h3><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221436396.png" alt="在这里插入图片描述"></p>
<p>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个 JDBC 类型。例如需求：一个 Java 中的 Date 数据类型，我想将之存到数据库的时候存成一个 1970 年至今的毫秒数，取出来时转换成 java 的 Date，即 java 的 Date 与数据库的 varchar 毫秒值之间转换。</p>
<p>开发步骤：</p>
<p>① 定义转换类继承类 BaseTypeHandler<br>② 覆盖 4 个未实现的方法，其中 setNonNullParameter 为 java 程序设置数据到数据库的回调方法，getNullableResult 为查询时 mysql 的字符串类型转换成 java 的 Type 类型的方法<br>③ 在 MyBatis 核心配置文件中进行注册<br>④ 测试转换是否正确</p>
<p>//想要自定义什么转换类型，对应 &lt;数据类型&gt; 尖括号内写对应数据类型<br>public class MyDateTypeHandler extends BaseTypeHandler<Date> {<br>    /*<br>     preparedStatement.setString（）转换成数据库的类型<br>     i===参数位置<br>     date===参数<br>    */<br>    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) {<br>        preparedStatement.setString(i, date.getTime() + “”);<br>    }<br>    //将数据库类型转为java类型<br>    public Date getNullableResult(ResultSet resultSet, String s) throws SQLException {<br>        return new Date(resultSet.getLong(s));<br>    }<br>    //将数据库类型转为java类型<br>    public Date getNullableResult(ResultSet resultSet, int i) throws SQLException {<br>        return new Date(resultSet.getLong(i));<br>    }<br>    //将数据库类型转为java类型<br>    public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException {<br>        return callableStatement.getDate(i);<br>    }<br>}</p>
<!--注册类型自定义转换器-->
<typeHandlers>
    <typeHandler handler="com.itheima.typeHandlers.MyDateTypeHandler"></typeHandler>
</typeHandlers>
测试添加操作：

<p>user.setBirthday(new Date());<br>userMapper.add2(user);<br>数据库数据：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221436451.png" alt="在这里插入图片描述"></p>
<p>测试查询操作：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221436751.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-plugins-标签"><a href="#1-2-plugins-标签" class="headerlink" title="1.2 plugins 标签"></a>1.2 plugins 标签</h3><p>分页助手 PageHelper</p>
<p>MyBatis 可以使用第三方的插件来对功能进行扩展，分页助手 PageHelper 是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据<br>开发步骤：<br>① 导入通用 PageHelper 的坐标<br>② 在 mybatis 核心配置文件中配置 PageHelper 插件<br>③ 测试分页数据获取</p>
<p>① 导入通用 PageHelper 坐标</p>
<!-- 分页助手 -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>3.7.5</version>
</dependency>
<dependency>
    <groupId>com.github.jsqlparser</groupId>
    <artifactId>jsqlparser</artifactId>
    <version>0.9.1</version>
</dependency>
② 在 mybatis 核心配置文件中配置 PageHelper 插件

<!-- 注意：分页助手的插件 配置在通用馆mapper之前 -->
<plugin interceptor="com.github.pagehelper.PageHelper">
    <!-- 指定方言 -->
    <property name="dialect" value="mysql"/>
</plugin>

<p>③ 测试分页代码实现</p>
<p>@Test<br>public void testPageHelper() {<br>    //设置分页参数(第几页，每页显示几条数据)<br>    PageHelper.startPage(1, 2);<br>    List<User> select = userMapper2.select(null);<br>    for (User user : select) {<br>        System.out.println(user);<br>    }<br>}<br>获得分页相关的其他参数</p>
<p>//其他分页的数据( &lt;泛型‘实体类’&gt;   ，new PageInfo<User>(查询的所有数据);)<br>PageInfo<User> pageInfo = new PageInfo<User>(select);<br>System.out.println(“总条数：” + pageInfo.getTotal());<br>System.out.println(“总页数：” + pageInfo.getPages());<br>System.out.println(“当前页：” + pageInfo.getPageNum());<br>System.out.println(“每页显示长度：” + pageInfo.getPageSize());<br>System.out.println(“是否第一页：” + pageInfo.isIsFirstPage());<br>System.out.println(“是否最后一页：” + pageInfo.isIsLastPage());</p>
<h3 id="1-3-知识小结-2"><a href="#1-3-知识小结-2" class="headerlink" title="1.3 知识小结"></a>1.3 知识小结</h3><p>MyBatis 核心配置文件常用标签：<br>（1）properties 标签：该标签可以加载外部的 properties 文件<br>（2）typeAliases 标签：设置类型别名<br>（3）environments 标签：数据源环境配置标签<br>（4）typeHandlers 标签：配置自定义类型处理器<br>（5）plugins 标签：配置 MyBatis 的插件</p>
<h1 id="第十五章-MyBatis-的多表操作"><a href="#第十五章-MyBatis-的多表操作" class="headerlink" title="第十五章 MyBatis 的多表操作"></a>第十五章 MyBatis 的多表操作</h1><h2 id="1-Mybatis-多表查询"><a href="#1-Mybatis-多表查询" class="headerlink" title="1.Mybatis 多表查询"></a>1.Mybatis 多表查询</h2><h3 id="1-1-一对一查询"><a href="#1-1-一对一查询" class="headerlink" title="1.1 一对一查询"></a>1.1 一对一查询</h3><p>（1）一对一查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221455574.png" alt="在这里插入图片描述"></p>
<p>（2）一对一查询的语句<br>对应的 sql 语句：select *,o.id oid from orders o,user u where o.uid=u.id;<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221455398.png" alt="在这里插入图片描述"></p>
<p>（3）创建 Order 和 User 实体</p>
<p>public class Order {<br>    private int id;<br>    private Date ordertime;<br>    private double total;<br>    //当前订单属于哪一个用户<br>    private User user;<br>}</p>
<p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;<br>    private Date birthday;<br>}<br>（4）创建 OrderMapper 接口</p>
<p>public interface OrderMapper {<br>    //查询全部的方法<br>    public List<Order> findAll();</p>
<p>}<br>（5）配置 OrderMapper.xml</p>
<mapper namespace="com.itheima.mapper.OrderMapper">
    <resultMap id="orderMap" type="order">
        <!--手动指定字段与实体属性的映射关系
            column: 数据表的字段名称
            property：实体的属性名称-->
        <id column="oid" property="id"></id>
        <result column="ordertime" property="ordertime"></result>
        <result column="total" property="total"></result>
        <result column="uid" property="user.id"></result>
        <result column="username" property="user.username"></result>
        <result column="password" property="user.password"></result>
        <result column="birthday" property="user.birthday"></result>
    </resultMap>
    <select id="findAll" resultMap="orderMap">
         select *,o.id oid from orders o,user u where o.uid=u.id;
    </select>
</mapper>
其中还可以配置如下：

<mapper namespace="com.itheima.mapper.OrderMapper">
    <resultMap id="orderMap" type="order">
        <!--手动指定字段与实体属性的映射关系
            column: 数据表的字段名称
            property：实体的属性名称-->
        <id column="oid" property="id"></id>
        <result column="ordertime" property="ordertime"></result>
        <result column="total" property="total"></result>
        <!--实体类映射-->
        <association property="user" javaType="user">
            <id column="uid" property="id"></id>
            <result column="username" property="username"></result>
            <result column="password" property="password"></result>
            <result column="birthday" property="birthday"></result>
        </association>
    </resultMap>
    <select id="findAll" resultMap="orderMap">
         select *,o.id oid from orders o,user u where o.uid=u.id;
    </select>
</mapper>
（6）测试结果

<p>OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);<br>List<Order> all = mapper.findAll();<br>for(Order order : all){<br>    System.out.println(order);<br>}</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221456182.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-一对多查询"><a href="#1-2-一对多查询" class="headerlink" title="1.2 一对多查询"></a>1.2 一对多查询</h3><p>（1）一对多查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221456243.png" alt="在这里插入图片描述"></p>
<p>（2） 一对多查询的语句<br>对应的 sql 语句：select *,o.id oid from user u left join orders o on u.id=o.uid;<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221456048.png" alt="在这里插入图片描述"></p>
<p>（3）修改 User 实体</p>
<p>//订单<br>public class Order {<br>    private int id;<br>    private Date ordertime;<br>    private double total;<br>    //当前订单属于哪一个用户<br>    private User user;<br>}</p>
<p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;<br>    private Date birthday;<br>    //描述的是当前用户存在哪些订单<br>    private List<Order> orderList;<br>}<br>（4）创建 UserMapper 接口</p>
<p>public interface UserMapper {<br>    public List<User> findAll();<br>}<br>（5）配置 UserMapper.xml</p>
<mapper namespace="com.itheima.mapper.UserMapper">
    <resultMap id="userMap" type="user">
        <id column="uid" property="id"></id>
        <result column="username" property="username"></result>
        <result column="password" property="password"></result>
        <result column="birthday" property="birthday"></result>
        <!--配置集合信息
            property:集合名称
            ofType：当前集合中的数据类型-->
        <collection property="orderList" ofType="order">
            <!--封装order的数据-->
            <id column="oid" property="id"></id>
            <result column="ordertime" property="ordertime"></result>
            <result column="total" property="total"></result>
        </collection>
    </resultMap>

<pre><code>&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
    SELECT *,o.id oid FROM USER u,orders o WHERE u.id=o.uid
&lt;/select&gt;
</code></pre>
</mapper>
（6）测试结果

<p>UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>List<User> all = mapper.findAll();<br>for(User user : all){<br>    System.out.println(user.getUsername());<br>    List<Order> orderList = user.getOrderList();<br>    for(Order order : orderList){<br>        System.out.println(order);<br>    }<br>    System.out.println(“———————————-“);<br>}</p>
<p><img src="https://img-blog.csdnimg.cn/158a7b176e6b4401a266650b2b2c5f8e.png" alt="在这里插入图片描述"></p>
<h3 id="1-3-多对多查询"><a href="#1-3-多对多查询" class="headerlink" title="1.3 多对多查询"></a>1.3 多对多查询</h3><p>（1）多对多查询的模型<br>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用<br>多对多查询的需求：查询用户同时查询出该用户的所有角色</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221457100.png" alt="在这里插入图片描述"></p>
<p>（2）多对多查询的语句<br>对应的 sql 语句：SELECT * FROM USER u,sys_user_role ur,sys_role r WHERE u.id=ur.userId AND ur.roleId=r.id;<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221457654.png" alt="img"></p>
<p>（3）创建 Role 实体，修改 User 实体</p>
<p>public class User {<br>    private int id;<br>    private String username;<br>    private String password;<br>    private Date birthday;<br>    //描述的是当前用户具备哪些角色<br>    private List<Role> roleList;<br>}<br>//角色<br>public class Role {<br>    private int id;<br>    private String roleName;<br>    private String roleDesc;<br>}<br>（4）添加 UserMapper 接口方法</p>
<p>public List<User> findUserAndRoleAll();<br>（5）配置 UserMapper.xml</p>
<resultMap id="userRoleMap" type="user">
    <!--user的信息-->
    <id column="userId" property="id"></id>
    <result column="username" property="username"></result>
    <result column="password" property="password"></result>
    <result column="birthday" property="birthday"></result>
    <!--user内部的roleList信息-->
    <collection property="roleList" ofType="role">
        <id column="roleId" property="id"></id>
        <result column="roleName" property="roleName"></result>
        <result column="roleDesc" property="roleDesc"></result>
    </collection>
</resultMap>

<select id="findUserAndRoleAll" resultMap="userRoleMap">
    SELECT * FROM USER u,sys_user_role ur,sys_role r WHERE u.id=ur.userId AND ur.roleId=r.id
</select>
（6）测试结果

<p>UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>List<User> all = mapper.findAllUserAndRole();<br>for(User user : all){<br>    System.out.println(user.getUsername());<br>    List<Role> roleList = user.getRoleList();<br>    for(Role role : roleList){<br>        System.out.println(role);<br>    }<br>    System.out.println(“———————————-“);<br>}</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221457773.png" alt="在这里插入图片描述"></p>
<h3 id="1-4-知识小结"><a href="#1-4-知识小结" class="headerlink" title="1.4 知识小结"></a>1.4 知识小结</h3><p>MyBatis 多表配置方式：<br>一对一配置：使用 <resultMap> 做配置<br>一对多配置：使用 <resultMap>+<collection> 做配置<br>多对多配置：使用 <resultMap>+<collection> 做配置</p>
<h1 id="第十六章-MyBatis-注解开发"><a href="#第十六章-MyBatis-注解开发" class="headerlink" title="第十六章 MyBatis 注解开发"></a>第十六章 MyBatis 注解开发</h1><h2 id="1-Mybatis-的注解开发"><a href="#1-Mybatis-的注解开发" class="headerlink" title="1.Mybatis 的注解开发"></a>1.Mybatis 的注解开发</h2><p>这几年来注解开发越来越流行，Mybatis 也可以使用注解开发方式，这样我们就可以减少编写 Mapper<br>映射文件了。我们先围绕一些基本的 CRUD 来学习，再学习复杂映射多表操作。</p>
<h3 id="1-1-注解"><a href="#1-1-注解" class="headerlink" title="1.1 注解"></a>1.1 注解</h3><p>@Insert：实现新增<br>@Update：实现更新<br>@Delete：实现删除<br>@Select：实现查询<br>@Result：实现结果集封装<br>@Results：可以与 @Result 一起使用，封装多个结果集<br>@One：实现一对一结果集封装<br>@Many：实现一对多结果集封装</p>
<h3 id="1-2-MyBatis-的增删改查"><a href="#1-2-MyBatis-的增删改查" class="headerlink" title="1.2 MyBatis 的增删改查"></a>1.2 MyBatis 的增删改查</h3><p>我们完成简单的 user 表的增删改查的操作</p>
<p>public class MyBatisTest {<br>    private UserMapper mapper;<br>    @Before<br>    public void before() throws IOException {<br>        InputStream resourceAsStream = Resources.getResourceAsStream(“sqlMapConfig.xml”);<br>        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);<br>        SqlSession sqlSession = sqlSessionFactory.openSession(true);<br>        mapper = sqlSession.getMapper(UserMapper.class);<br>    }<br>    @Test<br>    public void testSave(){<br>        User user = new User();<br>        user.setUsername(“tom”);<br>        user.setPassword(“abc”);<br>        mapper.save(user);<br>    }<br>    @Test<br>    public void testUpdate(){<br>        User user = new User();<br>        user.setId(18);<br>        user.setUsername(“lucy”);<br>        user.setPassword(“123”);<br>        mapper.update(user);<br>    }<br>    @Test<br>    public void testDelete(){<br>        mapper.delete(18);<br>    }<br>    @Test<br>    public void testFindById(){<br>        User user = mapper.findById(2);<br>        System.out.println(user);<br>    }<br>    @Test<br>    public void testFindAll(){<br>        List<User> all = mapper.findAll();<br>        for (User user : all) {<br>            System.out.println(user);<br>        }<br>    }<br>}<br>修改 MyBatis 的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的 Mapper 接口即可</p>
<mappers>
    <!--扫描使用注解的类-->
    <mapper class="com.itheima.mapper.UserMapper"></mapper>
</mappers>
或者指定扫描包含映射关系的接口所在的包也可以

<!--加载映射关系-->
<mappers>
    <!--指定接口所在的包-->
    <package name="com.itheima.mapper"></package>
</mappers>
UserMapper 改为注解形式

<p>public interface UserMapper {<br>    @Insert(“insert into user values(#{id},#{username},#{password},#{birthday})”)<br>    public void save(User user);</p>
<pre><code>@Update(&quot;update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;&quot;)
public void update(User user);

@Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)
public void delete(int id);

@Select(&quot;select * from user where id=#&#123;id&#125;&quot;)
public User findById(int id);

@Select(&quot;select * from user&quot;)
public List&lt;User&gt; findAll();
</code></pre>
<p>}</p>
<h3 id="1-3-MyBatis-的注解实现复杂映射开发"><a href="#1-3-MyBatis-的注解实现复杂映射开发" class="headerlink" title="1.3 MyBatis 的注解实现复杂映射开发"></a>1.3 MyBatis 的注解实现复杂映射开发</h3><p>实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用 @Results 注解，@Result 注解，@One 注解，@Many 注解组合完成复杂关系的配置</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221515997.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221515980.png" alt="在这里插入图片描述"></p>
<h3 id="1-4-一对一查询"><a href="#1-4-一对一查询" class="headerlink" title="1.4 一对一查询"></a>1.4 一对一查询</h3><p>（1） 一对一查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221515122.png" alt="在这里插入图片描述"></p>
<p>（2）一对一查询的语句<br>第一种方式：<br>对应的 sql 语句：<br>select *,o.id oid from orders o,user u where o.uid=u.id<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221516576.png" alt="在这里插入图片描述"></p>
<p>第二种方式：<br>select * from orders;<br>select * from user where id=查询出订单的uid;</p>
<p>（3）创建 Order 和 User 实体</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221516079.png" alt="在这里插入图片描述"></p>
<p>（4）创建 OrderMapper 接口</p>
<p>public interface OrderMapper {<br>    public List<Order> findAll();<br>}<br>（5）使用注解配置 Mapper<br>第一种方式：</p>
<p>public interface OrderMapper {<br>    @Select(“select *,o.id oid from orders o,user u where o.uid=u.id”)<br>    @Results({<br>            @Result(column = “oid”,property = “id”),<br>            @Result(column = “ordertime”,property = “ordertime”),<br>            @Result(column = “total”,property = “total”),<br>            @Result(column = “uid”,property = “user.id”),<br>            @Result(column = “username”,property = “user.username”),<br>            @Result(column = “password”,property = “user.password”)<br>    })<br>    public List<Order> findAll();<br>}</p>
<p>public interface UserMapper {<br>    @Select(“select * from user”)<br>    public List<User> findAll();<br>}<br>第二种方式：</p>
<p>public interface OrderMapper {<br>    @Select(“select * from orders”)<br>    @Results({<br>            @Result(column = “id”,property = “id”),<br>            @Result(column = “ordertime”,property = “ordertime”),<br>            @Result(column = “total”,property = “total”),<br>            @Result(<br>                    property = “user”, //要封装的属性名称<br>                    column = “uid”, //根据那个字段去查询user表的数据<br>                    javaType = User.class, //要封装的实体类型<br>                    //select属性 代表查询那个接口的方法获得数据<br>                    one = @One(select = “com.itheima.mapper.UserMapper.findById”)<br>            )<br>    })<br>    public List<Order> findAll();<br>}<br>public interface UserMapper {<br>    @Select(“select * from user where id=#{id}”)<br>    public User findById(int id);<br>}<br>（6）测试结果</p>
<p>@Test<br>public void testSelectOrderAndUser() {<br>    List<Order> all = orderMapper.findAll();<br>    for(Order order : all){<br>        System.out.println(order);<br>    }<br>}</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221516804.png" alt="在这里插入图片描述"></p>
<h3 id="1-5-一对多查询"><a href="#1-5-一对多查询" class="headerlink" title="1.5 一对多查询"></a>1.5 一对多查询</h3><p>（1）一对多查询的模型<br>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户<br>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221517018.png" alt="在这里插入图片描述"></p>
<p>（2）一对多查询的语句<br>对应的 sql 语句：<br>select * from user;<br>select * from orders where uid=查询出用户的id;<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221517663.png" alt="在这里插入图片描述"></p>
<p>（3）修改 User 实体</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221517975.png" alt="在这里插入图片描述"></p>
<p>（4）创建 UserMapper 接口</p>
<p>public List<User> findUserAndOrderAll();<br>（5）使用注解配置 Mapper</p>
<p>public interface UserMapper {<br>    @Select(“select * from user”)<br>    @Results({<br>            @Result(id=true ,column = “id”,property = “id”),<br>            @Result(column = “username”,property = “username”),<br>            @Result(column = “password”,property = “password”),<br>            @Result(<br>                    property = “orderList”,<br>                    column = “id”,<br>                    javaType = List.class,<br>                    many = @Many(select = “com.itheima.mapper.OrderMapper.findByUid”)<br>            )<br>    })<br>    public List<User> findUserAndOrderAll();<br>}<br>public interface OrderMapper {<br>    @Select(“select * from orders where uid=#{uid}”)<br>    public List<Order> findByUid(int uid);<br>}<br>（6）测试结果</p>
<p>List<User> all = userMapper.findAllUserAndOrder();<br>for(User user : all){<br>    System.out.println(user.getUsername());<br>    List<Order> orderList = user.getOrderList();<br>    for(Order order : orderList){<br>        System.out.println(order);<br>    }<br>    System.out.println(“—————————–”);<br>}</p>
<h3 id="1-6-多对多查询"><a href="#1-6-多对多查询" class="headerlink" title="1.6 多对多查询"></a>1.6 多对多查询</h3><p>（1）多对多查询的模型<br>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用<br>多对多查询的需求：查询用户同时查询出该用户的所有角色</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221518453.png" alt="img"></p>
<p>（2）多对多查询的语句<br>对应的 sql 语句：<br>select * from user;<br>select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=用户的id<br>查询的结果如下：</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221518922.png" alt="在这里插入图片描述"></p>
<p>（3）创建 Role 实体，修改 User 实体</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221519115.png" alt="在这里插入图片描述"></p>
<p>（4）添加 UserMapper 接口方法</p>
<p>public List<User> findUserAndRoleAll();<br>（5）使用注解配置 Mapper</p>
<p>public interface UserMapper {<br>    @Select(“SELECT * FROM USER”)<br>    @Results({<br>            @Result(id = true,column = “id”,property = “id”),<br>            @Result(column = “username”,property = “username”),<br>            @Result(column = “password”,property = “password”),<br>            @Result(<br>                    property = “roleList”,<br>                    column = “id”,<br>                    javaType = List.class,<br>                    many = @Many(select = “com.itheima.mapper.RoleMapper.findByUid”)<br>            )<br>    })<br>    public List<User> findUserAndRoleAll();<br>}<br>public interface RoleMapper {<br>    @Select(“SELECT * FROM sys_user_role ur,sys_role r WHERE ur.roleId=r.id AND ur.userId=#{uid}”)<br>    public List<Role> findByUid(int uid);<br>}<br>（6）测试结果</p>
<p>UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>List<User> all = mapper.findAllUserAndRole();<br>for(User user : all){<br>    System.out.println(user.getUsername());<br>    List<Role> roleList = user.getRoleList();<br>    for(Role role : roleList){<br>        System.out.println(role);<br>    }<br>    System.out.println(“———————————-“);<br>}</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221519937.png" alt="在这里插入图片描述"></p>
<h1 id="第十七章-SSM-整合"><a href="#第十七章-SSM-整合" class="headerlink" title="第十七章 SSM 整合"></a>第十七章 SSM 整合</h1><h2 id="1-SSM-框架整合"><a href="#1-SSM-框架整合" class="headerlink" title="1.SSM 框架整合"></a>1.SSM 框架整合</h2><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>（1）原始方式整合</p>
<p>create table account(<br>    id int primary key auto_increment,<br>    name varchar(100),<br>    money double(7,2)<br>);</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221609652.png" alt="在这里插入图片描述"></p>
<p>（2）创建 Maven 工程</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221610296.png" alt="在这里插入图片描述"></p>
<p>（3）导入 Maven 坐标</p>
<blockquote>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code><br><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</code><br>  <code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code></p>
<p>  <code>&lt;groupId&gt;com.itheima&lt;/groupId&gt;</code><br>  <code>&lt;artifactId&gt;itheima_ssm&lt;/artifactId&gt;</code><br>  <code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code><br>  <code>&lt;packaging&gt;war&lt;/packaging&gt;</code></p>
<p>  <code>&lt;name&gt;itheima_ssm Maven Webapp&lt;/name&gt;</code><br>  <code>&lt;!-- FIXME change it to the project&#39;s website --&gt;</code><br>  <code>&lt;url&gt;http://www.example.com&lt;/url&gt;</code></p>
<p>  <code>&lt;properties&gt;</code><br>    <code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</code><br>    <code>&lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</code><br>    <code>&lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</code><br>  <code>&lt;/properties&gt;</code></p>
<p>  <code>&lt;dependencies&gt;</code><br>    <code>&lt;!--spring相关--&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.aspectj&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;1.8.7&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-test&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code><br>    <code>&lt;dependency&gt;</code><br>      <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>      <code>&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</code><br>      <code>&lt;version&gt;5.0.5.RELEASE&lt;/version&gt;</code><br>    <code>&lt;/dependency&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--servlet和jsp--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--mybatis相关--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.9.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;jstl&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>  <code>&lt;/dependencies&gt;</code></p>
<p><code>&lt;/project&gt;</code><br>（4）编写实体类</p>
</blockquote>
<p>public class Account {<br>    private int id;<br>    private String name;<br>    private double money;<br>    //省略getter和setter方法<br>}<br>（5）编写 Mapper 接口</p>
<p>public interface AccountMapper {<br>    //保存账户数据<br>    void save(Account account);<br>    //查询账户数据<br>    List<Account> findAll();<br>}<br>（6）编写 Service 接口</p>
<p>public interface AccountService {<br>    void save(Account account); //保存账户数据<br>    List<Account> findAll(); //查询账户数据<br>}<br>（7）编写 Service 接口实现</p>
<p>@Service(“accountService”)<br>public class AccountServiceImpl implements AccountService {<br>    public void save(Account account) {<br>        SqlSession sqlSession = MyBatisUtils.openSession();<br>        AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class);<br>        accountMapper.save(account);<br>        sqlSession.commit();<br>        sqlSession.close();<br>    }<br>    public List<Account> findAll() {<br>        SqlSession sqlSession = MyBatisUtils.openSession();<br>        AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class);<br>        return accountMapper.findAll();<br>    }<br>}<br>（8）编写 Controller</p>
<p>@Controller<br>public class AccountController {<br>    @Autowired<br>    private AccountService accountService;<br>    @RequestMapping(“/save”)<br>    @ResponseBody<br>    public String save(Account account){<br>        accountService.save(account);<br>        return “save success”;<br>    }<br>    @RequestMapping(“/findAll”)<br>    public ModelAndView findAll(){<br>        ModelAndView modelAndView = new ModelAndView();<br>        modelAndView.setViewName(“accountList”);<br>        modelAndView.addObject(“accountList”,accountService.findAll());<br>        return modelAndView;<br>    }<br>}<br>（9）编写添加页面</p>
<p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p>
<html>

<head>
    <title>Title</title>
</head>

<body>
    <h1>保存账户信息表单</h1>
    <form action="${pageContext.request.contextPath}/save.action" method="post">
        用户名称<input type="text" name="name"><br/>
        账户金额<input type="text" name="money"><br/>
        <input type="submit" value="保存"><br/>
    </form>
</body>
</html>
（10）编写列表页面

<table border="1">
    <tr>
        <th>账户id</th>
        <th>账户名称</th>
        <th>账户金额</th>
    </tr>
    <c:forEach items="${accountList}" var="account">
        <tr>
            <td>${account.id}</td>
            <td>${account.name}</td>
            <td>${account.money}</td>
        </tr>
    </c:forEach>
</table>
（11）编写相应配置文件


<p>(12）测试添加账户</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221624284.png" alt="在这里插入图片描述"></p>
<p>（13）测试账户列表</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221624975.png" alt="在这里插入图片描述"></p>
<h2 id="2-Spring-整合-MyBatis"><a href="#2-Spring-整合-MyBatis" class="headerlink" title="2 Spring 整合 MyBatis"></a>2 Spring 整合 MyBatis</h2><p>（1）整合思路</p>
<p><img src="https://gitee.com/an-menghe/img/raw/master/test/202202221625229.png" alt="在这里插入图片描述"></p>
<p>（2）将 SqlSessionFactory 配置到 Spring 容器中</p>
<!--加载jdbc.properties-->
<p>&lt;context:property-placeholder location=”classpath:jdbc.properties”/&gt;</p>
<!--配置数据源-->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}"/>
    <property name="jdbcUrl" value="${jdbc.url}"/>
    <property name="user" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
<!--配置MyBatis的SqlSessionFactory-->
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="configLocation" value="classpath:sqlMapConfig.xml"/>
</bean>
（3）扫描 Mapper，让 Spring 容器产生 Mapper 实现类

<!--配置Mapper扫描-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.itheima.mapper"/>
</bean>
（4）配置声明式事务控制

<!--配置声明式事务控制-->
<!--配置平台事务管理器-->
<bean id="transacionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!--通知  事务的增强-->
<p>&lt;tx:advice id=”txAdvice” transaction-manager=”transacionManager”&gt;<br>    <a href="tx:attributes">tx:attributes</a><br>        &lt;tx:method name=”*”/&gt;<br>    </tx:attributes><br></tx:advice></p>
<!--配置事务的aop织入-->
<p><a href="aop:config">aop:config</a><br>    &lt;aop:pointcut id=”txPointcut” expression=”execution(* com.itheima.service.impl.*.*(..))”/&gt;<br>    &lt;aop:advisor advice-ref=”txAdvice” pointcut-ref=”txPointcut”/&gt;<br></aop:config></p>
<p>（5）修改 Service 实现类代码</p>
<p>@Service(“accountService”)<br>public class AccountServiceImpl implements AccountService {<br>    @Autowired<br>    private AccountMapper accountMapper;<br>    public void save(Account account) {<br>        accountMapper.save(account);<br>    }<br>    public List<Account> findAll() {<br>        return accountMapper.findAll();<br>    }<br>}</p>

      </div>
    </div>
  </div>
</div>
<div class="lx-navigation">
	<div class="lx-cover next lx-cover-sm" style="background-image: url(https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/images/footer-l.min.jpeg)">
		<div class="overlay"></div>
		<a class="copy" href="#">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Next</span>
						<h3>No newer post</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
        <div class="lx-cover prev lx-cover-sm" style="background-image: url(https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/images/footer-r.min.jpeg)">
		<div class="overlay"></div>
		<a class="copy" href="/2022/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Java/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Prev</span>
						<h3>java数据结构</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
</div>

</div>

<footer>
  <div>
  Copyright &copy; 2022.<a href="/">Hexo</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

</div>

<button class="hamburger hamburger--arrow-r" type="button" title="menu">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button>
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/images/avatar.min.jpeg" alt="xiaoxin"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>xiaoxin</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>Home</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
    
    
    
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>
<script src="https://cdn.jsdelivr.net/npm/theme-lx@0.4.3/source/dist/js/local.search.min.js"></script>

</body>
</html>
